/**
 * Brevo API
 * Brevo provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/brevo  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  |
 *
 * OpenAPI spec version: 3.0.0
 * Contact: contact@brevo.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as localVarRequest from "request";
import * as http from "http";

const defaultBasePath = "https://api.brevo.com/v3";
const version = "4.0.0";
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
const primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any",
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      const discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      const transformedData: any[] = [];
      for (const index in data) {
        const date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      const attributeTypes = typeMap[type].getAttributeTypeMap();
      const instance: { [index: string]: any } = {};
      for (const index in attributeTypes) {
        const attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      const transformedData: any[] = [];
      for (const index in data) {
        const date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      const instance = new typeMap[type]();
      const attributeTypes = typeMap[type].getAttributeTypeMap();
      for (const index in attributeTypes) {
        const attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type
        );
      }
      return instance;
    }
  }
}

export class AbTestCampaignResult {
  /**
   * Winning Campaign Info. pending = Campaign has been picked for sending and winning version is yet to be decided, tie = A tie happened between both the versions, notAvailable = Campaign has not yet been picked for sending.
   */
  "winningVersion"?: AbTestCampaignResult.WinningVersionEnum;
  /**
   * Criteria choosen for winning version (Open/Click)
   */
  "winningCriteria"?: AbTestCampaignResult.WinningCriteriaEnum;
  /**
   * Subject Line of current winning version
   */
  "winningSubjectLine"?: string;
  /**
   * Open rate for current winning version
   */
  "openRate"?: string;
  /**
   * Click rate for current winning version
   */
  "clickRate"?: string;
  /**
   * Open/Click rate for the winner version
   */
  "winningVersionRate"?: string;
  "statistics"?: AbTestCampaignResultStatistics;
  "clickedLinks"?: AbTestCampaignResultClickedLinks;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "winningVersion",
      baseName: "winningVersion",
      type: "AbTestCampaignResult.WinningVersionEnum",
    },
    {
      name: "winningCriteria",
      baseName: "winningCriteria",
      type: "AbTestCampaignResult.WinningCriteriaEnum",
    },
    {
      name: "winningSubjectLine",
      baseName: "winningSubjectLine",
      type: "string",
    },
    {
      name: "openRate",
      baseName: "openRate",
      type: "string",
    },
    {
      name: "clickRate",
      baseName: "clickRate",
      type: "string",
    },
    {
      name: "winningVersionRate",
      baseName: "winningVersionRate",
      type: "string",
    },
    {
      name: "statistics",
      baseName: "statistics",
      type: "AbTestCampaignResultStatistics",
    },
    {
      name: "clickedLinks",
      baseName: "clickedLinks",
      type: "AbTestCampaignResultClickedLinks",
    },
  ];

  static getAttributeTypeMap() {
    return AbTestCampaignResult.attributeTypeMap;
  }
}

export namespace AbTestCampaignResult {
  export enum WinningVersionEnum {
    NotAvailable = <any>"notAvailable",
    Pending = <any>"pending",
    Tie = <any>"tie",
    A = <any>"A",
    B = <any>"B",
  }
  export enum WinningCriteriaEnum {
    Open = <any>"Open",
    Click = <any>"Click",
  }
}
export class AbTestCampaignResultClickedLinks {
  "versionA": AbTestVersionClicks;
  "versionB": AbTestVersionClicks;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "versionA",
      baseName: "Version A",
      type: "AbTestVersionClicks",
    },
    {
      name: "versionB",
      baseName: "Version B",
      type: "AbTestVersionClicks",
    },
  ];

  static getAttributeTypeMap() {
    return AbTestCampaignResultClickedLinks.attributeTypeMap;
  }
}

export class AbTestCampaignResultStatistics {
  "openers": AbTestVersionStats;
  "clicks": AbTestVersionStats;
  "unsubscribed": AbTestVersionStats;
  "hardBounces": AbTestVersionStats;
  "softBounces": AbTestVersionStats;
  "complaints": AbTestVersionStats;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "openers",
      baseName: "openers",
      type: "AbTestVersionStats",
    },
    {
      name: "clicks",
      baseName: "clicks",
      type: "AbTestVersionStats",
    },
    {
      name: "unsubscribed",
      baseName: "unsubscribed",
      type: "AbTestVersionStats",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "AbTestVersionStats",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "AbTestVersionStats",
    },
    {
      name: "complaints",
      baseName: "complaints",
      type: "AbTestVersionStats",
    },
  ];

  static getAttributeTypeMap() {
    return AbTestCampaignResultStatistics.attributeTypeMap;
  }
}

/**
 * Information on clicked links for a particular version
 */
export class AbTestVersionClicks extends Array<AbTestVersionClicksInner> {
  static discriminator: string | undefined = undefined;
}

export class AbTestVersionClicksInner {
  /**
   * URL of the link
   */
  "link": string;
  /**
   * Number of times a link is clicked
   */
  "clicksCount": number;
  /**
   * Percentage of clicks of link with respect to total clicks
   */
  "clickRate": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "link",
      baseName: "link",
      type: "string",
    },
    {
      name: "clicksCount",
      baseName: "clicksCount",
      type: "number",
    },
    {
      name: "clickRate",
      baseName: "clickRate",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return AbTestVersionClicksInner.attributeTypeMap;
  }
}

/**
 * Percentage of a particular event for both versions
 */
export class AbTestVersionStats {
  /**
   * percentage of an event for version A
   */
  "versionA": string;
  /**
   * percentage of an event for version B
   */
  "versionB": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "versionA",
      baseName: "Version A",
      type: "string",
    },
    {
      name: "versionB",
      baseName: "Version B",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return AbTestVersionStats.attributeTypeMap;
  }
}

export class AddChildDomain {
  /**
   * Sender domain to add for a specific child account
   */
  "domain"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return AddChildDomain.attributeTypeMap;
  }
}

export class AddContactToList {
  /**
   * Mandatory if IDs are not passed, ignored otherwise. Emails to add to a list. You can pass a maximum of 150 emails for addition in one request. If you need to add the emails in bulk, please prefer /contacts/import api.
   */
  "emails"?: Array<string>;
  /**
   * Mandatory if Emails are not passed, ignored otherwise. Emails to add to a list. You can pass a maximum of 150 emails for addition in one request. If you need to add the emails in bulk, please prefer /contacts/import api.
   */
  "ids"?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "emails",
      baseName: "emails",
      type: "Array<string>",
    },
    {
      name: "ids",
      baseName: "ids",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return AddContactToList.attributeTypeMap;
  }
}

export class AddCredits {
  /**
   * Required if email credits are empty. SMS credits to be added to the child account
   */
  "sms"?: number;
  /**
   * Required if sms credits are empty. Email credits to be added to the child account
   */
  "email"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sms",
      baseName: "sms",
      type: "number",
    },
    {
      name: "email",
      baseName: "email",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return AddCredits.attributeTypeMap;
  }
}

export class AuthenticateDomainModel {
  /**
   * Domain
   */
  "domainName": string;
  /**
   * Success message
   */
  "message": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domainName",
      baseName: "domain_name",
      type: "string",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return AuthenticateDomainModel.attributeTypeMap;
  }
}

export class BlockDomain {
  /**
   * name of the domain to be blocked
   */
  "domain": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return BlockDomain.attributeTypeMap;
  }
}

export class Body {
  /**
   * Name of company
   */
  "name": string;
  /**
   * Attributes for company creation
   */
  "attributes"?: any;
  /**
   * Country code if phone_number is passed in attributes.
   */
  "countryCode"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
    {
      name: "countryCode",
      baseName: "countryCode",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return Body.attributeTypeMap;
  }
}

export class Body1 {
  /**
   * Name of company
   */
  "name"?: string;
  /**
   * Attributes for company update
   */
  "attributes"?: any;
  /**
   * Country code if phone_number is passed in attributes.
   */
  "countryCode"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
    {
      name: "countryCode",
      baseName: "countryCode",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return Body1.attributeTypeMap;
  }
}

export class Body10 {
  /**
   * visitor’s ID received <a href=\"https://developers.brevo.com/docs/conversations-webhooks\">from a webhook</a> or generated by you to <a href=\"https://developers.brevo.com/docs/customize-the-widget#identifying-existing-users\">bind existing user account to Conversations</a>
   */
  "visitorId": string;
  /**
   * message text
   */
  "text": string;
  /**
   * agent ID. It can be found on agent’s page or received <a href=\"https://developers.brevo.com/docs/conversations-webhooks\">from a webhook</a>. Optional if `groupId` is set.
   */
  "agentId"?: string;
  /**
   * group ID. It can be found on group’s page. Optional if `agentId` is set.
   */
  "groupId"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "visitorId",
      baseName: "visitorId",
      type: "string",
    },
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
    {
      name: "agentId",
      baseName: "agentId",
      type: "string",
    },
    {
      name: "groupId",
      baseName: "groupId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Body10.attributeTypeMap;
  }
}

export class Body11 {
  /**
   * edited message text
   */
  "text": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Body11.attributeTypeMap;
  }
}

export class Body12 {
  /**
   * agent ID. It can be found on agent’s page or received <a href=\"https://developers.brevo.com/docs/conversations-webhooks\">from a webhook</a>. Alternatively, you can use `agentEmail` + `agentName` + `receivedFrom` instead (all 3 fields required).
   */
  "agentId"?: string;
  /**
   * mark your messages to distinguish messages created by you from the others.
   */
  "receivedFrom"?: string;
  /**
   * agent email. When sending online pings from a standalone system, it’s hard to maintain a 1-to-1 relationship between the users of both systems. In this case, an agent can be specified by their email address. If there’s no agent with the specified email address in your Brevo organization, a dummy agent will be created automatically.
   */
  "agentEmail"?: string;
  /**
   * agent name.
   */
  "agentName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "agentId",
      baseName: "agentId",
      type: "string",
    },
    {
      name: "receivedFrom",
      baseName: "receivedFrom",
      type: "string",
    },
    {
      name: "agentEmail",
      baseName: "agentEmail",
      type: "string",
    },
    {
      name: "agentName",
      baseName: "agentName",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Body12.attributeTypeMap;
  }
}

export class Body2 {
  /**
   * Contact ids for contacts to be linked with company
   */
  "linkContactIds"?: Array<number>;
  /**
   * Contact ids for contacts to be unlinked from company
   */
  "unlinkContactIds"?: Array<number>;
  /**
   * Deals ids for deals to be linked with company
   */
  "linkDealsIds"?: Array<string>;
  /**
   * Deals ids for deals to be unlinked from company
   */
  "unlinkDealsIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "linkContactIds",
      baseName: "linkContactIds",
      type: "Array<number>",
    },
    {
      name: "unlinkContactIds",
      baseName: "unlinkContactIds",
      type: "Array<number>",
    },
    {
      name: "linkDealsIds",
      baseName: "linkDealsIds",
      type: "Array<string>",
    },
    {
      name: "unlinkDealsIds",
      baseName: "unlinkDealsIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return Body2.attributeTypeMap;
  }
}

export class Body3 {
  /**
   * Name of deal
   */
  "name": string;
  /**
   * Attributes fo\\r deal creation
   */
  "attributes"?: any;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
  ];

  static getAttributeTypeMap() {
    return Body3.attributeTypeMap;
  }
}

export class Body4 {
  /**
   * Name of deal
   */
  "name"?: string;
  /**
   * Attributes for deal update
   */
  "attributes"?: any;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
  ];

  static getAttributeTypeMap() {
    return Body4.attributeTypeMap;
  }
}

export class Body5 {
  /**
   * Contact ids for contacts to be linked with deal
   */
  "linkContactIds"?: Array<number>;
  /**
   * Contact ids for contacts to be unlinked from deal
   */
  "unlinkContactIds"?: Array<number>;
  /**
   * Company ids to be linked with deal
   */
  "linkCompanyIds"?: Array<string>;
  /**
   * Company ids to be unlinked from deal
   */
  "unlinkCompanyIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "linkContactIds",
      baseName: "linkContactIds",
      type: "Array<number>",
    },
    {
      name: "unlinkContactIds",
      baseName: "unlinkContactIds",
      type: "Array<number>",
    },
    {
      name: "linkCompanyIds",
      baseName: "linkCompanyIds",
      type: "Array<string>",
    },
    {
      name: "unlinkCompanyIds",
      baseName: "unlinkCompanyIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return Body5.attributeTypeMap;
  }
}

export class Body6 {
  /**
   * Name of task
   */
  "name": string;
  /**
   * Duration of task in milliseconds [1 minute = 60000 ms]
   */
  "duration"?: number;
  /**
   * Id for type of task e.g Call / Email / Meeting etc.
   */
  "taskTypeId": string;
  /**
   * Task due date and time
   */
  "date": Date;
  /**
   * Notes added to a task
   */
  "notes"?: string;
  /**
   * Task marked as done
   */
  "done"?: boolean;
  /**
   * User id to whom task is assigned
   */
  "assignToId"?: string;
  /**
   * Contact ids for contacts linked to this task
   */
  "contactsIds"?: Array<number>;
  /**
   * Deal ids for deals a task is linked to
   */
  "dealsIds"?: Array<string>;
  /**
   * Companies ids for companies a task is linked to
   */
  "companiesIds"?: Array<string>;
  "reminder"?: TaskReminder;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "duration",
      baseName: "duration",
      type: "number",
    },
    {
      name: "taskTypeId",
      baseName: "taskTypeId",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "Date",
    },
    {
      name: "notes",
      baseName: "notes",
      type: "string",
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean",
    },
    {
      name: "assignToId",
      baseName: "assignToId",
      type: "string",
    },
    {
      name: "contactsIds",
      baseName: "contactsIds",
      type: "Array<number>",
    },
    {
      name: "dealsIds",
      baseName: "dealsIds",
      type: "Array<string>",
    },
    {
      name: "companiesIds",
      baseName: "companiesIds",
      type: "Array<string>",
    },
    {
      name: "reminder",
      baseName: "reminder",
      type: "TaskReminder",
    },
  ];

  static getAttributeTypeMap() {
    return Body6.attributeTypeMap;
  }
}

export class Body7 {
  /**
   * Name of task
   */
  "name"?: string;
  /**
   * Duration of task in milliseconds [1 minute = 60000 ms]
   */
  "duration"?: number;
  /**
   * Id for type of task e.g Call / Email / Meeting etc.
   */
  "taskTypeId"?: string;
  /**
   * Task date/time
   */
  "date"?: Date;
  /**
   * Notes added to a task
   */
  "notes"?: string;
  /**
   * Task marked as done
   */
  "done"?: boolean;
  /**
   * User id to whom task is assigned
   */
  "assignToId"?: string;
  /**
   * Contact ids for contacts linked to this task
   */
  "contactsIds"?: Array<number>;
  /**
   * Deal ids for deals a task is linked to
   */
  "dealsIds"?: Array<string>;
  /**
   * Companies ids for companies a task is linked to
   */
  "companiesIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "duration",
      baseName: "duration",
      type: "number",
    },
    {
      name: "taskTypeId",
      baseName: "taskTypeId",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "Date",
    },
    {
      name: "notes",
      baseName: "notes",
      type: "string",
    },
    {
      name: "done",
      baseName: "done",
      type: "boolean",
    },
    {
      name: "assignToId",
      baseName: "assignToId",
      type: "string",
    },
    {
      name: "contactsIds",
      baseName: "contactsIds",
      type: "Array<number>",
    },
    {
      name: "dealsIds",
      baseName: "dealsIds",
      type: "Array<string>",
    },
    {
      name: "companiesIds",
      baseName: "companiesIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return Body7.attributeTypeMap;
  }
}

export class Body8 {
  /**
   * visitor’s ID received <a href=\"https://developers.brevo.com/docs/conversations-webhooks\">from a webhook</a> or generated by you to <a href=\"https://developers.brevo.com/docs/customize-the-widget#identifying-existing-users\">bind existing user account to Conversations</a>
   */
  "visitorId": string;
  /**
   * message text
   */
  "text": string;
  /**
   * agent ID. It can be found on agent’s page or received <a href=\"https://developers.brevo.com/docs/conversations-webhooks\">from a webhook</a>. Alternatively, you can use `agentEmail` + `agentName` + `receivedFrom` instead (all 3 fields required).
   */
  "agentId"?: string;
  /**
   * mark your messages to distinguish messages created by you from the others.
   */
  "receivedFrom"?: string;
  /**
   * agent email. When sending messages from a standalone system, it’s hard to maintain a 1-to-1 relationship between the users of both systems. In this case, an agent can be specified by their email address.
   */
  "agentEmail"?: string;
  /**
   * agent name
   */
  "agentName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "visitorId",
      baseName: "visitorId",
      type: "string",
    },
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
    {
      name: "agentId",
      baseName: "agentId",
      type: "string",
    },
    {
      name: "receivedFrom",
      baseName: "receivedFrom",
      type: "string",
    },
    {
      name: "agentEmail",
      baseName: "agentEmail",
      type: "string",
    },
    {
      name: "agentName",
      baseName: "agentName",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Body8.attributeTypeMap;
  }
}

export class Body9 {
  /**
   * edited message text
   */
  "text": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Body9.attributeTypeMap;
  }
}

export class BodyVariablesItems {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return BodyVariablesItems.attributeTypeMap;
  }
}

/**
 * List of companies
 */
export class CompaniesList {
  /**
   * List of compaies
   */
  "items"?: Array<Company>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "items",
      baseName: "items",
      type: "Array<Company>",
    },
  ];

  static getAttributeTypeMap() {
    return CompaniesList.attributeTypeMap;
  }
}

/**
 * Company Details
 */
export class Company {
  /**
   * Unique company id
   */
  "id"?: string;
  /**
   * Company attributes with values
   */
  "attributes"?: any;
  /**
   * Contact ids for contacts linked to this company
   */
  "linkedContactsIds"?: Array<number>;
  /**
   * Deals ids for companies linked to this company
   */
  "linkedDealsIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
    {
      name: "linkedContactsIds",
      baseName: "linkedContactsIds",
      type: "Array<number>",
    },
    {
      name: "linkedDealsIds",
      baseName: "linkedDealsIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return Company.attributeTypeMap;
  }
}

/**
 * List of company attributes
 */
export class CompanyAttributes extends Array<CompanyAttributesInner> {
  static discriminator: string | undefined = undefined;
}

/**
 * List of attributes
 */
export class CompanyAttributesInner {
  "internalName"?: string;
  "label"?: string;
  "attributeTypeName"?: string;
  "attributeOptions"?: Array<any>;
  "isRequired"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "internalName",
      baseName: "internalName",
      type: "string",
    },
    {
      name: "label",
      baseName: "label",
      type: "string",
    },
    {
      name: "attributeTypeName",
      baseName: "attributeTypeName",
      type: "string",
    },
    {
      name: "attributeOptions",
      baseName: "attributeOptions",
      type: "Array<any>",
    },
    {
      name: "isRequired",
      baseName: "isRequired",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CompanyAttributesInner.attributeTypeMap;
  }
}

export class ComponentItems {
  "type"?: string;
  "text"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "string",
    },
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ComponentItems.attributeTypeMap;
  }
}

/**
 * a Conversations message
 */
export class ConversationsMessage {
  /**
   * Message ID. It can be used for further manipulations with the message.
   */
  "id"?: string;
  /**
   * `\"agent\"` for agents’ messages, `\"visitor\"` for visitors’ messages.
   */
  "type"?: ConversationsMessage.TypeEnum;
  /**
   * Message text or name of the attached file
   */
  "text"?: string;
  /**
   * visitor’s ID
   */
  "visitorId"?: string;
  /**
   * ID of the agent on whose behalf the message was sent (only in messages sent by an agent).
   */
  "agentId"?: string;
  /**
   * Agent’s name as displayed to the visitor. Only in the messages sent by an agent.
   */
  "agentName"?: string;
  /**
   * Timestamp in milliseconds.
   */
  "createdAt"?: number;
  /**
   * `true` for pushed messages
   */
  "isPushed"?: boolean;
  /**
   * In two-way integrations, messages sent via REST API can be marked with receivedFrom property and then filtered out when received in a webhook to avoid infinite loop.
   */
  "receivedFrom"?: string;
  "file"?: ConversationsMessageFile;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "type",
      baseName: "type",
      type: "ConversationsMessage.TypeEnum",
    },
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
    {
      name: "visitorId",
      baseName: "visitorId",
      type: "string",
    },
    {
      name: "agentId",
      baseName: "agentId",
      type: "string",
    },
    {
      name: "agentName",
      baseName: "agentName",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "number",
    },
    {
      name: "isPushed",
      baseName: "isPushed",
      type: "boolean",
    },
    {
      name: "receivedFrom",
      baseName: "receivedFrom",
      type: "string",
    },
    {
      name: "file",
      baseName: "file",
      type: "ConversationsMessageFile",
    },
  ];

  static getAttributeTypeMap() {
    return ConversationsMessage.attributeTypeMap;
  }
}

export namespace ConversationsMessage {
  export enum TypeEnum {
    Agent = <any>"agent",
    Visitor = <any>"visitor",
  }
}
export class ConversationsMessageFile {
  /**
   * Name of the file
   */
  "filename"?: string;
  /**
   * Size in bytes
   */
  "size"?: number;
  /**
   * Whether the file is an image
   */
  "isImage"?: boolean;
  /**
   * URL of the file
   */
  "url"?: string;
  "imageInfo"?: ConversationsMessageFileImageInfo;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "filename",
      baseName: "filename",
      type: "string",
    },
    {
      name: "size",
      baseName: "size",
      type: "number",
    },
    {
      name: "isImage",
      baseName: "isImage",
      type: "boolean",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "imageInfo",
      baseName: "imageInfo",
      type: "ConversationsMessageFileImageInfo",
    },
  ];

  static getAttributeTypeMap() {
    return ConversationsMessageFile.attributeTypeMap;
  }
}

/**
 * image info is passed in case the file is an image
 */
export class ConversationsMessageFileImageInfo {
  /**
   * Width of the image
   */
  "width"?: number;
  /**
   * height of the image
   */
  "height"?: number;
  /**
   * URL of the preview
   */
  "previewUrl"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "width",
      baseName: "width",
      type: "number",
    },
    {
      name: "height",
      baseName: "height",
      type: "number",
    },
    {
      name: "previewUrl",
      baseName: "previewUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ConversationsMessageFileImageInfo.attributeTypeMap;
  }
}

export class CreateApiKeyRequest {
  /**
   * Id of the sub-account organization
   */
  "id": number;
  /**
   * Name of the API key
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateApiKeyRequest.attributeTypeMap;
  }
}

export class CreateApiKeyResponse {
  /**
   * Status of the API operation.
   */
  "status"?: string;
  /**
   * API Key
   */
  "key"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "status",
      baseName: "status",
      type: "string",
    },
    {
      name: "key",
      baseName: "key",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateApiKeyResponse.attributeTypeMap;
  }
}

export class CreateAttribute {
  /**
   * Value of the attribute. Use only if the attribute's category is 'calculated' or 'global'
   */
  "value"?: string;
  /**
   * Type of the attribute. Use only if the attribute's category is 'calculated' or 'global'
   */
  "isRecurring"?: boolean;
  /**
   * List of values and labels that the attribute can take. Use only if the attribute's category is \"category\". For example, [{\"value\":1, \"label\":\"male\"}, {\"value\":2, \"label\":\"female\"}]
   */
  "enumeration"?: Array<CreateAttributeEnumeration>;
  /**
   * Type of the attribute. Use only if the attribute's category is 'normal', 'category' or 'transactional' ( type 'boolean' is only available if the category is 'normal' attribute, type 'id' is only available if the category is 'transactional' attribute & type 'category' is only available if the category is 'category' attribute )
   */
  "type"?: CreateAttribute.TypeEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "value",
      baseName: "value",
      type: "string",
    },
    {
      name: "isRecurring",
      baseName: "isRecurring",
      type: "boolean",
    },
    {
      name: "enumeration",
      baseName: "enumeration",
      type: "Array<CreateAttributeEnumeration>",
    },
    {
      name: "type",
      baseName: "type",
      type: "CreateAttribute.TypeEnum",
    },
  ];

  static getAttributeTypeMap() {
    return CreateAttribute.attributeTypeMap;
  }
}

export namespace CreateAttribute {
  export enum TypeEnum {
    Text = <any>"text",
    Date = <any>"date",
    Float = <any>"float",
    Boolean = <any>"boolean",
    Id = <any>"id",
    Category = <any>"category",
  }
}
export class CreateAttributeEnumeration {
  /**
   * Id of the value
   */
  "value": number;
  /**
   * Label of the value
   */
  "label": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "value",
      baseName: "value",
      type: "number",
    },
    {
      name: "label",
      baseName: "label",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateAttributeEnumeration.attributeTypeMap;
  }
}

export class CreateCategoryModel {
  /**
   * ID of the category when a new category is created
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateCategoryModel.attributeTypeMap;
  }
}

export class CreateChild {
  /**
   * Email address to create the child account
   */
  "email": string;
  /**
   * First name to use to create the child account
   */
  "firstName": string;
  /**
   * Last name to use to create the child account
   */
  "lastName": string;
  /**
   * Company name to use to create the child account
   */
  "companyName": string;
  /**
   * Password for the child account to login
   */
  "password": string;
  /**
   * Language of the child account
   */
  "language"?: CreateChild.LanguageEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "firstName",
      baseName: "firstName",
      type: "string",
    },
    {
      name: "lastName",
      baseName: "lastName",
      type: "string",
    },
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
    {
      name: "password",
      baseName: "password",
      type: "string",
    },
    {
      name: "language",
      baseName: "language",
      type: "CreateChild.LanguageEnum",
    },
  ];

  static getAttributeTypeMap() {
    return CreateChild.attributeTypeMap;
  }
}

export namespace CreateChild {
  export enum LanguageEnum {
    Fr = <any>"fr",
    Es = <any>"es",
    Pt = <any>"pt",
    It = <any>"it",
    De = <any>"de",
    En = <any>"en",
  }
}
export class CreateContact {
  /**
   * Email address of the user. Mandatory if \"SMS\" field is not passed in \"attributes\" parameter. Mobile Number in \"SMS\" field should be passed with proper country code. For example {\"SMS\":\"+91xxxxxxxxxx\"} or {\"SMS\":\"0091xxxxxxxxxx\"}
   */
  "email"?: string;
  /**
   * Pass your own Id to create a contact.
   */
  "extId"?: string;
  /**
   * Pass the set of attributes and their values. The attribute's parameter should be passed in capital letter while creating a contact. These attributes must be present in your Brevo account. For eg. {\"FNAME\":\"Elly\", \"LNAME\":\"Roger\"}
   */
  "attributes"?: any;
  /**
   * Set this field to blacklist the contact for emails (emailBlacklisted = true)
   */
  "emailBlacklisted"?: boolean;
  /**
   * Set this field to blacklist the contact for SMS (smsBlacklisted = true)
   */
  "smsBlacklisted"?: boolean;
  /**
   * Ids of the lists to add the contact to
   */
  "listIds"?: Array<number>;
  /**
   * Facilitate to update the existing contact in the same request (updateEnabled = true)
   */
  "updateEnabled"?: boolean;
  /**
   * transactional email forbidden sender for contact. Use only for email Contact ( only available if updateEnabled = true )
   */
  "smtpBlacklistSender"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "extId",
      baseName: "ext_id",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
    {
      name: "emailBlacklisted",
      baseName: "emailBlacklisted",
      type: "boolean",
    },
    {
      name: "smsBlacklisted",
      baseName: "smsBlacklisted",
      type: "boolean",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "updateEnabled",
      baseName: "updateEnabled",
      type: "boolean",
    },
    {
      name: "smtpBlacklistSender",
      baseName: "smtpBlacklistSender",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return CreateContact.attributeTypeMap;
  }
}

export class CreateDoiContact {
  /**
   * Email address where the confirmation email will be sent. This email address will be the identifier for all other contact attributes.
   */
  "email": string;
  /**
   * Pass the set of attributes and their values. These attributes must be present in your Brevo account. For eg. {'FNAME':'Elly', 'LNAME':'Roger'}
   */
  "attributes"?: any;
  /**
   * Lists under user account where contact should be added
   */
  "includeListIds": Array<number>;
  /**
   * Lists under user account where contact should not be added
   */
  "excludeListIds"?: Array<number>;
  /**
   * Id of the Double opt-in (DOI) template
   */
  "templateId": number;
  /**
   * URL of the web page that user will be redirected to after clicking on the double opt in URL. When editing your DOI template you can reference this URL by using the tag {{ params.DOIurl }}.
   */
  "redirectionUrl": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
    {
      name: "includeListIds",
      baseName: "includeListIds",
      type: "Array<number>",
    },
    {
      name: "excludeListIds",
      baseName: "excludeListIds",
      type: "Array<number>",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
    {
      name: "redirectionUrl",
      baseName: "redirectionUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateDoiContact.attributeTypeMap;
  }
}

export class CreateDomain {
  /**
   * Domain name
   */
  "name": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateDomain.attributeTypeMap;
  }
}

export class CreateDomainModel {
  /**
   * ID of the Domain created
   */
  "id": number;
  /**
   * Domain
   */
  "domainName"?: string;
  /**
   * Success message
   */
  "message"?: string;
  "dnsRecords"?: CreateDomainModelDnsRecords;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "domainName",
      baseName: "domain_name",
      type: "string",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "dnsRecords",
      baseName: "dns_records",
      type: "CreateDomainModelDnsRecords",
    },
  ];

  static getAttributeTypeMap() {
    return CreateDomainModel.attributeTypeMap;
  }
}

export class CreateDomainModelDnsRecords {
  "dkimRecord"?: CreateDomainModelDnsRecordsDkimRecord;
  "brevoCode"?: CreateDomainModelDnsRecordsDkimRecord;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "dkimRecord",
      baseName: "dkim_record",
      type: "CreateDomainModelDnsRecordsDkimRecord",
    },
    {
      name: "brevoCode",
      baseName: "brevo_code",
      type: "CreateDomainModelDnsRecordsDkimRecord",
    },
  ];

  static getAttributeTypeMap() {
    return CreateDomainModelDnsRecords.attributeTypeMap;
  }
}

export class CreateDomainModelDnsRecordsDkimRecord {
  "type"?: string;
  "value"?: string;
  "hostName"?: string;
  "status"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "string",
    },
    {
      name: "value",
      baseName: "value",
      type: "string",
    },
    {
      name: "hostName",
      baseName: "host_name",
      type: "string",
    },
    {
      name: "status",
      baseName: "status",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CreateDomainModelDnsRecordsDkimRecord.attributeTypeMap;
  }
}

export class CreateEmailCampaign {
  /**
   * Tag of the campaign
   */
  "tag"?: string;
  "sender": CreateEmailCampaignSender;
  /**
   * Name of the campaign
   */
  "name": string;
  /**
   * Mandatory if htmlUrl and templateId are empty. Body of the message (HTML)
   */
  "htmlContent"?: string;
  /**
   * Mandatory if htmlContent and templateId are empty. Url to the message (HTML)
   */
  "htmlUrl"?: string;
  /**
   * Mandatory if htmlContent and htmlUrl are empty. Id of the transactional email template with status 'active'. Used to copy only its content fetched from htmlContent/htmlUrl to an email campaign for RSS feature.
   */
  "templateId"?: number;
  /**
   * Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
   */
  "scheduledAt"?: string;
  /**
   * Subject of the campaign. Mandatory if abTesting is false. Ignored if abTesting is true.
   */
  "subject"?: string;
  /**
   * Email on which the campaign recipients will be able to reply to
   */
  "replyTo"?: string;
  /**
   * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your Brevo account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
   */
  "toField"?: string;
  "recipients"?: CreateEmailCampaignRecipients;
  /**
   * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
   */
  "attachmentUrl"?: string;
  /**
   * Use true to embedded the images in your email. Final size of the email should be less than 4MB. Campaigns with embedded images can not be sent to more than 5000 contacts
   */
  "inlineImageActivation"?: boolean;
  /**
   * Use true to enable the mirror link
   */
  "mirrorActive"?: boolean;
  /**
   * Footer of the email campaign
   */
  "footer"?: string;
  /**
   * Header of the email campaign
   */
  "header"?: string;
  /**
   * Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
   */
  "utmCampaign"?: string;
  /**
   * Pass the set of attributes to customize the type classic campaign. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. Only available if 'type' is 'classic'. It's considered only if campaign is in New Template Language format. The New Template Language is dependent on the values of 'subject', 'htmlContent/htmlUrl', 'sender.name' & 'toField'
   */
  "params"?: any;
  /**
   * Set this to true if you want to send your campaign at best time.
   */
  "sendAtBestTime"?: boolean;
  /**
   * Status of A/B Test. abTesting = false means it is disabled, & abTesting = true means it is enabled. 'subjectA', 'subjectB', 'splitRule', 'winnerCriteria' & 'winnerDelay' will be considered when abTesting is set to true. 'subjectA' & 'subjectB' are mandatory together & 'subject' if passed is ignored. Can be set to true only if 'sendAtBestTime' is 'false'. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
   */
  "abTesting"?: boolean;
  /**
   * Subject A of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
   */
  "subjectA"?: string;
  /**
   * Subject B of the campaign. Mandatory if abTesting = true. subjectA & subjectB should have unique value
   */
  "subjectB"?: string;
  /**
   * Add the size of your test groups. Mandatory if abTesting = true & 'recipients' is passed. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
   */
  "splitRule"?: number;
  /**
   * Choose the metrics that will determinate the winning version. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed
   */
  "winnerCriteria"?: CreateEmailCampaign.WinnerCriteriaEnum;
  /**
   * Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. Mandatory if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerDelay' is ignored if passed
   */
  "winnerDelay"?: number;
  /**
   * Available for dedicated ip clients. Set this to true if you wish to warm up your ip.
   */
  "ipWarmupEnable"?: boolean;
  /**
   * Mandatory if ipWarmupEnable is set to true. Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
   */
  "initialQuota"?: number;
  /**
   * Mandatory if ipWarmupEnable is set to true. Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
   */
  "increaseRate"?: number;
  /**
   * Enter an unsubscription page id. The page id is a 24 digit alphanumeric id that can be found in the URL when editing the page. If not entered, then the default unsubscription page will be used.
   */
  "unsubscriptionPageId"?: string;
  /**
   * Mandatory if templateId is used containing the {{ update_profile }} tag. Enter an update profile form id. The form id is a 24 digit alphanumeric id that can be found in the URL when editing the form. If not entered, then the default update profile form will be used.
   */
  "updateFormId"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "CreateEmailCampaignSender",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "htmlContent",
      baseName: "htmlContent",
      type: "string",
    },
    {
      name: "htmlUrl",
      baseName: "htmlUrl",
      type: "string",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "string",
    },
    {
      name: "toField",
      baseName: "toField",
      type: "string",
    },
    {
      name: "recipients",
      baseName: "recipients",
      type: "CreateEmailCampaignRecipients",
    },
    {
      name: "attachmentUrl",
      baseName: "attachmentUrl",
      type: "string",
    },
    {
      name: "inlineImageActivation",
      baseName: "inlineImageActivation",
      type: "boolean",
    },
    {
      name: "mirrorActive",
      baseName: "mirrorActive",
      type: "boolean",
    },
    {
      name: "footer",
      baseName: "footer",
      type: "string",
    },
    {
      name: "header",
      baseName: "header",
      type: "string",
    },
    {
      name: "utmCampaign",
      baseName: "utmCampaign",
      type: "string",
    },
    {
      name: "params",
      baseName: "params",
      type: "any",
    },
    {
      name: "sendAtBestTime",
      baseName: "sendAtBestTime",
      type: "boolean",
    },
    {
      name: "abTesting",
      baseName: "abTesting",
      type: "boolean",
    },
    {
      name: "subjectA",
      baseName: "subjectA",
      type: "string",
    },
    {
      name: "subjectB",
      baseName: "subjectB",
      type: "string",
    },
    {
      name: "splitRule",
      baseName: "splitRule",
      type: "number",
    },
    {
      name: "winnerCriteria",
      baseName: "winnerCriteria",
      type: "CreateEmailCampaign.WinnerCriteriaEnum",
    },
    {
      name: "winnerDelay",
      baseName: "winnerDelay",
      type: "number",
    },
    {
      name: "ipWarmupEnable",
      baseName: "ipWarmupEnable",
      type: "boolean",
    },
    {
      name: "initialQuota",
      baseName: "initialQuota",
      type: "number",
    },
    {
      name: "increaseRate",
      baseName: "increaseRate",
      type: "number",
    },
    {
      name: "unsubscriptionPageId",
      baseName: "unsubscriptionPageId",
      type: "string",
    },
    {
      name: "updateFormId",
      baseName: "updateFormId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateEmailCampaign.attributeTypeMap;
  }
}

export namespace CreateEmailCampaign {
  export enum WinnerCriteriaEnum {
    Open = <any>"open",
    Click = <any>"click",
  }
}
/**
 * Segment ids and List ids to include/exclude from campaign
 */
export class CreateEmailCampaignRecipients {
  /**
   * List ids to exclude from the campaign
   */
  "exclusionListIds"?: Array<number>;
  /**
   * Mandatory if scheduledAt is not empty. List Ids to send the campaign to
   */
  "listIds"?: Array<number>;
  /**
   * Mandatory if listIds are not used. Segment ids to send the campaign to.
   */
  "segmentIds"?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "exclusionListIds",
      baseName: "exclusionListIds",
      type: "Array<number>",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "segmentIds",
      baseName: "segmentIds",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return CreateEmailCampaignRecipients.attributeTypeMap;
  }
}

/**
 * Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
 */
export class CreateEmailCampaignSender {
  /**
   * Sender Name
   */
  "name"?: string;
  /**
   * Sender email
   */
  "email": string;
  /**
   * Select the sender for the campaign on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateEmailCampaignSender.attributeTypeMap;
  }
}

export class CreateExternalFeed {
  /**
   * Name of the feed
   */
  "name": string;
  /**
   * URL of the feed
   */
  "url": string;
  /**
   * Auth type of the feed:   * `basic`   * `token`   * `noAuth`
   */
  "authType"?: CreateExternalFeed.AuthTypeEnum;
  /**
   * Username for authType `basic`
   */
  "username"?: string;
  /**
   * Password for authType `basic`
   */
  "password"?: string;
  /**
   * Token for authType `token`
   */
  "token"?: string;
  /**
   * Custom headers for the feed
   */
  "headers"?: Array<GetExternalFeedByUUIDHeaders>;
  /**
   * Maximum number of retries on the feed url
   */
  "maxRetries"?: number;
  /**
   * Toggle caching of feed url response
   */
  "cache"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "authType",
      baseName: "authType",
      type: "CreateExternalFeed.AuthTypeEnum",
    },
    {
      name: "username",
      baseName: "username",
      type: "string",
    },
    {
      name: "password",
      baseName: "password",
      type: "string",
    },
    {
      name: "token",
      baseName: "token",
      type: "string",
    },
    {
      name: "headers",
      baseName: "headers",
      type: "Array<GetExternalFeedByUUIDHeaders>",
    },
    {
      name: "maxRetries",
      baseName: "maxRetries",
      type: "number",
    },
    {
      name: "cache",
      baseName: "cache",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CreateExternalFeed.attributeTypeMap;
  }
}

export namespace CreateExternalFeed {
  export enum AuthTypeEnum {
    Basic = <any>"basic",
    Token = <any>"token",
    NoAuth = <any>"noAuth",
  }
}
export class CreateList {
  /**
   * Name of the list
   */
  "name": string;
  /**
   * Id of the parent folder in which this list is to be created
   */
  "folderId": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "folderId",
      baseName: "folderId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateList.attributeTypeMap;
  }
}

export class CreateModel {
  /**
   * ID of the object created
   */
  "id": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateModel.attributeTypeMap;
  }
}

export class CreateProductModel {
  /**
   * ID of the Product when a new product is created
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateProductModel.attributeTypeMap;
  }
}

export class CreateReseller {
  /**
   * AuthKey of Reseller child created
   */
  "authKey": string;
  /**
   * Id of Reseller child created
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "authKey",
      baseName: "authKey",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateReseller.attributeTypeMap;
  }
}

export class CreateSender {
  /**
   * From Name to use for the sender
   */
  "name": string;
  /**
   * From email to use for the sender. A verification email will be sent to this address.
   */
  "email": string;
  /**
   * Mandatory in case of dedicated IP, IPs to associate to the sender
   */
  "ips"?: Array<CreateSenderIps>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "ips",
      baseName: "ips",
      type: "Array<CreateSenderIps>",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSender.attributeTypeMap;
  }
}

export class CreateSenderIps {
  /**
   * Dedicated IP available in your account
   */
  "ip": string;
  /**
   * Domain of the IP
   */
  "domain": string;
  /**
   * Weight to apply to the IP. Sum of all IP weights must be 100. Should be passed for either ALL or NONE of the IPs. If it's not passed, the sending will be equally balanced on all IPs.
   */
  "weight"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
    {
      name: "weight",
      baseName: "weight",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSenderIps.attributeTypeMap;
  }
}

export class CreateSenderModel {
  /**
   * ID of the Sender created
   */
  "id": number;
  /**
   * Status of SPF configuration for the sender (true = SPF not well configured, false = SPF well configured)
   */
  "spfError"?: boolean;
  /**
   * Status of DKIM configuration for the sender (true = DKIM not well configured, false = DKIM well configured)
   */
  "dkimError"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "spfError",
      baseName: "spfError",
      type: "boolean",
    },
    {
      name: "dkimError",
      baseName: "dkimError",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSenderModel.attributeTypeMap;
  }
}

export class CreateSmsCampaign {
  /**
   * Name of the campaign
   */
  "name": string;
  /**
   * Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**
   */
  "sender": string;
  /**
   * Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
   */
  "content": string;
  "recipients"?: CreateSmsCampaignRecipients;
  /**
   * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
   */
  "scheduledAt"?: string;
  /**
   * Format of the message. It indicates whether the content should be treated as unicode or not.
   */
  "unicodeEnabled"?: boolean;
  /**
   * A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**
   */
  "organisationPrefix"?: string;
  /**
   * Instructions to unsubscribe from future communications. Recommended by U.S. carriers. Must include **STOP** keyword. This will be added as instructions after the end of message content. **Prefer verifying maximum length of 160 characters including this instructions in message content to avoid multiple sending of same sms.**
   */
  "unsubscribeInstruction"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "string",
    },
    {
      name: "content",
      baseName: "content",
      type: "string",
    },
    {
      name: "recipients",
      baseName: "recipients",
      type: "CreateSmsCampaignRecipients",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "unicodeEnabled",
      baseName: "unicodeEnabled",
      type: "boolean",
    },
    {
      name: "organisationPrefix",
      baseName: "organisationPrefix",
      type: "string",
    },
    {
      name: "unsubscribeInstruction",
      baseName: "unsubscribeInstruction",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSmsCampaign.attributeTypeMap;
  }
}

export class CreateSmsCampaignRecipients {
  /**
   * Lists Ids to send the campaign to. REQUIRED if scheduledAt is not empty
   */
  "listIds": Array<number>;
  /**
   * List ids which have to be excluded from a campaign
   */
  "exclusionListIds"?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "exclusionListIds",
      baseName: "exclusionListIds",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSmsCampaignRecipients.attributeTypeMap;
  }
}

export class CreateSmtpEmail {
  /**
   * Message ID of the transactional email sent
   */
  "messageId"?: string;
  "messageIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
    {
      name: "messageIds",
      baseName: "messageIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSmtpEmail.attributeTypeMap;
  }
}

export class CreateSmtpTemplate {
  /**
   * Tag of the template
   */
  "tag"?: string;
  "sender": CreateSmtpTemplateSender;
  /**
   * Name of the template
   */
  "templateName": string;
  /**
   * Body of the message (HTML version). The field must have more than 10 characters. REQUIRED if htmlUrl is empty
   */
  "htmlContent"?: string;
  /**
   * Url which contents the body of the email message. REQUIRED if htmlContent is empty
   */
  "htmlUrl"?: string;
  /**
   * Subject of the template
   */
  "subject": string;
  /**
   * Email on which campaign recipients will be able to reply to
   */
  "replyTo"?: string;
  /**
   * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your Brevo account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
   */
  "toField"?: string;
  /**
   * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
   */
  "attachmentUrl"?: string;
  /**
   * Status of template. isActive = true means template is active and isActive = false means template is inactive
   */
  "isActive"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "CreateSmtpTemplateSender",
    },
    {
      name: "templateName",
      baseName: "templateName",
      type: "string",
    },
    {
      name: "htmlContent",
      baseName: "htmlContent",
      type: "string",
    },
    {
      name: "htmlUrl",
      baseName: "htmlUrl",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "string",
    },
    {
      name: "toField",
      baseName: "toField",
      type: "string",
    },
    {
      name: "attachmentUrl",
      baseName: "attachmentUrl",
      type: "string",
    },
    {
      name: "isActive",
      baseName: "isActive",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSmtpTemplate.attributeTypeMap;
  }
}

/**
 * Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
 */
export class CreateSmtpTemplateSender {
  /**
   * Name of the sender. If not passed, will be set to default
   */
  "name"?: string;
  /**
   * Email of the sender
   */
  "email"?: string;
  /**
   * Select the sender for the template on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSmtpTemplateSender.attributeTypeMap;
  }
}

export class CreateSubAccount {
  /**
   * Set the name of the sub-account company
   */
  "companyName": string;
  /**
   * Email address for the organization
   */
  "email": string;
  /**
   * Set the language of the sub-account
   */
  "language"?: CreateSubAccount.LanguageEnum;
  /**
   * Set the timezone of the sub-account
   */
  "timezone"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "language",
      baseName: "language",
      type: "CreateSubAccount.LanguageEnum",
    },
    {
      name: "timezone",
      baseName: "timezone",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSubAccount.attributeTypeMap;
  }
}

export namespace CreateSubAccount {
  export enum LanguageEnum {
    En = <any>"en",
    Fr = <any>"fr",
    It = <any>"it",
    Es = <any>"es",
    Pt = <any>"pt",
    De = <any>"de",
  }
}
export class CreateSubAccountResponse {
  /**
   * ID of the sub-account created
   */
  "id": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateSubAccountResponse.attributeTypeMap;
  }
}

export class CreateUpdateBatchCategory {
  /**
   * array of categories objects
   */
  "categories": Array<CreateUpdateCategories>;
  /**
   * Facilitate to update the existing categories in the same request (updateEnabled = true)
   */
  "updateEnabled"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "categories",
      baseName: "categories",
      type: "Array<CreateUpdateCategories>",
    },
    {
      name: "updateEnabled",
      baseName: "updateEnabled",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateBatchCategory.attributeTypeMap;
  }
}

export class CreateUpdateBatchCategoryModel {
  /**
   * Number of the new created categories
   */
  "createdCount"?: number;
  /**
   * Number of the existing categories updated
   */
  "updatedCount"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "createdCount",
      baseName: "createdCount",
      type: "number",
    },
    {
      name: "updatedCount",
      baseName: "updatedCount",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateBatchCategoryModel.attributeTypeMap;
  }
}

export class CreateUpdateBatchProducts {
  /**
   * array of products objects
   */
  "products": Array<CreateUpdateProducts>;
  /**
   * Facilitate to update the existing categories in the same request (updateEnabled = true)
   */
  "updateEnabled"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "products",
      baseName: "products",
      type: "Array<CreateUpdateProducts>",
    },
    {
      name: "updateEnabled",
      baseName: "updateEnabled",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateBatchProducts.attributeTypeMap;
  }
}

export class CreateUpdateBatchProductsModel {
  /**
   * Number of the new created products
   */
  "createdCount"?: number;
  /**
   * Number of the existing products updated
   */
  "updatedCount"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "createdCount",
      baseName: "createdCount",
      type: "number",
    },
    {
      name: "updatedCount",
      baseName: "updatedCount",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateBatchProductsModel.attributeTypeMap;
  }
}

export class CreateUpdateCategories {
  /**
   * Unique Category ID as saved in the shop
   */
  "id": string;
  /**
   * **Mandatory in case of creation**. Name of the Category, as displayed in the shop
   */
  "name"?: string;
  /**
   * URL to the category
   */
  "url"?: string;
  /**
   * UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the category deleted from the shop's database
   */
  "deletedAt"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "deletedAt",
      baseName: "deletedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateCategories.attributeTypeMap;
  }
}

export class CreateUpdateCategory {
  /**
   * Unique Category ID as saved in the shop
   */
  "id": string;
  /**
   * **Mandatory in case of creation**. Name of the Category, as displayed in the shop
   */
  "name"?: string;
  /**
   * URL to the category
   */
  "url"?: string;
  /**
   * Facilitate to update the existing category in the same request (updateEnabled = true)
   */
  "updateEnabled"?: boolean;
  /**
   * UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the category deleted from the shop's database
   */
  "deletedAt"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "updateEnabled",
      baseName: "updateEnabled",
      type: "boolean",
    },
    {
      name: "deletedAt",
      baseName: "deletedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateCategory.attributeTypeMap;
  }
}

export class CreateUpdateContactModel {
  /**
   * ID of the contact when a new contact is created
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateContactModel.attributeTypeMap;
  }
}

export class CreateUpdateFolder {
  /**
   * Name of the folder
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateFolder.attributeTypeMap;
  }
}

export class CreateUpdateProduct {
  /**
   * Product ID for which you requested the details
   */
  "id": string;
  /**
   * Mandatory in case of creation**. Name of the product for which you requested the details
   */
  "name": string;
  /**
   * URL to the product
   */
  "url"?: string;
  /**
   * Absolute URL to the cover image of the product
   */
  "imageUrl"?: string;
  /**
   * Product identifier from the shop
   */
  "sku"?: string;
  /**
   * Price of the product
   */
  "price"?: number;
  /**
   * Category ID-s of the product
   */
  "categories"?: Array<string>;
  /**
   * Parent product id of the product
   */
  "parentId"?: string;
  /**
   * Meta data of product such as description, vendor, producer, stock level. The size of cumulative metaInfo shall not exceed **1000 KB**. Maximum length of metaInfo object can be 10.
   */
  "metaInfo"?: { [key: string]: string };
  /**
   * Facilitate to update the existing category in the same request (updateEnabled = true)
   */
  "updateEnabled"?: boolean;
  /**
   * UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the product deleted from the shop's database
   */
  "deletedAt"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "imageUrl",
      baseName: "imageUrl",
      type: "string",
    },
    {
      name: "sku",
      baseName: "sku",
      type: "string",
    },
    {
      name: "price",
      baseName: "price",
      type: "number",
    },
    {
      name: "categories",
      baseName: "categories",
      type: "Array<string>",
    },
    {
      name: "parentId",
      baseName: "parentId",
      type: "string",
    },
    {
      name: "metaInfo",
      baseName: "metaInfo",
      type: "{ [key: string]: string; }",
    },
    {
      name: "updateEnabled",
      baseName: "updateEnabled",
      type: "boolean",
    },
    {
      name: "deletedAt",
      baseName: "deletedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateProduct.attributeTypeMap;
  }
}

export class CreateUpdateProducts {
  /**
   * Product ID for which you requested the details
   */
  "id": string;
  /**
   * Mandatory in case of creation**. Name of the product for which you requested the details
   */
  "name": string;
  /**
   * URL to the product
   */
  "url"?: string;
  /**
   * Absolute URL to the cover image of the product
   */
  "imageUrl"?: string;
  /**
   * Product identifier from the shop
   */
  "sku"?: string;
  /**
   * Price of the product
   */
  "price"?: number;
  /**
   * Category ID-s of the product
   */
  "categories"?: Array<string>;
  /**
   * Parent product id of the product
   */
  "parentId"?: string;
  /**
   * Meta data of product such as description, vendor, producer, stock level. The size of cumulative metaInfo shall not exceed **1000 KB**. Maximum length of metaInfo object can be 10.
   */
  "metaInfo"?: { [key: string]: string };
  /**
   * UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) of the product deleted from the shop's database
   */
  "deletedAt"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "imageUrl",
      baseName: "imageUrl",
      type: "string",
    },
    {
      name: "sku",
      baseName: "sku",
      type: "string",
    },
    {
      name: "price",
      baseName: "price",
      type: "number",
    },
    {
      name: "categories",
      baseName: "categories",
      type: "Array<string>",
    },
    {
      name: "parentId",
      baseName: "parentId",
      type: "string",
    },
    {
      name: "metaInfo",
      baseName: "metaInfo",
      type: "{ [key: string]: string; }",
    },
    {
      name: "deletedAt",
      baseName: "deletedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateUpdateProducts.attributeTypeMap;
  }
}

export class CreateWebhook {
  /**
   * URL of the webhook
   */
  "url": string;
  /**
   * Description of the webhook
   */
  "description"?: string;
  /**
   * - Events triggering the webhook. Possible values for **Transactional** type webhook: #### `sent` OR `request`, `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`, `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and `unsubscribed` - Possible values for **Marketing** type webhook: #### `spam`, `opened`, `click`, `hardBounce`, `softBounce`, `unsubscribed`, `listAddition` & `delivered` - Possible values for **Inbound** type webhook: #### `inboundEmailProcessed`
   */
  "events": Array<CreateWebhook.EventsEnum>;
  /**
   * Type of the webhook
   */
  "type"?: CreateWebhook.TypeEnum;
  /**
   * Inbound domain of webhook, required in case of event type `inbound`
   */
  "domain"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "description",
      baseName: "description",
      type: "string",
    },
    {
      name: "events",
      baseName: "events",
      type: "Array<CreateWebhook.EventsEnum>",
    },
    {
      name: "type",
      baseName: "type",
      type: "CreateWebhook.TypeEnum",
    },
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return CreateWebhook.attributeTypeMap;
  }
}

export namespace CreateWebhook {
  export enum EventsEnum {
    Sent = <any>"sent",
    HardBounce = <any>"hardBounce",
    SoftBounce = <any>"softBounce",
    Blocked = <any>"blocked",
    Spam = <any>"spam",
    Delivered = <any>"delivered",
    Request = <any>"request",
    Click = <any>"click",
    Invalid = <any>"invalid",
    Deferred = <any>"deferred",
    Opened = <any>"opened",
    UniqueOpened = <any>"uniqueOpened",
    Unsubscribed = <any>"unsubscribed",
    ListAddition = <any>"listAddition",
    ContactUpdated = <any>"contactUpdated",
    ContactDeleted = <any>"contactDeleted",
    InboundEmailProcessed = <any>"inboundEmailProcessed",
  }
  export enum TypeEnum {
    Transactional = <any>"transactional",
    Marketing = <any>"marketing",
    Inbound = <any>"inbound",
  }
}
export class CreateWhatsAppCampaign {
  /**
   * Name of the WhatsApp campaign creation
   */
  "name": string;
  /**
   * Id of the WhatsApp template in **approved** state
   */
  "templateId": number;
  /**
   * Sending UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). **Prefer to pass your timezone in date-time format for accurate result.For example: **2017-06-01T12:30:00+02:00**
   */
  "scheduledAt": string;
  "recipients": CreateWhatsAppCampaignRecipients;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "recipients",
      baseName: "recipients",
      type: "CreateWhatsAppCampaignRecipients",
    },
  ];

  static getAttributeTypeMap() {
    return CreateWhatsAppCampaign.attributeTypeMap;
  }
}

/**
 * Segment ids and List ids to include/exclude from campaign
 */
export class CreateWhatsAppCampaignRecipients {
  /**
   * List ids to exclude from the campaign
   */
  "excludedIds"?: Array<number>;
  /**
   * **Mandatory if scheduledAt is not empty**. List Ids to send the campaign to
   */
  "listIds"?: Array<number>;
  /**
   * **Mandatory if listIds are not used**. Segment ids to send the campaign to.
   */
  "segments"?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "excludedIds",
      baseName: "excludedIds",
      type: "Array<number>",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "segments",
      baseName: "segments",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return CreateWhatsAppCampaignRecipients.attributeTypeMap;
  }
}

export class CreateWhatsAppTemplate {
  /**
   * Name of the template
   */
  "name": string;
  /**
   * Language of the template
   */
  "language": string;
  /**
   * Category of the template
   */
  "category": CreateWhatsAppTemplate.CategoryEnum;
  /**
   * Absolute url of the media file **(no local file)**
   */
  "mediaUrl"?: string;
  /**
   * Body of the template
   */
  "body": string;
  /**
   * Html content of the header
   */
  "headerHtml"?: string;
  "headerType"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "language",
      baseName: "language",
      type: "string",
    },
    {
      name: "category",
      baseName: "category",
      type: "CreateWhatsAppTemplate.CategoryEnum",
    },
    {
      name: "mediaUrl",
      baseName: "mediaUrl",
      type: "string",
    },
    {
      name: "body",
      baseName: "body",
      type: "string",
    },
    {
      name: "headerHtml",
      baseName: "headerHtml",
      type: "string",
    },
    {
      name: "headerType",
      baseName: "headerType",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return CreateWhatsAppTemplate.attributeTypeMap;
  }
}

export namespace CreateWhatsAppTemplate {
  export enum CategoryEnum {
    MARKETING = <any>"MARKETING",
    TRANSACTIONAL = <any>"TRANSACTIONAL",
  }
}
export class CreatedBatchId {
  /**
   * Batch ID of the request
   */
  "batchId": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "batchId",
      baseName: "batchId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreatedBatchId.attributeTypeMap;
  }
}

export class CreatedProcessId {
  /**
   * Id of the process created
   */
  "processId": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "processId",
      baseName: "processId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return CreatedProcessId.attributeTypeMap;
  }
}

/**
 * Deal Details
 */
export class Deal {
  /**
   * Unique deal id
   */
  "id"?: string;
  /**
   * Deal attributes with values
   */
  "attributes"?: any;
  /**
   * Contact ids for contacts linked to this deal
   */
  "linkedContactsIds"?: Array<number>;
  /**
   * Companies ids for companies linked to this deal
   */
  "linkedCompaniesIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
    {
      name: "linkedContactsIds",
      baseName: "linkedContactsIds",
      type: "Array<number>",
    },
    {
      name: "linkedCompaniesIds",
      baseName: "linkedCompaniesIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return Deal.attributeTypeMap;
  }
}

/**
 * List of deal attributes
 */
export class DealAttributes extends Array<DealAttributesInner> {
  static discriminator: string | undefined = undefined;
}

/**
 * List of attributes
 */
export class DealAttributesInner {
  "internalName"?: string;
  "label"?: string;
  "attributeTypeName"?: string;
  "attributeOptions"?: Array<any>;
  "isRequired"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "internalName",
      baseName: "internalName",
      type: "string",
    },
    {
      name: "label",
      baseName: "label",
      type: "string",
    },
    {
      name: "attributeTypeName",
      baseName: "attributeTypeName",
      type: "string",
    },
    {
      name: "attributeOptions",
      baseName: "attributeOptions",
      type: "Array<any>",
    },
    {
      name: "isRequired",
      baseName: "isRequired",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return DealAttributesInner.attributeTypeMap;
  }
}

/**
 * List of Deals
 */
export class DealsList {
  /**
   * List of deals
   */
  "items"?: Array<Deal>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "items",
      baseName: "items",
      type: "Array<Deal>",
    },
  ];

  static getAttributeTypeMap() {
    return DealsList.attributeTypeMap;
  }
}

export class DeleteHardbounces {
  /**
   * Starting date (YYYY-MM-DD) of the time period for deletion. The hardbounces occurred after this date will be deleted. Must be less than or equal to the endDate
   */
  "startDate"?: string;
  /**
   * Ending date (YYYY-MM-DD) of the time period for deletion. The hardbounces until this date will be deleted. Must be greater than or equal to the startDate
   */
  "endDate"?: string;
  /**
   * Target a specific email address
   */
  "contactEmail"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "startDate",
      baseName: "startDate",
      type: "string",
    },
    {
      name: "endDate",
      baseName: "endDate",
      type: "string",
    },
    {
      name: "contactEmail",
      baseName: "contactEmail",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return DeleteHardbounces.attributeTypeMap;
  }
}

export class EmailExportRecipients {
  /**
   * Webhook called once the export process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479
   */
  "notifyURL"?: string;
  /**
   * Type of recipients to export for a campaign
   */
  "recipientsType": EmailExportRecipients.RecipientsTypeEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "notifyURL",
      baseName: "notifyURL",
      type: "string",
    },
    {
      name: "recipientsType",
      baseName: "recipientsType",
      type: "EmailExportRecipients.RecipientsTypeEnum",
    },
  ];

  static getAttributeTypeMap() {
    return EmailExportRecipients.attributeTypeMap;
  }
}

export namespace EmailExportRecipients {
  export enum RecipientsTypeEnum {
    All = <any>"all",
    NonClickers = <any>"nonClickers",
    NonOpeners = <any>"nonOpeners",
    Clickers = <any>"clickers",
    Openers = <any>"openers",
    SoftBounces = <any>"softBounces",
    HardBounces = <any>"hardBounces",
    Unsubscribed = <any>"unsubscribed",
  }
}
export class ErrorModel {
  /**
   * Error code displayed in case of a failure
   */
  "code": ErrorModel.CodeEnum;
  /**
   * Readable message associated to the failure
   */
  "message": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "ErrorModel.CodeEnum",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ErrorModel.attributeTypeMap;
  }
}

export namespace ErrorModel {
  export enum CodeEnum {
    InvalidParameter = <any>"invalid_parameter",
    MissingParameter = <any>"missing_parameter",
    OutOfRange = <any>"out_of_range",
    CampaignProcessing = <any>"campaign_processing",
    CampaignSent = <any>"campaign_sent",
    DocumentNotFound = <any>"document_not_found",
    ResellerPermissionDenied = <any>"reseller_permission_denied",
    NotEnoughCredits = <any>"not_enough_credits",
    PermissionDenied = <any>"permission_denied",
    DuplicateParameter = <any>"duplicate_parameter",
    DuplicateRequest = <any>"duplicate_request",
    MethodNotAllowed = <any>"method_not_allowed",
    Unauthorized = <any>"unauthorized",
    AccountUnderValidation = <any>"account_under_validation",
    NotAcceptable = <any>"not_acceptable",
    BadRequest = <any>"bad_request",
  }
}
export class ExportWebhooksHistory {
  /**
   * Number of days in the past including today (positive integer). _Not compatible with 'startDate' and 'endDate'_
   */
  "days"?: number;
  /**
   * Mandatory if endDate is used. Starting date of the history (YYYY-MM-DD). Must be lower than equal to endDate
   */
  "startDate"?: string;
  /**
   * Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
   */
  "endDate"?: string;
  /**
   * Sorting order of records (asc or desc)
   */
  "sort"?: string;
  /**
   * Filter the history for a specific event type
   */
  "event": ExportWebhooksHistory.EventEnum;
  /**
   * Webhook URL to receive CSV file link
   */
  "notifyURL": string;
  /**
   * Filter the history for a specific webhook id
   */
  "webhookId"?: number;
  /**
   * Filter the history for a specific email
   */
  "email"?: string;
  /**
   * Filter the history for a specific message id
   */
  "messageId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "days",
      baseName: "days",
      type: "number",
    },
    {
      name: "startDate",
      baseName: "startDate",
      type: "string",
    },
    {
      name: "endDate",
      baseName: "endDate",
      type: "string",
    },
    {
      name: "sort",
      baseName: "sort",
      type: "string",
    },
    {
      name: "event",
      baseName: "event",
      type: "ExportWebhooksHistory.EventEnum",
    },
    {
      name: "notifyURL",
      baseName: "notifyURL",
      type: "string",
    },
    {
      name: "webhookId",
      baseName: "webhookId",
      type: "number",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "messageId",
      baseName: "messageId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return ExportWebhooksHistory.attributeTypeMap;
  }
}

export namespace ExportWebhooksHistory {
  export enum EventEnum {
    InvalidParameter = <any>"invalid_parameter",
    MissingParameter = <any>"missing_parameter",
    HardBounce = <any>"hardBounce",
    SoftBounce = <any>"softBounce",
    Delivered = <any>'delivered"',
    Spam = <any>"spam",
    Request = <any>"request",
    Opened = <any>"opened",
    Click = <any>"click",
    Invalid = <any>"invalid",
    Deferred = <any>"deferred",
    Blocked = <any>"blocked",
    Unsubscribed = <any>"unsubscribed",
    Error = <any>"error",
    UniqueOpened = <any>"uniqueOpened",
    LoadedByProxy = <any>"loadedByProxy",
    AllEvents = <any>"allEvents",
  }
}
/**
 * File data that is uploaded
 */
export class FileData {
  /**
   * Name of uploaded file
   */
  "name"?: string;
  /**
   * Account id of user which created the file
   */
  "authorId"?: string;
  /**
   * Contact id of contact on which file is uploaded
   */
  "contactId"?: number;
  /**
   * Deal id linked to a file
   */
  "dealId"?: string;
  /**
   * Company id linked to a file
   */
  "companyId"?: string;
  /**
   * Size of file in bytes
   */
  "size"?: number;
  /**
   * File created date/time
   */
  "createdAt"?: Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "authorId",
      baseName: "authorId",
      type: "string",
    },
    {
      name: "contactId",
      baseName: "contactId",
      type: "number",
    },
    {
      name: "dealId",
      baseName: "dealId",
      type: "string",
    },
    {
      name: "companyId",
      baseName: "companyId",
      type: "string",
    },
    {
      name: "size",
      baseName: "size",
      type: "number",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "Date",
    },
  ];

  static getAttributeTypeMap() {
    return FileData.attributeTypeMap;
  }
}

export class FileDownloadableLink {
  /**
   * A unique link to download the requested file.
   */
  "fileUrl": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "fileUrl",
      baseName: "fileUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return FileDownloadableLink.attributeTypeMap;
  }
}

/**
 * List of files
 */
export class FileList extends Array<FileData> {
  static discriminator: string | undefined = undefined;
}

export class GetAccountActivity {
  /**
   * Get user activity logs
   */
  "logs"?: Array<GetAccountActivityLogs>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "logs",
      baseName: "logs",
      type: "Array<GetAccountActivityLogs>",
    },
  ];

  static getAttributeTypeMap() {
    return GetAccountActivity.attributeTypeMap;
  }
}

export class GetAccountActivityLogs {
  /**
   * Type of activity in the account.
   */
  "action": string;
  /**
   * Time of the activity.
   */
  "date": string;
  /**
   * Email address of the user who performed activity in the account.
   */
  "userEmail": string;
  /**
   * IP address of the user who performed activity in the account.
   */
  "userIp": string;
  /**
   * Browser details of the user who performed the activity.
   */
  "userAgent": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "action",
      baseName: "action",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "userEmail",
      baseName: "user_email",
      type: "string",
    },
    {
      name: "userIp",
      baseName: "user_ip",
      type: "string",
    },
    {
      name: "userAgent",
      baseName: "user_agent",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetAccountActivityLogs.attributeTypeMap;
  }
}

export class GetAccountMarketingAutomation {
  /**
   * Marketing Automation Tracker ID
   */
  "key"?: string;
  /**
   * Status of Marketing Automation Plateform activation for your account (true=enabled, false=disabled)
   */
  "enabled": boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "key",
      baseName: "key",
      type: "string",
    },
    {
      name: "enabled",
      baseName: "enabled",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return GetAccountMarketingAutomation.attributeTypeMap;
  }
}

export class GetAccountPlan {
  /**
   * Displays the plan type of the user
   */
  "type": GetAccountPlan.TypeEnum;
  /**
   * This is the type of the credit, \"Send Limit\" is one of the possible types of credit of a user. \"Send Limit\" implies the total number of emails you can send to the subscribers in your account.
   */
  "creditsType": GetAccountPlan.CreditsTypeEnum;
  /**
   * Remaining credits of the user
   */
  "credits": number;
  /**
   * Date of the period from which the plan will start (only available for \"subscription\" and \"reseller\" plan type)
   */
  "startDate"?: string;
  /**
   * Date of the period from which the plan will end (only available for \"subscription\" and \"reseller\" plan type)
   */
  "endDate"?: string;
  /**
   * Only in case of reseller account. It implies the total number of child accounts you can add to your account.
   */
  "userLimit"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "type",
      baseName: "type",
      type: "GetAccountPlan.TypeEnum",
    },
    {
      name: "creditsType",
      baseName: "creditsType",
      type: "GetAccountPlan.CreditsTypeEnum",
    },
    {
      name: "credits",
      baseName: "credits",
      type: "number",
    },
    {
      name: "startDate",
      baseName: "startDate",
      type: "string",
    },
    {
      name: "endDate",
      baseName: "endDate",
      type: "string",
    },
    {
      name: "userLimit",
      baseName: "userLimit",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetAccountPlan.attributeTypeMap;
  }
}

export namespace GetAccountPlan {
  export enum TypeEnum {
    PayAsYouGo = <any>"payAsYouGo",
    Free = <any>"free",
    Subscription = <any>"subscription",
    Sms = <any>"sms",
    Reseller = <any>"reseller",
  }
  export enum CreditsTypeEnum {
    SendLimit = <any>"sendLimit",
  }
}
/**
 * Information about your transactional email account
 */
export class GetAccountRelay {
  /**
   * Status of your transactional email Account (true=Enabled, false=Disabled)
   */
  "enabled": boolean;
  "data": GetAccountRelayData;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "enabled",
      baseName: "enabled",
      type: "boolean",
    },
    {
      name: "data",
      baseName: "data",
      type: "GetAccountRelayData",
    },
  ];

  static getAttributeTypeMap() {
    return GetAccountRelay.attributeTypeMap;
  }
}

/**
 * Data regarding the transactional email account
 */
export class GetAccountRelayData {
  /**
   * Email to use as login on transactional platform
   */
  "userName": string;
  /**
   * URL of the SMTP Relay
   */
  "relay": string;
  /**
   * Port used for SMTP Relay
   */
  "port": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "userName",
      baseName: "userName",
      type: "string",
    },
    {
      name: "relay",
      baseName: "relay",
      type: "string",
    },
    {
      name: "port",
      baseName: "port",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetAccountRelayData.attributeTypeMap;
  }
}

export class GetAggregatedReport {
  /**
   * Time frame of the report
   */
  "range"?: string;
  /**
   * Number of requests for the timeframe
   */
  "requests"?: number;
  /**
   * Number of delivered emails for the timeframe
   */
  "delivered"?: number;
  /**
   * Number of hardbounces for the timeframe
   */
  "hardBounces"?: number;
  /**
   * Number of softbounces for the timeframe
   */
  "softBounces"?: number;
  /**
   * Number of clicks for the timeframe
   */
  "clicks"?: number;
  /**
   * Number of unique clicks for the timeframe
   */
  "uniqueClicks"?: number;
  /**
   * Number of openings for the timeframe
   */
  "opens"?: number;
  /**
   * Number of unique openings for the timeframe
   */
  "uniqueOpens"?: number;
  /**
   * Number of complaint (spam report) for the timeframe
   */
  "spamReports"?: number;
  /**
   * Number of blocked contact emails for the timeframe
   */
  "blocked"?: number;
  /**
   * Number of invalid emails for the timeframe
   */
  "invalid"?: number;
  /**
   * Number of unsubscribed emails for the timeframe
   */
  "unsubscribed"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "range",
      baseName: "range",
      type: "string",
    },
    {
      name: "requests",
      baseName: "requests",
      type: "number",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "number",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "number",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "number",
    },
    {
      name: "clicks",
      baseName: "clicks",
      type: "number",
    },
    {
      name: "uniqueClicks",
      baseName: "uniqueClicks",
      type: "number",
    },
    {
      name: "opens",
      baseName: "opens",
      type: "number",
    },
    {
      name: "uniqueOpens",
      baseName: "uniqueOpens",
      type: "number",
    },
    {
      name: "spamReports",
      baseName: "spamReports",
      type: "number",
    },
    {
      name: "blocked",
      baseName: "blocked",
      type: "number",
    },
    {
      name: "invalid",
      baseName: "invalid",
      type: "number",
    },
    {
      name: "unsubscribed",
      baseName: "unsubscribed",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetAggregatedReport.attributeTypeMap;
  }
}

export class GetAllExternalFeeds {
  /**
   * Total number of batches
   */
  "count"?: number;
  "feeds"?: Array<GetAllExternalFeedsFeeds>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "feeds",
      baseName: "feeds",
      type: "Array<GetAllExternalFeedsFeeds>",
    },
  ];

  static getAttributeTypeMap() {
    return GetAllExternalFeeds.attributeTypeMap;
  }
}

export class GetAllExternalFeedsFeeds {
  /**
   * ID of the feed
   */
  "id": string;
  /**
   * Name of the feed
   */
  "name": string;
  /**
   * URL of the feed
   */
  "url": string;
  /**
   * Auth type of the feed: * `basic` * `token` * `noAuth`
   */
  "authType": GetAllExternalFeedsFeeds.AuthTypeEnum;
  /**
   * Username for authType `basic`
   */
  "username"?: string;
  /**
   * Password for authType `basic`
   */
  "password"?: string;
  /**
   * Token for authType `token`
   */
  "token"?: string;
  /**
   * Custom headers for the feed
   */
  "headers": Array<GetExternalFeedByUUIDHeaders>;
  /**
   * Maximum number of retries on the feed url
   */
  "maxRetries": number;
  /**
   * Toggle caching of feed url response
   */
  "cache": boolean;
  /**
   * Datetime on which the feed was created
   */
  "createdAt": Date;
  /**
   * Datetime on which the feed was modified
   */
  "modifiedAt": Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "authType",
      baseName: "authType",
      type: "GetAllExternalFeedsFeeds.AuthTypeEnum",
    },
    {
      name: "username",
      baseName: "username",
      type: "string",
    },
    {
      name: "password",
      baseName: "password",
      type: "string",
    },
    {
      name: "token",
      baseName: "token",
      type: "string",
    },
    {
      name: "headers",
      baseName: "headers",
      type: "Array<GetExternalFeedByUUIDHeaders>",
    },
    {
      name: "maxRetries",
      baseName: "maxRetries",
      type: "number",
    },
    {
      name: "cache",
      baseName: "cache",
      type: "boolean",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "Date",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "Date",
    },
  ];

  static getAttributeTypeMap() {
    return GetAllExternalFeedsFeeds.attributeTypeMap;
  }
}

export namespace GetAllExternalFeedsFeeds {
  export enum AuthTypeEnum {
    Basic = <any>"basic",
    Token = <any>"token",
    NoAuth = <any>"noAuth",
  }
}
export class GetAttributes {
  /**
   * Listing of available contact attributes in your account
   */
  "attributes": Array<GetAttributesAttributes>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "attributes",
      baseName: "attributes",
      type: "Array<GetAttributesAttributes>",
    },
  ];

  static getAttributeTypeMap() {
    return GetAttributes.attributeTypeMap;
  }
}

export class GetAttributesAttributes {
  /**
   * Name of the attribute
   */
  "name": string;
  /**
   * Category of the attribute
   */
  "category": GetAttributesAttributes.CategoryEnum;
  /**
   * Type of the attribute
   */
  "type"?: GetAttributesAttributes.TypeEnum;
  /**
   * Parameter only available for \"category\" type attributes.
   */
  "enumeration"?: Array<GetAttributesEnumeration>;
  /**
   * Calculated value formula
   */
  "calculatedValue"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "category",
      baseName: "category",
      type: "GetAttributesAttributes.CategoryEnum",
    },
    {
      name: "type",
      baseName: "type",
      type: "GetAttributesAttributes.TypeEnum",
    },
    {
      name: "enumeration",
      baseName: "enumeration",
      type: "Array<GetAttributesEnumeration>",
    },
    {
      name: "calculatedValue",
      baseName: "calculatedValue",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetAttributesAttributes.attributeTypeMap;
  }
}

export namespace GetAttributesAttributes {
  export enum CategoryEnum {
    Normal = <any>"normal",
    Transactional = <any>"transactional",
    Category = <any>"category",
    Calculated = <any>"calculated",
    Global = <any>"global",
  }
  export enum TypeEnum {
    Text = <any>"text",
    Date = <any>"date",
    Float = <any>"float",
    Id = <any>"id",
    Boolean = <any>"boolean",
  }
}
export class GetAttributesEnumeration {
  /**
   * ID of Value of the \"category\" type attribute
   */
  "value": number;
  /**
   * Label of the \"category\" type attribute
   */
  "label": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "value",
      baseName: "value",
      type: "number",
    },
    {
      name: "label",
      baseName: "label",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetAttributesEnumeration.attributeTypeMap;
  }
}

/**
 * list of blocked domains
 */
export class GetBlockedDomains {
  /**
   * List of all blocked domains
   */
  "domains": Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domains",
      baseName: "domains",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return GetBlockedDomains.attributeTypeMap;
  }
}

export class GetCampaignOverview {
  /**
   * ID of the campaign
   */
  "id": number;
  /**
   * Name of the campaign
   */
  "name": string;
  /**
   * Subject of the campaign. Only available if `abTesting` flag of the campaign is `false`
   */
  "subject"?: string;
  /**
   * Type of campaign
   */
  "type": GetCampaignOverview.TypeEnum;
  /**
   * Status of the campaign
   */
  "status": GetCampaignOverview.StatusEnum;
  /**
   * UTC date-time on which campaign is scheduled (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "scheduledAt"?: string;
  /**
   * Status of A/B Test for the campaign. abTesting = false means it is disabled, & abTesting = true means it is enabled.
   */
  "abTesting"?: boolean;
  /**
   * Subject A of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
   */
  "subjectA"?: string;
  /**
   * Subject B of the ab-test campaign. Only available if `abTesting` flag of the campaign is `true`
   */
  "subjectB"?: string;
  /**
   * The size of your ab-test groups. Only available if `abTesting` flag of the campaign is `true`
   */
  "splitRule"?: number;
  /**
   * Criteria for the winning version. Only available if `abTesting` flag of the campaign is `true`
   */
  "winnerCriteria"?: string;
  /**
   * The duration of the test in hours at the end of which the winning version will be sent. Only available if `abTesting` flag of the campaign is `true`
   */
  "winnerDelay"?: number;
  /**
   * It is true if you have chosen to send your campaign at best time, otherwise it is false
   */
  "sendAtBestTime"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "type",
      baseName: "type",
      type: "GetCampaignOverview.TypeEnum",
    },
    {
      name: "status",
      baseName: "status",
      type: "GetCampaignOverview.StatusEnum",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "abTesting",
      baseName: "abTesting",
      type: "boolean",
    },
    {
      name: "subjectA",
      baseName: "subjectA",
      type: "string",
    },
    {
      name: "subjectB",
      baseName: "subjectB",
      type: "string",
    },
    {
      name: "splitRule",
      baseName: "splitRule",
      type: "number",
    },
    {
      name: "winnerCriteria",
      baseName: "winnerCriteria",
      type: "string",
    },
    {
      name: "winnerDelay",
      baseName: "winnerDelay",
      type: "number",
    },
    {
      name: "sendAtBestTime",
      baseName: "sendAtBestTime",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return GetCampaignOverview.attributeTypeMap;
  }
}

export namespace GetCampaignOverview {
  export enum TypeEnum {
    Classic = <any>"classic",
    Trigger = <any>"trigger",
  }
  export enum StatusEnum {
    Draft = <any>"draft",
    Sent = <any>"sent",
    Archive = <any>"archive",
    Queued = <any>"queued",
    Suspended = <any>"suspended",
    InProcess = <any>"in_process",
  }
}
export class GetCampaignRecipients {
  "lists": Array<number>;
  "exclusionLists": Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "lists",
      baseName: "lists",
      type: "Array<number>",
    },
    {
      name: "exclusionLists",
      baseName: "exclusionLists",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return GetCampaignRecipients.attributeTypeMap;
  }
}

export class GetCampaignStats {
  /**
   * List Id of email campaign (only in case of get email campaign(s)(not for global stats))
   */
  "listId"?: number;
  /**
   * Number of unique clicks for the campaign
   */
  "uniqueClicks": number;
  /**
   * Number of total clicks for the campaign
   */
  "clickers": number;
  /**
   * Number of complaints (Spam reports) for the campaign
   */
  "complaints": number;
  /**
   * Number of delivered emails for the campaign
   */
  "delivered": number;
  /**
   * Number of sent emails for the campaign
   */
  "sent": number;
  /**
   * Number of softbounce for the campaign
   */
  "softBounces": number;
  /**
   * Number of harbounce for the campaign
   */
  "hardBounces": number;
  /**
   * Number of unique openings for the campaign
   */
  "uniqueViews": number;
  /**
   * Recipients without any privacy protection option enabled in their email client
   */
  "trackableViews": number;
  /**
   * Rate of recipients without any privacy protection option enabled in their email client
   */
  "trackableViewsRate"?: number;
  /**
   * Rate of recipients without any privacy protection option enabled in their email client, applied to all delivered emails
   */
  "estimatedViews"?: number;
  /**
   * Number of unsubscription for the campaign
   */
  "unsubscriptions": number;
  /**
   * Number of openings for the campaign
   */
  "viewed": number;
  /**
   * Number of deferred emails for the campaign
   */
  "deferred"?: number;
  /**
   * Total number of non-delivered campaigns for a particular campaign id.
   */
  "returnBounce"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "listId",
      baseName: "listId",
      type: "number",
    },
    {
      name: "uniqueClicks",
      baseName: "uniqueClicks",
      type: "number",
    },
    {
      name: "clickers",
      baseName: "clickers",
      type: "number",
    },
    {
      name: "complaints",
      baseName: "complaints",
      type: "number",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "number",
    },
    {
      name: "sent",
      baseName: "sent",
      type: "number",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "number",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "number",
    },
    {
      name: "uniqueViews",
      baseName: "uniqueViews",
      type: "number",
    },
    {
      name: "trackableViews",
      baseName: "trackableViews",
      type: "number",
    },
    {
      name: "trackableViewsRate",
      baseName: "trackableViewsRate",
      type: "number",
    },
    {
      name: "estimatedViews",
      baseName: "estimatedViews",
      type: "number",
    },
    {
      name: "unsubscriptions",
      baseName: "unsubscriptions",
      type: "number",
    },
    {
      name: "viewed",
      baseName: "viewed",
      type: "number",
    },
    {
      name: "deferred",
      baseName: "deferred",
      type: "number",
    },
    {
      name: "returnBounce",
      baseName: "returnBounce",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetCampaignStats.attributeTypeMap;
  }
}

export class GetCategories {
  "categories": Array<any>;
  /**
   * Number of categories
   */
  "count": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "categories",
      baseName: "categories",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetCategories.attributeTypeMap;
  }
}

export class GetCategoryDetails {
  /**
   * Category ID for which you requested the details
   */
  "id": string;
  /**
   * Name of the category for which you requested the details
   */
  "name": string;
  /**
   * Creation UTC date-time of the category (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * Last modification UTC date-time of the category (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;
  /**
   * URL to the category
   */
  "url"?: string;
  /**
   * category deleted from the shop's database
   */
  "isDeleted"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "isDeleted",
      baseName: "isDeleted",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return GetCategoryDetails.attributeTypeMap;
  }
}

export class GetChildAccountCreationStatus {
  /**
   * Status of child account creation whether it is successfully created (exists) or not.
   */
  "childAccountCreated": boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "childAccountCreated",
      baseName: "childAccountCreated",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildAccountCreationStatus.attributeTypeMap;
  }
}

export class GetChildDomain {
  /**
   * Sender domain
   */
  "domain"?: string;
  /**
   * indicates whether a domain is verified or not
   */
  "active"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
    {
      name: "active",
      baseName: "active",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildDomain.attributeTypeMap;
  }
}

export class GetChildDomains extends Array<any> {
  static discriminator: string | undefined = undefined;
}

/**
 * API Keys associated to child account
 */
export class GetChildInfoApiKeys {
  "v2": Array<GetChildInfoApiKeysV2>;
  "v3"?: Array<GetChildInfoApiKeysV3>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "v2",
      baseName: "v2",
      type: "Array<GetChildInfoApiKeysV2>",
    },
    {
      name: "v3",
      baseName: "v3",
      type: "Array<GetChildInfoApiKeysV3>",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildInfoApiKeys.attributeTypeMap;
  }
}

export class GetChildInfoApiKeysV2 {
  /**
   * Name of the key for version 2
   */
  "name": string;
  /**
   * API Key for version 2
   */
  "key": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "key",
      baseName: "key",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildInfoApiKeysV2.attributeTypeMap;
  }
}

export class GetChildInfoApiKeysV3 {
  /**
   * Name of the key for version 3
   */
  "name": string;
  /**
   * API Key for version 3
   */
  "key": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "key",
      baseName: "key",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildInfoApiKeysV3.attributeTypeMap;
  }
}

/**
 * Credits available for your child
 */
export class GetChildInfoCredits {
  /**
   * Email credits available for your child
   */
  "emailCredits"?: number;
  /**
   * SMS credits available for your child
   */
  "smsCredits"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "emailCredits",
      baseName: "emailCredits",
      type: "number",
    },
    {
      name: "smsCredits",
      baseName: "smsCredits",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildInfoCredits.attributeTypeMap;
  }
}

/**
 * Statistics about your child account activity
 */
export class GetChildInfoStatistics {
  /**
   * Overall emails sent for the previous month
   */
  "previousMonthTotalSent"?: number;
  /**
   * Overall emails sent for current month
   */
  "currentMonthTotalSent"?: number;
  /**
   * Overall emails sent for since the account exists
   */
  "totalSent"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "previousMonthTotalSent",
      baseName: "previousMonthTotalSent",
      type: "number",
    },
    {
      name: "currentMonthTotalSent",
      baseName: "currentMonthTotalSent",
      type: "number",
    },
    {
      name: "totalSent",
      baseName: "totalSent",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildInfoStatistics.attributeTypeMap;
  }
}

export class GetChildrenList {
  /**
   * Your children's account information
   */
  "children"?: Array<any>;
  /**
   * Number of child accounts
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "children",
      baseName: "children",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetChildrenList.attributeTypeMap;
  }
}

export class GetClient {
  /**
   * Login Email
   */
  "email": string;
  /**
   * First Name
   */
  "firstName": string;
  /**
   * Last Name
   */
  "lastName": string;
  /**
   * Name of the company
   */
  "companyName": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "firstName",
      baseName: "firstName",
      type: "string",
    },
    {
      name: "lastName",
      baseName: "lastName",
      type: "string",
    },
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetClient.attributeTypeMap;
  }
}

export class GetChildInfo extends GetClient {
  "credits"?: GetChildInfoCredits;
  "statistics"?: GetChildInfoStatistics;
  /**
   * The encrypted password of child account
   */
  "password": string;
  /**
   * IP(s) associated to a child account user
   */
  "ips"?: Array<string>;
  "apiKeys"?: GetChildInfoApiKeys;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "credits",
      baseName: "credits",
      type: "GetChildInfoCredits",
    },
    {
      name: "statistics",
      baseName: "statistics",
      type: "GetChildInfoStatistics",
    },
    {
      name: "password",
      baseName: "password",
      type: "string",
    },
    {
      name: "ips",
      baseName: "ips",
      type: "Array<string>",
    },
    {
      name: "apiKeys",
      baseName: "apiKeys",
      type: "GetChildInfoApiKeys",
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(GetChildInfo.attributeTypeMap);
  }
}

/**
 * Campaign Statistics for the contact
 */
export class GetContactCampaignStats {
  "messagesSent"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  "hardBounces"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  "softBounces"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  "complaints"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  "unsubscriptions"?: GetContactCampaignStatsUnsubscriptions;
  "opened"?: Array<GetContactCampaignStatsOpened>;
  "clicked"?: Array<GetContactCampaignStatsClicked>;
  "transacAttributes"?: Array<GetContactCampaignStatsTransacAttributes>;
  "delivered"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "messagesSent",
      baseName: "messagesSent",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "complaints",
      baseName: "complaints",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "unsubscriptions",
      baseName: "unsubscriptions",
      type: "GetContactCampaignStatsUnsubscriptions",
    },
    {
      name: "opened",
      baseName: "opened",
      type: "Array<GetContactCampaignStatsOpened>",
    },
    {
      name: "clicked",
      baseName: "clicked",
      type: "Array<GetContactCampaignStatsClicked>",
    },
    {
      name: "transacAttributes",
      baseName: "transacAttributes",
      type: "Array<GetContactCampaignStatsTransacAttributes>",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
  ];

  static getAttributeTypeMap() {
    return GetContactCampaignStats.attributeTypeMap;
  }
}

export class GetContactCampaignStatsClicked {
  /**
   * ID of the campaign which generated the event
   */
  "campaignId": number;
  "links": Array<GetExtendedContactDetailsStatisticsLinks>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaignId",
      baseName: "campaignId",
      type: "number",
    },
    {
      name: "links",
      baseName: "links",
      type: "Array<GetExtendedContactDetailsStatisticsLinks>",
    },
  ];

  static getAttributeTypeMap() {
    return GetContactCampaignStatsClicked.attributeTypeMap;
  }
}

export class GetContactCampaignStatsOpened {
  /**
   * ID of the campaign which generated the event
   */
  "campaignId": number;
  /**
   * Number of openings of the campaign
   */
  "count": number;
  /**
   * UTC date-time of the event
   */
  "eventTime": string;
  /**
   * IP from which the user has opened the campaign
   */
  "ip": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaignId",
      baseName: "campaignId",
      type: "number",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "eventTime",
      baseName: "eventTime",
      type: "string",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetContactCampaignStatsOpened.attributeTypeMap;
  }
}

export class GetContactCampaignStatsTransacAttributes {
  /**
   * Date of the order
   */
  "orderDate": string;
  /**
   * Price of the order
   */
  "orderPrice": number;
  /**
   * ID of the order
   */
  "orderId": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "orderDate",
      baseName: "orderDate",
      type: "string",
    },
    {
      name: "orderPrice",
      baseName: "orderPrice",
      type: "number",
    },
    {
      name: "orderId",
      baseName: "orderId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetContactCampaignStatsTransacAttributes.attributeTypeMap;
  }
}

export class GetContactCampaignStatsUnsubscriptions {
  /**
   * Contact has unsubscribed via the unsubscription link in the email
   */
  "userUnsubscription": Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>;
  /**
   * Contact has been unsubscribed from the administrator
   */
  "adminUnsubscription": Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "userUnsubscription",
      baseName: "userUnsubscription",
      type: "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>",
    },
    {
      name: "adminUnsubscription",
      baseName: "adminUnsubscription",
      type: "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>",
    },
  ];

  static getAttributeTypeMap() {
    return GetContactCampaignStatsUnsubscriptions.attributeTypeMap;
  }
}

export class GetContactDetails {
  /**
   * Email address of the contact for which you requested the details
   */
  "email": string;
  /**
   * ID of the contact for which you requested the details
   */
  "id": number;
  /**
   * Blacklist status for email campaigns (true=blacklisted, false=not blacklisted)
   */
  "emailBlacklisted": boolean;
  /**
   * Blacklist status for SMS campaigns (true=blacklisted, false=not blacklisted)
   */
  "smsBlacklisted": boolean;
  /**
   * Creation UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * Last modification UTC date-time of the contact (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;
  "listIds": Array<number>;
  "listUnsubscribed"?: Array<number>;
  /**
   * Set of attributes of the contact
   */
  "attributes": any;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "emailBlacklisted",
      baseName: "emailBlacklisted",
      type: "boolean",
    },
    {
      name: "smsBlacklisted",
      baseName: "smsBlacklisted",
      type: "boolean",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "listUnsubscribed",
      baseName: "listUnsubscribed",
      type: "Array<number>",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
  ];

  static getAttributeTypeMap() {
    return GetContactDetails.attributeTypeMap;
  }
}

export class GetContacts {
  "contacts": Array<any>;
  /**
   * Number of contacts
   */
  "count": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "contacts",
      baseName: "contacts",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetContacts.attributeTypeMap;
  }
}

export class GetDeviceBrowserStats {
  /**
   * Number of total clicks for the campaign using the particular browser
   */
  "clickers": number;
  /**
   * Number of unique clicks for the campaign using the particular browser
   */
  "uniqueClicks": number;
  /**
   * Number of openings for the campaign using the particular browser
   */
  "viewed": number;
  /**
   * Number of unique openings for the campaign using the particular browser
   */
  "uniqueViews": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "clickers",
      baseName: "clickers",
      type: "number",
    },
    {
      name: "uniqueClicks",
      baseName: "uniqueClicks",
      type: "number",
    },
    {
      name: "viewed",
      baseName: "viewed",
      type: "number",
    },
    {
      name: "uniqueViews",
      baseName: "uniqueViews",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetDeviceBrowserStats.attributeTypeMap;
  }
}

export class GetDomainonfigurationModel {
  /**
   * Domain
   */
  "domain": string;
  /**
   * Status of domain verification (true=verified, false=non verified)
   */
  "verified": boolean;
  /**
   * Status of domain authentication (true=authenticated, false=non authenticated)
   */
  "authenticated": boolean;
  "dnsRecords": CreateDomainModelDnsRecords;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
    {
      name: "verified",
      baseName: "verified",
      type: "boolean",
    },
    {
      name: "authenticated",
      baseName: "authenticated",
      type: "boolean",
    },
    {
      name: "dnsRecords",
      baseName: "dns_records",
      type: "CreateDomainModelDnsRecords",
    },
  ];

  static getAttributeTypeMap() {
    return GetDomainonfigurationModel.attributeTypeMap;
  }
}

export class GetDomainsList {
  /**
   * List of the domains available in your account
   */
  "domains"?: Array<GetDomainsListDomains>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domains",
      baseName: "domains",
      type: "Array<GetDomainsListDomains>",
    },
  ];

  static getAttributeTypeMap() {
    return GetDomainsList.attributeTypeMap;
  }
}

export class GetDomainsListDomains {
  /**
   * Id of the domain
   */
  "id": number;
  /**
   * Domain name
   */
  "domainName": string;
  /**
   * Status of domain authentication (true=authenticated, false=non authenticated)
   */
  "authenticated": boolean;
  /**
   * Status of domain verification (true=verified, false=non verified)
   */
  "verified": boolean;
  /**
   * Dedicated IP associated with domain
   */
  "ip"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "domainName",
      baseName: "domain_name",
      type: "string",
    },
    {
      name: "authenticated",
      baseName: "authenticated",
      type: "boolean",
    },
    {
      name: "verified",
      baseName: "verified",
      type: "boolean",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetDomainsListDomains.attributeTypeMap;
  }
}

export namespace GetEmailCampaign {}
export class GetEmailCampaigns {
  "campaigns"?: Array<any>;
  /**
   * Number of Email campaigns retrieved
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaigns",
      baseName: "campaigns",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetEmailCampaigns.attributeTypeMap;
  }
}

export class GetEmailEventReport {
  "events"?: Array<GetEmailEventReportEvents>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "events",
      baseName: "events",
      type: "Array<GetEmailEventReportEvents>",
    },
  ];

  static getAttributeTypeMap() {
    return GetEmailEventReport.attributeTypeMap;
  }
}

export class GetEmailEventReportEvents {
  /**
   * Email address which generates the event
   */
  "email": string;
  /**
   * UTC date-time on which the event has been generated
   */
  "date": string;
  /**
   * Subject of the event
   */
  "subject"?: string;
  /**
   * Message ID which generated the event
   */
  "messageId": string;
  /**
   * Event which occurred
   */
  "event": GetEmailEventReportEvents.EventEnum;
  /**
   * Reason of bounce (only available if the event is hardbounce or softbounce)
   */
  "reason"?: string;
  /**
   * Tag of the email which generated the event
   */
  "tag"?: string;
  /**
   * IP from which the user has opened the email or clicked on the link (only available if the event is opened or clicks)
   */
  "ip"?: string;
  /**
   * The link which is sent to the user (only available if the event is requests or opened or clicks)
   */
  "link"?: string;
  /**
   * Sender email from which the emails are sent
   */
  "from"?: string;
  /**
   * ID of the template (only available if the email is template based)
   */
  "templateId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
    {
      name: "event",
      baseName: "event",
      type: "GetEmailEventReportEvents.EventEnum",
    },
    {
      name: "reason",
      baseName: "reason",
      type: "string",
    },
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
    {
      name: "link",
      baseName: "link",
      type: "string",
    },
    {
      name: "from",
      baseName: "from",
      type: "string",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetEmailEventReportEvents.attributeTypeMap;
  }
}

export namespace GetEmailEventReportEvents {
  export enum EventEnum {
    Bounces = <any>"bounces",
    HardBounces = <any>"hardBounces",
    SoftBounces = <any>"softBounces",
    Delivered = <any>"delivered",
    Spam = <any>"spam",
    Requests = <any>"requests",
    Opened = <any>"opened",
    Clicks = <any>"clicks",
    Invalid = <any>"invalid",
    Deferred = <any>"deferred",
    Blocked = <any>"blocked",
    Unsubscribed = <any>"unsubscribed",
    Error = <any>"error",
    LoadedByProxy = <any>"loadedByProxy",
  }
}
export class GetExtendedCampaignOverview extends GetCampaignOverview {
  /**
   * Retrieved the status of test email sending. (true=Test email has been sent  false=Test email has not been sent)
   */
  "testSent": boolean;
  /**
   * Header of the campaign
   */
  "header": string;
  /**
   * Footer of the campaign
   */
  "footer": string;
  "sender": GetExtendedCampaignOverviewSender;
  /**
   * Email defined as the \"Reply to\" of the campaign
   */
  "replyTo": string;
  /**
   * Customisation of the \"to\" field of the campaign
   */
  "toField"?: string;
  /**
   * HTML content of the campaign
   */
  "htmlContent": string;
  /**
   * Link to share the campaign on social medias
   */
  "shareLink"?: string;
  /**
   * Tag of the campaign
   */
  "tag"?: string;
  /**
   * Creation UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * UTC date-time of last modification of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;
  /**
   * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email.
   */
  "inlineImageActivation"?: boolean;
  /**
   * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
   */
  "mirrorActive"?: boolean;
  /**
   * FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
   */
  "recurring"?: boolean;
  /**
   * Sent UTC date-time of the campaign (YYYY-MM-DDTHH:mm:ss.SSSZ). Only available if 'status' of the campaign is 'sent'
   */
  "sentDate"?: string;
  /**
   * Total number of non-delivered campaigns for a particular campaign id.
   */
  "returnBounce"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "testSent",
      baseName: "testSent",
      type: "boolean",
    },
    {
      name: "header",
      baseName: "header",
      type: "string",
    },
    {
      name: "footer",
      baseName: "footer",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "GetExtendedCampaignOverviewSender",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "string",
    },
    {
      name: "toField",
      baseName: "toField",
      type: "string",
    },
    {
      name: "htmlContent",
      baseName: "htmlContent",
      type: "string",
    },
    {
      name: "shareLink",
      baseName: "shareLink",
      type: "string",
    },
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
    {
      name: "inlineImageActivation",
      baseName: "inlineImageActivation",
      type: "boolean",
    },
    {
      name: "mirrorActive",
      baseName: "mirrorActive",
      type: "boolean",
    },
    {
      name: "recurring",
      baseName: "recurring",
      type: "boolean",
    },
    {
      name: "sentDate",
      baseName: "sentDate",
      type: "string",
    },
    {
      name: "returnBounce",
      baseName: "returnBounce",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(GetExtendedCampaignOverview.attributeTypeMap);
  }
}

export class GetEmailCampaign extends GetExtendedCampaignOverview {
  "recipients": GetCampaignRecipients;
  "statistics": GetExtendedCampaignStats;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "recipients",
      baseName: "recipients",
      type: "GetCampaignRecipients",
    },
    {
      name: "statistics",
      baseName: "statistics",
      type: "GetExtendedCampaignStats",
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(GetEmailCampaign.attributeTypeMap);
  }
}

export namespace GetExtendedCampaignOverview {}
export class GetExtendedCampaignOverviewSender {
  /**
   * Sender name of the campaign
   */
  "name"?: string;
  /**
   * Sender email of the campaign
   */
  "email"?: string;
  /**
   * Sender id of the campaign
   */
  "id"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedCampaignOverviewSender.attributeTypeMap;
  }
}

export class GetExtendedCampaignStats {
  "globalStats": any;
  /**
   * List-wise statistics of the campaign.
   */
  "campaignStats": Array<any>;
  /**
   * Number of clicks on mirror link
   */
  "mirrorClick": number;
  /**
   * Number of remaning emails to send
   */
  "remaining": number;
  /**
   * Statistics about the number of clicks for the links
   */
  "linksStats": any;
  "statsByDomain": any;
  /**
   * Statistics about the campaign on the basis of various devices
   */
  "statsByDevice": any;
  /**
   * Statistics about the campaign on the basis of various browsers
   */
  "statsByBrowser": any;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "globalStats",
      baseName: "globalStats",
      type: "any",
    },
    {
      name: "campaignStats",
      baseName: "campaignStats",
      type: "Array<any>",
    },
    {
      name: "mirrorClick",
      baseName: "mirrorClick",
      type: "number",
    },
    {
      name: "remaining",
      baseName: "remaining",
      type: "number",
    },
    {
      name: "linksStats",
      baseName: "linksStats",
      type: "any",
    },
    {
      name: "statsByDomain",
      baseName: "statsByDomain",
      type: "any",
    },
    {
      name: "statsByDevice",
      baseName: "statsByDevice",
      type: "any",
    },
    {
      name: "statsByBrowser",
      baseName: "statsByBrowser",
      type: "any",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedCampaignStats.attributeTypeMap;
  }
}

/**
 * Overall statistics of the campaign
 */
export class GetExtendedCampaignStatsGlobalStats {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return GetExtendedCampaignStatsGlobalStats.attributeTypeMap;
  }
}

export class GetExtendedClient extends GetClient {
  "address": GetExtendedClientAddress;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "address",
      baseName: "address",
      type: "GetExtendedClientAddress",
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(GetExtendedClient.attributeTypeMap);
  }
}

export class GetAccount extends GetExtendedClient {
  /**
   * Information about your plans and credits
   */
  "plan": Array<GetAccountPlan>;
  "relay": GetAccountRelay;
  "marketingAutomation"?: GetAccountMarketingAutomation;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "plan",
      baseName: "plan",
      type: "Array<GetAccountPlan>",
    },
    {
      name: "relay",
      baseName: "relay",
      type: "GetAccountRelay",
    },
    {
      name: "marketingAutomation",
      baseName: "marketingAutomation",
      type: "GetAccountMarketingAutomation",
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(GetAccount.attributeTypeMap);
  }
}
/**
 * Address informations
 */
export class GetExtendedClientAddress {
  /**
   * Street information
   */
  "street": string;
  /**
   * City information
   */
  "city": string;
  /**
   * Zip Code information
   */
  "zipCode": string;
  /**
   * Country information
   */
  "country": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "street",
      baseName: "street",
      type: "string",
    },
    {
      name: "city",
      baseName: "city",
      type: "string",
    },
    {
      name: "zipCode",
      baseName: "zipCode",
      type: "string",
    },
    {
      name: "country",
      baseName: "country",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedClientAddress.attributeTypeMap;
  }
}

export class GetExtendedContactDetails extends GetContactDetails {
  "statistics": GetExtendedContactDetailsStatistics;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "statistics",
      baseName: "statistics",
      type: "GetExtendedContactDetailsStatistics",
    },
  ];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(GetExtendedContactDetails.attributeTypeMap);
  }
}

/**
 * Campaign statistics of the contact
 */
export class GetExtendedContactDetailsStatistics {
  /**
   * Listing of the sent campaign for the contact
   */
  "messagesSent"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  /**
   * Listing of the hardbounes generated by the contact
   */
  "hardBounces"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  /**
   * Listing of the softbounes generated by the contact
   */
  "softBounces"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  /**
   * Listing of the complaints generated by the contact
   */
  "complaints"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;
  "unsubscriptions"?: GetExtendedContactDetailsStatisticsUnsubscriptions;
  /**
   * Listing of the openings generated by the contact
   */
  "opened"?: Array<GetExtendedContactDetailsStatisticsOpened>;
  /**
   * Listing of the clicks generated by the contact
   */
  "clicked"?: Array<GetExtendedContactDetailsStatisticsClicked>;
  /**
   * Listing of the transactional attributes for the contact
   */
  "transacAttributes"?: Array<any>;
  /**
   * Listing of the delivered campaign for the contact
   */
  "delivered"?: Array<GetExtendedContactDetailsStatisticsMessagesSent>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "messagesSent",
      baseName: "messagesSent",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "complaints",
      baseName: "complaints",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
    {
      name: "unsubscriptions",
      baseName: "unsubscriptions",
      type: "GetExtendedContactDetailsStatisticsUnsubscriptions",
    },
    {
      name: "opened",
      baseName: "opened",
      type: "Array<GetExtendedContactDetailsStatisticsOpened>",
    },
    {
      name: "clicked",
      baseName: "clicked",
      type: "Array<GetExtendedContactDetailsStatisticsClicked>",
    },
    {
      name: "transacAttributes",
      baseName: "transacAttributes",
      type: "Array<any>",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "Array<GetExtendedContactDetailsStatisticsMessagesSent>",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatistics.attributeTypeMap;
  }
}

export class GetExtendedContactDetailsStatisticsClicked {
  /**
   * ID of the campaign which generated the event
   */
  "campaignId": number;
  /**
   * Listing of the clicked links for the campaign
   */
  "links": Array<GetExtendedContactDetailsStatisticsLinks>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaignId",
      baseName: "campaignId",
      type: "number",
    },
    {
      name: "links",
      baseName: "links",
      type: "Array<GetExtendedContactDetailsStatisticsLinks>",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatisticsClicked.attributeTypeMap;
  }
}

export class GetExtendedContactDetailsStatisticsLinks {
  /**
   * Number of clicks on this link for the campaign
   */
  "count": number;
  /**
   * UTC date-time of the event
   */
  "eventTime": string;
  /**
   * IP from which the user has clicked on the link
   */
  "ip": string;
  /**
   * URL of the clicked link
   */
  "url": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "eventTime",
      baseName: "eventTime",
      type: "string",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatisticsLinks.attributeTypeMap;
  }
}

export class GetExtendedContactDetailsStatisticsMessagesSent {
  /**
   * ID of the campaign which generated the event
   */
  "campaignId": number;
  /**
   * UTC date-time of the event
   */
  "eventTime": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaignId",
      baseName: "campaignId",
      type: "number",
    },
    {
      name: "eventTime",
      baseName: "eventTime",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatisticsMessagesSent.attributeTypeMap;
  }
}

export class GetExtendedContactDetailsStatisticsOpened {
  /**
   * ID of the campaign which generated the event
   */
  "campaignId": number;
  /**
   * Number of openings for the campaign
   */
  "count": number;
  /**
   * UTC date-time of the event
   */
  "eventTime": string;
  /**
   * IP from which the user has opened the email
   */
  "ip": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaignId",
      baseName: "campaignId",
      type: "number",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "eventTime",
      baseName: "eventTime",
      type: "string",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatisticsOpened.attributeTypeMap;
  }
}

/**
 * Listing of the unsubscription for the contact
 */
export class GetExtendedContactDetailsStatisticsUnsubscriptions {
  /**
   * Contact unsubscribe via unsubscription link in a campaign
   */
  "userUnsubscription": Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>;
  /**
   * Contact has been unsubscribed from the administrator
   */
  "adminUnsubscription": Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "userUnsubscription",
      baseName: "userUnsubscription",
      type: "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription>",
    },
    {
      name: "adminUnsubscription",
      baseName: "adminUnsubscription",
      type: "Array<GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription>",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatisticsUnsubscriptions.attributeTypeMap;
  }
}

export class GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription {
  /**
   * UTC date-time of the event
   */
  "eventTime": string;
  /**
   * IP from which the user has been unsubscribed
   */
  "ip"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "eventTime",
      baseName: "eventTime",
      type: "string",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription.attributeTypeMap;
  }
}

export class GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription {
  /**
   * ID of the campaign which generated the event
   */
  "campaignId": number;
  /**
   * UTC date-time of the event
   */
  "eventTime": string;
  /**
   * IP from which the user has unsubscribed
   */
  "ip"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaignId",
      baseName: "campaignId",
      type: "number",
    },
    {
      name: "eventTime",
      baseName: "eventTime",
      type: "string",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription.attributeTypeMap;
  }
}

export class GetExtendedListCampaignStats {
  /**
   * ID of the campaign
   */
  "campaignId": number;
  "stats": GetCampaignStats;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaignId",
      baseName: "campaignId",
      type: "number",
    },
    {
      name: "stats",
      baseName: "stats",
      type: "GetCampaignStats",
    },
  ];

  static getAttributeTypeMap() {
    return GetExtendedListCampaignStats.attributeTypeMap;
  }
}

export class GetExternalFeedByUUID {
  /**
   * ID of the feed
   */
  "id": string;
  /**
   * Name of the feed
   */
  "name": string;
  /**
   * URL of the feed
   */
  "url": string;
  /**
   * Auth type of the feed: * `basic` * `token` * `noAuth`
   */
  "authType": GetExternalFeedByUUID.AuthTypeEnum;
  /**
   * Username for authType `basic`
   */
  "username"?: string;
  /**
   * Password for authType `basic`
   */
  "password"?: string;
  /**
   * Token for authType `token`
   */
  "token"?: string;
  /**
   * Custom headers for the feed
   */
  "headers": Array<GetExternalFeedByUUIDHeaders>;
  /**
   * Maximum number of retries on the feed url
   */
  "maxRetries": number;
  /**
   * Toggle caching of feed url response
   */
  "cache": boolean;
  /**
   * Datetime on which the feed was created
   */
  "createdAt": Date;
  /**
   * Datetime on which the feed was modified
   */
  "modifiedAt": Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "authType",
      baseName: "authType",
      type: "GetExternalFeedByUUID.AuthTypeEnum",
    },
    {
      name: "username",
      baseName: "username",
      type: "string",
    },
    {
      name: "password",
      baseName: "password",
      type: "string",
    },
    {
      name: "token",
      baseName: "token",
      type: "string",
    },
    {
      name: "headers",
      baseName: "headers",
      type: "Array<GetExternalFeedByUUIDHeaders>",
    },
    {
      name: "maxRetries",
      baseName: "maxRetries",
      type: "number",
    },
    {
      name: "cache",
      baseName: "cache",
      type: "boolean",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "Date",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "Date",
    },
  ];

  static getAttributeTypeMap() {
    return GetExternalFeedByUUID.attributeTypeMap;
  }
}

export namespace GetExternalFeedByUUID {
  export enum AuthTypeEnum {
    Basic = <any>"basic",
    Token = <any>"token",
    NoAuth = <any>"noAuth",
  }
}
export class GetExternalFeedByUUIDHeaders {
  /**
   * Name of the header
   */
  "name"?: string;
  /**
   * Value of the header
   */
  "value"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "value",
      baseName: "value",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetExternalFeedByUUIDHeaders.attributeTypeMap;
  }
}

export class GetFolder {
  /**
   * ID of the folder
   */
  "id": number;
  /**
   * Name of the folder
   */
  "name": string;
  /**
   * Number of blacklisted contacts in the folder
   */
  "totalBlacklisted": number;
  /**
   * Number of contacts in the folder
   */
  "totalSubscribers": number;
  /**
   * Number of unique contacts in the folder
   */
  "uniqueSubscribers": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "totalBlacklisted",
      baseName: "totalBlacklisted",
      type: "number",
    },
    {
      name: "totalSubscribers",
      baseName: "totalSubscribers",
      type: "number",
    },
    {
      name: "uniqueSubscribers",
      baseName: "uniqueSubscribers",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetFolder.attributeTypeMap;
  }
}

export class GetFolderLists {
  "lists"?: Array<any>;
  /**
   * Number of lists in the folder
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "lists",
      baseName: "lists",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetFolderLists.attributeTypeMap;
  }
}

export class GetFolders {
  "folders"?: Array<any>;
  /**
   * Number of folders available in your account
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "folders",
      baseName: "folders",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetFolders.attributeTypeMap;
  }
}

export class GetInboundEmailEvents {
  "events"?: Array<GetInboundEmailEventsEvents>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "events",
      baseName: "events",
      type: "Array<GetInboundEmailEventsEvents>",
    },
  ];

  static getAttributeTypeMap() {
    return GetInboundEmailEvents.attributeTypeMap;
  }
}

export class GetInboundEmailEventsByUuid {
  /**
   * Date when email was received on SMTP relay
   */
  "receivedAt"?: Date;
  /**
   * Date when email was delivered successfully to client’s webhook
   */
  "deliveredAt"?: Date;
  /**
   * Recipient’s email address
   */
  "recipient"?: string;
  /**
   * Sender’s email address
   */
  "sender"?: string;
  /**
   * Value of the Message-ID header. This will be present only after the processing is done.
   */
  "messageId"?: string;
  /**
   * Value of the Subject header. This will be present only after the processing is done.
   */
  "subject"?: string;
  /**
   * List of attachments of the email. This will be present only after the processing is done.
   */
  "attachments"?: Array<GetInboundEmailEventsByUuidAttachments>;
  /**
   * List of events/logs that describe the lifecycle of the email on SIB platform
   */
  "logs"?: Array<GetInboundEmailEventsByUuidLogs>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "receivedAt",
      baseName: "receivedAt",
      type: "Date",
    },
    {
      name: "deliveredAt",
      baseName: "deliveredAt",
      type: "Date",
    },
    {
      name: "recipient",
      baseName: "recipient",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "string",
    },
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "attachments",
      baseName: "attachments",
      type: "Array<GetInboundEmailEventsByUuidAttachments>",
    },
    {
      name: "logs",
      baseName: "logs",
      type: "Array<GetInboundEmailEventsByUuidLogs>",
    },
  ];

  static getAttributeTypeMap() {
    return GetInboundEmailEventsByUuid.attributeTypeMap;
  }
}

export class GetInboundEmailEventsByUuidAttachments {
  /**
   * filename specified in the Content-Disposition header of the attachment
   */
  "name"?: string;
  /**
   * value of the Content-Type header of the attachment
   */
  "contentType"?: string;
  /**
   * value of the Content-ID header of the attachment.
   */
  "contentId"?: string;
  /**
   * size of the attachment in bytes
   */
  "contentLength"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "contentType",
      baseName: "contentType",
      type: "string",
    },
    {
      name: "contentId",
      baseName: "contentId",
      type: "string",
    },
    {
      name: "contentLength",
      baseName: "contentLength",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetInboundEmailEventsByUuidAttachments.attributeTypeMap;
  }
}

export class GetInboundEmailEventsByUuidLogs {
  /**
   * Date of the event
   */
  "date"?: Date;
  /**
   * Type of the event
   */
  "type"?: GetInboundEmailEventsByUuidLogs.TypeEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "date",
      baseName: "date",
      type: "Date",
    },
    {
      name: "type",
      baseName: "type",
      type: "GetInboundEmailEventsByUuidLogs.TypeEnum",
    },
  ];

  static getAttributeTypeMap() {
    return GetInboundEmailEventsByUuidLogs.attributeTypeMap;
  }
}

export namespace GetInboundEmailEventsByUuidLogs {
  export enum TypeEnum {
    Received = <any>"received",
    Processed = <any>"processed",
    WebhookFailed = <any>"webhookFailed",
    WebhookDelivered = <any>"webhookDelivered",
  }
}
export class GetInboundEmailEventsEvents {
  /**
   * UUID that can be used to fetch additional data
   */
  "uuid": string;
  /**
   * Date when email was received on SMTP relay
   */
  "date": Date;
  /**
   * Sender’s email address
   */
  "sender": string;
  /**
   * Recipient’s email address
   */
  "recipient": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "uuid",
      baseName: "uuid",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "Date",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "string",
    },
    {
      name: "recipient",
      baseName: "recipient",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetInboundEmailEventsEvents.attributeTypeMap;
  }
}

export class GetIp {
  /**
   * ID of the dedicated IP
   */
  "id": number;
  /**
   * Dedicated IP
   */
  "ip": string;
  /**
   * Status of the IP (true=active, false=inactive)
   */
  "active": boolean;
  /**
   * Domain associated to the IP
   */
  "domain": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
    {
      name: "active",
      baseName: "active",
      type: "boolean",
    },
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetIp.attributeTypeMap;
  }
}

export class GetIpFromSender {
  /**
   * ID of the dedicated IP
   */
  "id": number;
  /**
   * Dedicated IP
   */
  "ip": string;
  /**
   * Domain associated to the IP
   */
  "domain": string;
  /**
   * Weight of the IP
   */
  "weight": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
    {
      name: "weight",
      baseName: "weight",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetIpFromSender.attributeTypeMap;
  }
}

export class GetIps {
  /**
   * Dedicated IP(s) available on your account
   */
  "ips": Array<GetIp>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ips",
      baseName: "ips",
      type: "Array<GetIp>",
    },
  ];

  static getAttributeTypeMap() {
    return GetIps.attributeTypeMap;
  }
}

export class GetIpsFromSender {
  /**
   * Dedicated IP(s) linked to a sender
   */
  "ips": Array<GetIpFromSender>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ips",
      baseName: "ips",
      type: "Array<GetIpFromSender>",
    },
  ];

  static getAttributeTypeMap() {
    return GetIpsFromSender.attributeTypeMap;
  }
}

export class GetList {
  /**
   * ID of the list
   */
  "id": number;
  /**
   * Name of the list
   */
  "name": string;
  /**
   * Number of blacklisted contacts in the list
   */
  "totalBlacklisted": number;
  /**
   * Number of contacts in the list
   */
  "totalSubscribers": number;
  /**
   * Number of unique contacts in the list
   */
  "uniqueSubscribers": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "totalBlacklisted",
      baseName: "totalBlacklisted",
      type: "number",
    },
    {
      name: "totalSubscribers",
      baseName: "totalSubscribers",
      type: "number",
    },
    {
      name: "uniqueSubscribers",
      baseName: "uniqueSubscribers",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetList.attributeTypeMap;
  }
}

export class GetExtendedList extends GetList {
  /**
   * ID of the folder
   */
  "folderId": number;
  /**
   * Creation UTC date-time of the list (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  "campaignStats"?: Array<GetExtendedListCampaignStats>;
  /**
   * Status telling if the list is dynamic or not (true=dynamic, false=not dynamic)
   */
  "dynamicList"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "folderId",
      baseName: "folderId",
      type: "number",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "campaignStats",
      baseName: "campaignStats",
      type: "Array<GetExtendedListCampaignStats>",
    },
    {
      name: "dynamicList",
      baseName: "dynamicList",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(GetExtendedList.attributeTypeMap);
  }
}

export class GetLists {
  /**
   * Listing of all the lists available in your account
   */
  "lists"?: Array<any>;
  /**
   * Number of lists in your account
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "lists",
      baseName: "lists",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetLists.attributeTypeMap;
  }
}

export class GetProcess {
  /**
   * Id of the process
   */
  "id": number;
  /**
   * Status of the process
   */
  "status": GetProcess.StatusEnum;
  /**
   * Process name
   */
  "name": string;
  /**
   * URL on which send export the of contacts once the process is completed
   */
  "exportUrl"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "status",
      baseName: "status",
      type: "GetProcess.StatusEnum",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "exportUrl",
      baseName: "export_url",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetProcess.attributeTypeMap;
  }
}

export namespace GetProcess {
  export enum StatusEnum {
    Queued = <any>"queued",
    InProcess = <any>"in_process",
    Completed = <any>"completed",
  }
}
export class GetProcesses {
  /**
   * List of processes available on your account
   */
  "processes"?: Array<GetProcess>;
  /**
   * Number of processes available on your account
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "processes",
      baseName: "processes",
      type: "Array<GetProcess>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetProcesses.attributeTypeMap;
  }
}

export class GetProductDetails {
  /**
   * Product ID for which you requested the details
   */
  "id": string;
  /**
   * Name of the product for which you requested the details
   */
  "name": string;
  /**
   * Creation UTC date-time of the product (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * Last modification UTC date-time of the product (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;
  /**
   * URL to the product
   */
  "url"?: string;
  /**
   * Absolute URL to the cover image of the product
   */
  "imageUrl"?: string;
  /**
   * Product identifier from the shop
   */
  "sku"?: string;
  /**
   * Price of the product
   */
  "price"?: number;
  /**
   * Category ID-s of the product
   */
  "categories"?: Array<string>;
  /**
   * Parent product id of the product
   */
  "parentId"?: string;
  /**
   * S3 url of original image
   */
  "s3Original"?: string;
  /**
   * S3 thumbnail url of original image in 120x120 dimension for analytics section
   */
  "s3ThumbAnalytics": string;
  /**
   * Meta data of product such as description, vendor, producer, stock level, etc.
   */
  "metaInfo"?: any;
  /**
   * S3 thumbnail url of original image in 600x400 dimension for editor section
   */
  "s3ThumbEditor": string;
  /**
   * product deleted from the shop's database
   */
  "isDeleted"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "imageUrl",
      baseName: "imageUrl",
      type: "string",
    },
    {
      name: "sku",
      baseName: "sku",
      type: "string",
    },
    {
      name: "price",
      baseName: "price",
      type: "number",
    },
    {
      name: "categories",
      baseName: "categories",
      type: "Array<string>",
    },
    {
      name: "parentId",
      baseName: "parentId",
      type: "string",
    },
    {
      name: "s3Original",
      baseName: "s3Original",
      type: "string",
    },
    {
      name: "s3ThumbAnalytics",
      baseName: "s3ThumbAnalytics",
      type: "string",
    },
    {
      name: "metaInfo",
      baseName: "metaInfo",
      type: "any",
    },
    {
      name: "s3ThumbEditor",
      baseName: "s3ThumbEditor",
      type: "string",
    },
    {
      name: "isDeleted",
      baseName: "isDeleted",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return GetProductDetails.attributeTypeMap;
  }
}

export class GetProducts {
  "products": Array<any>;
  /**
   * Number of products
   */
  "count": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "products",
      baseName: "products",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetProducts.attributeTypeMap;
  }
}

export class GetReports {
  "reports"?: Array<GetReportsReports>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "reports",
      baseName: "reports",
      type: "Array<GetReportsReports>",
    },
  ];

  static getAttributeTypeMap() {
    return GetReports.attributeTypeMap;
  }
}

export class GetReportsReports {
  /**
   * Date of the statistics
   */
  "date": string;
  /**
   * Number of requests for the date
   */
  "requests": number;
  /**
   * Number of delivered emails for the date
   */
  "delivered": number;
  /**
   * Number of hardbounces for the date
   */
  "hardBounces": number;
  /**
   * Number of softbounces for the date
   */
  "softBounces": number;
  /**
   * Number of clicks for the date
   */
  "clicks": number;
  /**
   * Number of unique clicks for the date
   */
  "uniqueClicks": number;
  /**
   * Number of openings for the date
   */
  "opens": number;
  /**
   * Number of unique openings for the date
   */
  "uniqueOpens": number;
  /**
   * Number of complaints (spam reports) for the date
   */
  "spamReports": number;
  /**
   * Number of blocked emails for the date
   */
  "blocked": number;
  /**
   * Number of invalid emails for the date
   */
  "invalid": number;
  /**
   * Number of unsubscribed emails for the date
   */
  "unsubscribed": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "requests",
      baseName: "requests",
      type: "number",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "number",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "number",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "number",
    },
    {
      name: "clicks",
      baseName: "clicks",
      type: "number",
    },
    {
      name: "uniqueClicks",
      baseName: "uniqueClicks",
      type: "number",
    },
    {
      name: "opens",
      baseName: "opens",
      type: "number",
    },
    {
      name: "uniqueOpens",
      baseName: "uniqueOpens",
      type: "number",
    },
    {
      name: "spamReports",
      baseName: "spamReports",
      type: "number",
    },
    {
      name: "blocked",
      baseName: "blocked",
      type: "number",
    },
    {
      name: "invalid",
      baseName: "invalid",
      type: "number",
    },
    {
      name: "unsubscribed",
      baseName: "unsubscribed",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetReportsReports.attributeTypeMap;
  }
}

export class GetScheduledEmailByBatchId {
  /**
   * Total number of batches
   */
  "count"?: number;
  "batches"?: Array<GetScheduledEmailByBatchIdBatches>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "batches",
      baseName: "batches",
      type: "Array<GetScheduledEmailByBatchIdBatches>",
    },
  ];

  static getAttributeTypeMap() {
    return GetScheduledEmailByBatchId.attributeTypeMap;
  }
}

export class GetScheduledEmailByBatchIdBatches {
  /**
   * Datetime for which the batch was scheduled
   */
  "scheduledAt": String;
  /**
   * Datetime on which the batch was scheduled
   */
  "createdAt": Date;
  /**
   * Current status of the scheduled batch
   */
  "status": GetScheduledEmailByBatchIdBatches.StatusEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "String",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "Date",
    },
    {
      name: "status",
      baseName: "status",
      type: "GetScheduledEmailByBatchIdBatches.StatusEnum",
    },
  ];

  static getAttributeTypeMap() {
    return GetScheduledEmailByBatchIdBatches.attributeTypeMap;
  }
}

export namespace GetScheduledEmailByBatchIdBatches {
  export enum StatusEnum {
    InProgress = <any>"inProgress",
    Queued = <any>"queued",
    Processed = <any>"processed",
    Error = <any>"error",
  }
}
export class GetScheduledEmailByMessageId {
  /**
   * Datetime for which the email was scheduled
   */
  "scheduledAt": String;
  /**
   * Datetime on which the email was scheduled
   */
  "createdAt": Date;
  /**
   * Current status of the scheduled email
   */
  "status": GetScheduledEmailByMessageId.StatusEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "String",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "Date",
    },
    {
      name: "status",
      baseName: "status",
      type: "GetScheduledEmailByMessageId.StatusEnum",
    },
  ];

  static getAttributeTypeMap() {
    return GetScheduledEmailByMessageId.attributeTypeMap;
  }
}

export namespace GetScheduledEmailByMessageId {
  export enum StatusEnum {
    InProgress = <any>"inProgress",
    Queued = <any>"queued",
    Processed = <any>"processed",
    Error = <any>"error",
  }
}
export class GetSegments {
  "segments"?: GetSegmentsSegments;
  /**
   * Number of Segments available in your account
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "segments",
      baseName: "segments",
      type: "GetSegmentsSegments",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetSegments.attributeTypeMap;
  }
}

export class GetSegmentsSegments {
  /**
   * ID of the list
   */
  "id"?: number;
  /**
   * Name of the Segment
   */
  "segmentName"?: string;
  /**
   * Name of the Segment Category
   */
  "categoryName"?: string;
  /**
   * Updation UTC date-time of the segment (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "updatedAt"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "segmentName",
      baseName: "segmentName",
      type: "string",
    },
    {
      name: "categoryName",
      baseName: "categoryName",
      type: "string",
    },
    {
      name: "updatedAt",
      baseName: "updatedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetSegmentsSegments.attributeTypeMap;
  }
}

export class GetSendersList {
  /**
   * List of the senders available in your account
   */
  "senders"?: Array<GetSendersListSenders>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "senders",
      baseName: "senders",
      type: "Array<GetSendersListSenders>",
    },
  ];

  static getAttributeTypeMap() {
    return GetSendersList.attributeTypeMap;
  }
}

export class GetSendersListIps {
  /**
   * Dedicated IP available in your account
   */
  "ip": string;
  /**
   * Domain of the IP
   */
  "domain": string;
  /**
   * Weight of the IP for this sender
   */
  "weight": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
    {
      name: "weight",
      baseName: "weight",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetSendersListIps.attributeTypeMap;
  }
}

export class GetSendersListSenders {
  /**
   * Id of the sender
   */
  "id": number;
  /**
   * From Name associated to the sender
   */
  "name": string;
  /**
   * From Email associated to the sender
   */
  "email": string;
  /**
   * Status of sender (true=activated, false=deactivated)
   */
  "active": boolean;
  /**
   * List of dedicated IP(s) available in the account. This data is displayed only for dedicated IPs
   */
  "ips"?: Array<GetSendersListIps>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "active",
      baseName: "active",
      type: "boolean",
    },
    {
      name: "ips",
      baseName: "ips",
      type: "Array<GetSendersListIps>",
    },
  ];

  static getAttributeTypeMap() {
    return GetSendersListSenders.attributeTypeMap;
  }
}

export class GetSharedTemplateUrl {
  /**
   * A unique URL for the email campaign or transactional template. This URL can be shared with other Brevo users.
   */
  "sharedUrl": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sharedUrl",
      baseName: "sharedUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetSharedTemplateUrl.attributeTypeMap;
  }
}

export namespace GetSmsCampaign {}
export class GetSmsCampaignOverview {
  /**
   * ID of the SMS Campaign
   */
  "id": number;
  /**
   * Name of the SMS Campaign
   */
  "name": string;
  /**
   * Status of the SMS Campaign
   */
  "status": GetSmsCampaignOverview.StatusEnum;
  /**
   * Content of the SMS Campaign
   */
  "content": string;
  /**
   * UTC date-time on which SMS campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
   */
  "scheduledAt"?: string;
  /**
   * Sender of the SMS Campaign
   */
  "sender": string;
  /**
   * Creation UTC date-time of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * UTC date-time of last modification of the SMS campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "status",
      baseName: "status",
      type: "GetSmsCampaignOverview.StatusEnum",
    },
    {
      name: "content",
      baseName: "content",
      type: "string",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmsCampaignOverview.attributeTypeMap;
  }
}

export class GetSmsCampaign extends GetSmsCampaignOverview {
  "recipients": GetSmsCampaignRecipients;
  "statistics": GetSmsCampaignRecipients;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "recipients",
      baseName: "recipients",
      type: "GetSmsCampaignRecipients",
    },
    {
      name: "statistics",
      baseName: "statistics",
      type: "GetSmsCampaignRecipients",
    },
  ];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(GetSmsCampaign.attributeTypeMap);
  }
}
export namespace GetSmsCampaignOverview {
  export enum StatusEnum {
    Draft = <any>"draft",
    Sent = <any>"sent",
    Archive = <any>"archive",
    Queued = <any>"queued",
    Suspended = <any>"suspended",
    InProcess = <any>"inProcess",
  }
}
export class GetSmsCampaignRecipients {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return GetSmsCampaignRecipients.attributeTypeMap;
  }
}

export class GetSmsCampaignStats {
  /**
   * Number of delivered SMS
   */
  "delivered": number;
  /**
   * Number of sent SMS
   */
  "sent": number;
  /**
   * Number of processing SMS
   */
  "processing": number;
  /**
   * Number of softbounced SMS
   */
  "softBounces": number;
  /**
   * Number of hardbounced SMS
   */
  "hardBounces": number;
  /**
   * Number of unsubscription SMS
   */
  "unsubscriptions": number;
  /**
   * Number of replies to the SMS
   */
  "answered": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "delivered",
      baseName: "delivered",
      type: "number",
    },
    {
      name: "sent",
      baseName: "sent",
      type: "number",
    },
    {
      name: "processing",
      baseName: "processing",
      type: "number",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "number",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "number",
    },
    {
      name: "unsubscriptions",
      baseName: "unsubscriptions",
      type: "number",
    },
    {
      name: "answered",
      baseName: "answered",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmsCampaignStats.attributeTypeMap;
  }
}

export class GetSmsCampaigns {
  "campaigns"?: Array<any>;
  /**
   * Number of SMS campaigns retrieved
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaigns",
      baseName: "campaigns",
      type: "Array<any>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmsCampaigns.attributeTypeMap;
  }
}

export class GetSmsEventReport {
  "events"?: Array<GetSmsEventReportEvents>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "events",
      baseName: "events",
      type: "Array<GetSmsEventReportEvents>",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmsEventReport.attributeTypeMap;
  }
}

export class GetSmsEventReportEvents {
  /**
   * Phone number which has generated the event
   */
  "phoneNumber"?: string;
  /**
   * UTC date-time on which the event has been generated
   */
  "date"?: string;
  /**
   * Message ID which generated the event
   */
  "messageId"?: string;
  /**
   * Event which occurred
   */
  "event"?: GetSmsEventReportEvents.EventEnum;
  /**
   * Reason of bounce (only available if the event is hardbounce or softbounce)
   */
  "reason"?: string;
  "reply"?: string;
  /**
   * Tag of the SMS which generated the event
   */
  "tag"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "phoneNumber",
      baseName: "phoneNumber",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
    {
      name: "event",
      baseName: "event",
      type: "GetSmsEventReportEvents.EventEnum",
    },
    {
      name: "reason",
      baseName: "reason",
      type: "string",
    },
    {
      name: "reply",
      baseName: "reply",
      type: "string",
    },
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmsEventReportEvents.attributeTypeMap;
  }
}

export namespace GetSmsEventReportEvents {
  export enum EventEnum {
    Bounces = <any>"bounces",
    HardBounces = <any>"hardBounces",
    SoftBounces = <any>"softBounces",
    Delivered = <any>"delivered",
    Sent = <any>"sent",
    Accepted = <any>"accepted",
    Unsubscription = <any>"unsubscription",
    Replies = <any>"replies",
    Blocked = <any>"blocked",
    Rejected = <any>"rejected",
  }
}
export class GetSmtpTemplateOverview {
  /**
   * ID of the template
   */
  "id": number;
  /**
   * Name of the template
   */
  "name": string;
  /**
   * Subject of the template
   */
  "subject": string;
  /**
   * Status of template (true=active, false=inactive)
   */
  "isActive": boolean;
  /**
   * Status of test sending for the template (true=test email has been sent, false=test email has not been sent)
   */
  "testSent": boolean;
  "sender": GetSmtpTemplateOverviewSender;
  /**
   * Email defined as the \"Reply to\" for the template
   */
  "replyTo": string;
  /**
   * Customisation of the \"to\" field for the template
   */
  "toField": string;
  /**
   * Tag of the template
   */
  "tag": string;
  /**
   * HTML content of the template
   */
  "htmlContent": string;
  /**
   * Creation UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * Last modification UTC date-time of the template (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;
  /**
   * It is true if template is a valid Double opt-in (DOI) template, otherwise it is false. This field will be available only in case of single template detail call.
   */
  "doiTemplate"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "isActive",
      baseName: "isActive",
      type: "boolean",
    },
    {
      name: "testSent",
      baseName: "testSent",
      type: "boolean",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "GetSmtpTemplateOverviewSender",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "string",
    },
    {
      name: "toField",
      baseName: "toField",
      type: "string",
    },
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "htmlContent",
      baseName: "htmlContent",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
    {
      name: "doiTemplate",
      baseName: "doiTemplate",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmtpTemplateOverview.attributeTypeMap;
  }
}

export class GetSmtpTemplateOverviewSender {
  /**
   * From email for the template
   */
  "name"?: string;
  /**
   * From email for the template
   */
  "email"?: string;
  /**
   * Sender id of the template
   */
  "id"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmtpTemplateOverviewSender.attributeTypeMap;
  }
}

export class GetSmtpTemplates {
  /**
   * Count of transactional email templates
   */
  "count"?: number;
  "templates"?: Array<GetSmtpTemplateOverview>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "templates",
      baseName: "templates",
      type: "Array<GetSmtpTemplateOverview>",
    },
  ];

  static getAttributeTypeMap() {
    return GetSmtpTemplates.attributeTypeMap;
  }
}

export class GetSsoToken {
  /**
   * Session token, it will remain valid for 15 days.
   */
  "token": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "token",
      baseName: "token",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetSsoToken.attributeTypeMap;
  }
}

export class GetStatsByBrowser extends null<String, GetDeviceBrowserStats> {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(GetStatsByBrowser.attributeTypeMap);
  }
}

export class GetStatsByDevice {
  /**
   * Statistics of the campaign on the basis of desktop devices
   */
  "desktop"?: { [key: string]: GetDeviceBrowserStats };
  /**
   * Statistics of the campaign on the basis of mobile devices
   */
  "mobile"?: { [key: string]: GetDeviceBrowserStats };
  /**
   * Statistics of the campaign on the basis of tablet devices
   */
  "tablet"?: { [key: string]: GetDeviceBrowserStats };
  /**
   * Statistics of the campaign on the basis of unknown devices
   */
  "unknown"?: { [key: string]: GetDeviceBrowserStats };

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "desktop",
      baseName: "desktop",
      type: "{ [key: string]: GetDeviceBrowserStats; }",
    },
    {
      name: "mobile",
      baseName: "mobile",
      type: "{ [key: string]: GetDeviceBrowserStats; }",
    },
    {
      name: "tablet",
      baseName: "tablet",
      type: "{ [key: string]: GetDeviceBrowserStats; }",
    },
    {
      name: "unknown",
      baseName: "unknown",
      type: "{ [key: string]: GetDeviceBrowserStats; }",
    },
  ];

  static getAttributeTypeMap() {
    return GetStatsByDevice.attributeTypeMap;
  }
}

export class GetStatsByDomain extends null<String, GetCampaignStats> {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return super
      .getAttributeTypeMap()
      .concat(GetStatsByDomain.attributeTypeMap);
  }
}

export class GetTransacAggregatedSmsReport {
  /**
   * Time frame of the report
   */
  "range"?: string;
  /**
   * Number of requests for the timeframe
   */
  "requests"?: number;
  /**
   * Number of delivered SMS for the timeframe
   */
  "delivered"?: number;
  /**
   * Number of hardbounces for the timeframe
   */
  "hardBounces"?: number;
  /**
   * Number of softbounces for the timeframe
   */
  "softBounces"?: number;
  /**
   * Number of blocked contact for the timeframe
   */
  "blocked"?: number;
  /**
   * Number of unsubscription for the timeframe
   */
  "unsubscribed"?: number;
  /**
   * Number of answered SMS for the timeframe
   */
  "replied"?: number;
  /**
   * Number of accepted for the timeframe
   */
  "accepted"?: number;
  /**
   * Number of rejected for the timeframe
   */
  "rejected"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "range",
      baseName: "range",
      type: "string",
    },
    {
      name: "requests",
      baseName: "requests",
      type: "number",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "number",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "number",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "number",
    },
    {
      name: "blocked",
      baseName: "blocked",
      type: "number",
    },
    {
      name: "unsubscribed",
      baseName: "unsubscribed",
      type: "number",
    },
    {
      name: "replied",
      baseName: "replied",
      type: "number",
    },
    {
      name: "accepted",
      baseName: "accepted",
      type: "number",
    },
    {
      name: "rejected",
      baseName: "rejected",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacAggregatedSmsReport.attributeTypeMap;
  }
}

export class GetTransacBlockedContacts {
  /**
   * Count of blocked or unsubscribed contact
   */
  "count"?: number;
  "contacts"?: Array<GetTransacBlockedContactsContacts>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "contacts",
      baseName: "contacts",
      type: "Array<GetTransacBlockedContactsContacts>",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacBlockedContacts.attributeTypeMap;
  }
}

export class GetTransacBlockedContactsContacts {
  /**
   * Email address of the blocked or unsubscribed contact
   */
  "email": string;
  /**
   * Sender email address of the blocked or unsubscribed contact
   */
  "senderEmail": string;
  "reason": GetTransacBlockedContactsReason;
  /**
   * Date when the contact was blocked or unsubscribed on
   */
  "blockedAt": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "senderEmail",
      baseName: "senderEmail",
      type: "string",
    },
    {
      name: "reason",
      baseName: "reason",
      type: "GetTransacBlockedContactsReason",
    },
    {
      name: "blockedAt",
      baseName: "blockedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacBlockedContactsContacts.attributeTypeMap;
  }
}

/**
 * Reason for blocking / unsubscribing
 */
export class GetTransacBlockedContactsReason {
  /**
   * Reason code for blocking / unsubscribing (This code is safe for comparison)
   */
  "code"?: GetTransacBlockedContactsReason.CodeEnum;
  /**
   * Reason for blocking / unsubscribing (This string is not safe for comparison)
   */
  "message"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "GetTransacBlockedContactsReason.CodeEnum",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacBlockedContactsReason.attributeTypeMap;
  }
}

export namespace GetTransacBlockedContactsReason {
  export enum CodeEnum {
    UnsubscribedViaMA = <any>"unsubscribedViaMA",
    UnsubscribedViaEmail = <any>"unsubscribedViaEmail",
    AdminBlocked = <any>"adminBlocked",
    UnsubscribedViaApi = <any>"unsubscribedViaApi",
    HardBounce = <any>"hardBounce",
    ContactFlaggedAsSpam = <any>"contactFlaggedAsSpam",
  }
}
export class GetTransacEmailContent {
  /**
   * Email address to which transactional email has been sent
   */
  "email": string;
  /**
   * Subject of the sent email
   */
  "subject": string;
  /**
   * Id of the template
   */
  "templateId"?: number;
  /**
   * Date on which transactional email was sent
   */
  "date": string;
  /**
   * Series of events which occurred on the transactional email
   */
  "events": Array<GetTransacEmailContentEvents>;
  /**
   * Actual content of the transactional email that has been sent
   */
  "body": string;
  /**
   * Count of the attachments that were sent in the email
   */
  "attachmentCount": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "events",
      baseName: "events",
      type: "Array<GetTransacEmailContentEvents>",
    },
    {
      name: "body",
      baseName: "body",
      type: "string",
    },
    {
      name: "attachmentCount",
      baseName: "attachmentCount",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacEmailContent.attributeTypeMap;
  }
}

export class GetTransacEmailContentEvents {
  /**
   * Name of the event that occurred on the sent email
   */
  "name": string;
  /**
   * Time at which the event occurred
   */
  "time": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "time",
      baseName: "time",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacEmailContentEvents.attributeTypeMap;
  }
}

export class GetTransacEmailsList {
  /**
   * Total number of transactional emails available on your account according to the passed filter
   */
  "count"?: number;
  "transactionalEmails"?: Array<GetTransacEmailsListTransactionalEmails>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "transactionalEmails",
      baseName: "transactionalEmails",
      type: "Array<GetTransacEmailsListTransactionalEmails>",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacEmailsList.attributeTypeMap;
  }
}

export class GetTransacEmailsListTransactionalEmails {
  /**
   * Email address to which transactional email has been sent
   */
  "email": string;
  /**
   * Subject of the sent email
   */
  "subject": string;
  /**
   * Id of the template
   */
  "templateId"?: number;
  /**
   * Message Id of the sent email
   */
  "messageId": string;
  /**
   * Unique id of the email sent to a particular contact
   */
  "uuid": string;
  /**
   * Date on which transactional email was sent
   */
  "date": string;
  /**
   * Email address of the sender from which the email was sent
   */
  "from"?: string;
  /**
   * Tags used for your email
   */
  "tags"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
    {
      name: "uuid",
      baseName: "uuid",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "from",
      baseName: "from",
      type: "string",
    },
    {
      name: "tags",
      baseName: "tags",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacEmailsListTransactionalEmails.attributeTypeMap;
  }
}

export class GetTransacSmsReport {
  "reports"?: Array<GetTransacSmsReportReports>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "reports",
      baseName: "reports",
      type: "Array<GetTransacSmsReportReports>",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacSmsReport.attributeTypeMap;
  }
}

export class GetTransacSmsReportReports {
  /**
   * Date for which statistics are retrieved
   */
  "date"?: string;
  /**
   * Number of requests for the date
   */
  "requests"?: number;
  /**
   * Number of delivered SMS for the date
   */
  "delivered"?: number;
  /**
   * Number of hardbounces for the date
   */
  "hardBounces"?: number;
  /**
   * Number of softbounces for the date
   */
  "softBounces"?: number;
  /**
   * Number of blocked contact for the date
   */
  "blocked"?: number;
  /**
   * Number of unsubscription for the date
   */
  "unsubscribed"?: number;
  /**
   * Number of answered SMS for the date
   */
  "replied"?: number;
  /**
   * Number of accepted for the date
   */
  "accepted"?: number;
  /**
   * Number of rejected for the date
   */
  "rejected"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "requests",
      baseName: "requests",
      type: "number",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "number",
    },
    {
      name: "hardBounces",
      baseName: "hardBounces",
      type: "number",
    },
    {
      name: "softBounces",
      baseName: "softBounces",
      type: "number",
    },
    {
      name: "blocked",
      baseName: "blocked",
      type: "number",
    },
    {
      name: "unsubscribed",
      baseName: "unsubscribed",
      type: "number",
    },
    {
      name: "replied",
      baseName: "replied",
      type: "number",
    },
    {
      name: "accepted",
      baseName: "accepted",
      type: "number",
    },
    {
      name: "rejected",
      baseName: "rejected",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetTransacSmsReportReports.attributeTypeMap;
  }
}

export class GetWATemplates {
  "templates": Array<GetWATemplatesTemplates>;
  /**
   * Number of whatsApp templates retrived
   */
  "count": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "templates",
      baseName: "templates",
      type: "Array<GetWATemplatesTemplates>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetWATemplates.attributeTypeMap;
  }
}

export class GetWATemplatesTemplates {
  /**
   * id of the template
   */
  "id": string;
  /**
   * Name of the WhatsApp template
   */
  "name": string;
  /**
   * Status of the WhatsApp template
   */
  "status": string;
  /**
   * Language in which template exists
   */
  "language": string;
  /**
   * category of the template
   */
  "category": string;
  /**
   * Error reason in the template creation
   */
  "errorReason"?: string;
  /**
   * Creation UTC date-time of the whatsApp template (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * UTC date-time of last modification of the whatsApp template (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "status",
      baseName: "status",
      type: "string",
    },
    {
      name: "language",
      baseName: "language",
      type: "string",
    },
    {
      name: "category",
      baseName: "category",
      type: "string",
    },
    {
      name: "errorReason",
      baseName: "errorReason",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetWATemplatesTemplates.attributeTypeMap;
  }
}

export class GetWebhook {
  /**
   * URL of the webhook
   */
  "url": string;
  /**
   * ID of the webhook
   */
  "id": number;
  /**
   * Description of the webhook
   */
  "description": string;
  "events": Array<string>;
  /**
   * Type of webhook (marketing or transactional)
   */
  "type": GetWebhook.TypeEnum;
  /**
   * Creation UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * Last modification UTC date-time of the webhook (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "description",
      baseName: "description",
      type: "string",
    },
    {
      name: "events",
      baseName: "events",
      type: "Array<string>",
    },
    {
      name: "type",
      baseName: "type",
      type: "GetWebhook.TypeEnum",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetWebhook.attributeTypeMap;
  }
}

export namespace GetWebhook {
  export enum TypeEnum {
    Marketing = <any>"marketing",
    Transactional = <any>"transactional",
  }
}
export class GetWebhooks {
  "webhooks": Array<any>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "webhooks",
      baseName: "webhooks",
      type: "Array<any>",
    },
  ];

  static getAttributeTypeMap() {
    return GetWebhooks.attributeTypeMap;
  }
}

export class GetWhatsAppConfig {
  /**
   * Id of the WhatsApp business account
   */
  "whatsappBusinessAccountId"?: string;
  /**
   * Sending limit Information of the WhatsApp API account
   */
  "sendingLimit"?: string;
  /**
   * Quality status of phone number associated with WhatsApp account. There are three quality ratings. example - **High (GREEN) , Medium (YELLOW) and Low(RED)**
   */
  "phoneNumberQuality"?: GetWhatsAppConfig.PhoneNumberQualityEnum;
  /**
   * Status information related to WhatsApp Api account
   */
  "whatsappBusinessAccountStatus"?: string;
  /**
   * Verification status information of the Business account
   */
  "businessStatus"?: string;
  /**
   * Status of the name associated with WhatsApp Phone number
   */
  "phoneNumberNameStatus"?: GetWhatsAppConfig.PhoneNumberNameStatusEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "whatsappBusinessAccountId",
      baseName: "whatsappBusinessAccountId",
      type: "string",
    },
    {
      name: "sendingLimit",
      baseName: "sendingLimit",
      type: "string",
    },
    {
      name: "phoneNumberQuality",
      baseName: "phoneNumberQuality",
      type: "GetWhatsAppConfig.PhoneNumberQualityEnum",
    },
    {
      name: "whatsappBusinessAccountStatus",
      baseName: "whatsappBusinessAccountStatus",
      type: "string",
    },
    {
      name: "businessStatus",
      baseName: "businessStatus",
      type: "string",
    },
    {
      name: "phoneNumberNameStatus",
      baseName: "phoneNumberNameStatus",
      type: "GetWhatsAppConfig.PhoneNumberNameStatusEnum",
    },
  ];

  static getAttributeTypeMap() {
    return GetWhatsAppConfig.attributeTypeMap;
  }
}

export namespace GetWhatsAppConfig {
  export enum PhoneNumberQualityEnum {
    GREEN = <any>"GREEN",
    YELLOW = <any>"YELLOW",
    RED = <any>"RED",
  }
  export enum PhoneNumberNameStatusEnum {
    APPROVED = <any>"APPROVED",
    PENDING = <any>"PENDING",
    REJECTED = <any>"REJECTED",
  }
}
export class GetWhatsappCampaignOverview {
  /**
   * ID of the WhatsApp Campaign
   */
  "id": number;
  /**
   * Name of the WhatsApp Campaign
   */
  "campaignName": string;
  /**
   * Status of the WhatsApp Campaign
   */
  "campaignStatus": GetWhatsappCampaignOverview.CampaignStatusEnum;
  /**
   * UTC date-time on which WhatsApp campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
   */
  "scheduledAt"?: string;
  /**
   * Sender of the WhatsApp Campaign
   */
  "senderNumber": string;
  "stats"?: WhatsappCampStats;
  "template": WhatsappCampTemplate;
  /**
   * Creation UTC date-time of the WhatsApp campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * UTC date-time of last modification of the WhatsApp campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "campaignName",
      baseName: "campaignName",
      type: "string",
    },
    {
      name: "campaignStatus",
      baseName: "campaignStatus",
      type: "GetWhatsappCampaignOverview.CampaignStatusEnum",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "senderNumber",
      baseName: "senderNumber",
      type: "string",
    },
    {
      name: "stats",
      baseName: "stats",
      type: "WhatsappCampStats",
    },
    {
      name: "template",
      baseName: "template",
      type: "WhatsappCampTemplate",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetWhatsappCampaignOverview.attributeTypeMap;
  }
}

export namespace GetWhatsappCampaignOverview {
  export enum CampaignStatusEnum {
    Draft = <any>"draft",
    Scheduled = <any>"scheduled",
    Pending = <any>"pending",
    Approved = <any>"approved",
    Running = <any>"running",
    Suspended = <any>"suspended",
    Rejected = <any>"rejected",
    Sent = <any>"sent",
  }
}
export class GetWhatsappCampaigns {
  "campaigns"?: Array<GetWhatsappCampaignsCampaigns>;
  /**
   * Number of WhatsApp campaigns retrived
   */
  "count"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "campaigns",
      baseName: "campaigns",
      type: "Array<GetWhatsappCampaignsCampaigns>",
    },
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return GetWhatsappCampaigns.attributeTypeMap;
  }
}

export class GetWhatsappCampaignsCampaigns {
  /**
   * ID of the WhatsApp Campaign
   */
  "id": number;
  /**
   * Name of the WhatsApp Campaign
   */
  "campaignName": string;
  /**
   * Id of the WhatsApp template
   */
  "templateId": string;
  /**
   * Status of the WhatsApp Campaign
   */
  "campaignStatus": GetWhatsappCampaignsCampaigns.CampaignStatusEnum;
  /**
   * UTC date-time on which WhatsApp campaign is scheduled. Should be in YYYY-MM-DDTHH:mm:ss.SSSZ format
   */
  "scheduledAt": string;
  /**
   * Error reason in the campaign creation
   */
  "errorReason"?: string;
  /**
   * Count of invalidated contacts
   */
  "invalidatedContacts"?: number;
  /**
   * Read percentage of the the WhatsApp campaign created
   */
  "readPercentage"?: number;
  "stats"?: WhatsappCampStats;
  /**
   * Creation UTC date-time of the WhatsApp campaign (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "createdAt": string;
  /**
   * UTC date-time of last modification of the whatsapp template (YYYY-MM-DDTHH:mm:ss.SSSZ)
   */
  "modifiedAt": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "campaignName",
      baseName: "campaignName",
      type: "string",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "string",
    },
    {
      name: "campaignStatus",
      baseName: "campaignStatus",
      type: "GetWhatsappCampaignsCampaigns.CampaignStatusEnum",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "errorReason",
      baseName: "errorReason",
      type: "string",
    },
    {
      name: "invalidatedContacts",
      baseName: "invalidatedContacts",
      type: "number",
    },
    {
      name: "readPercentage",
      baseName: "readPercentage",
      type: "number",
    },
    {
      name: "stats",
      baseName: "stats",
      type: "WhatsappCampStats",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "modifiedAt",
      baseName: "modifiedAt",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetWhatsappCampaignsCampaigns.attributeTypeMap;
  }
}

export namespace GetWhatsappCampaignsCampaigns {
  export enum CampaignStatusEnum {
    Draft = <any>"draft",
    Scheduled = <any>"scheduled",
    Pending = <any>"pending",
    Approved = <any>"approved",
    Running = <any>"running",
    Suspended = <any>"suspended",
    Rejected = <any>"rejected",
    Sent = <any>"sent",
  }
}
export class GetWhatsappEventReport {
  "events"?: Array<GetWhatsappEventReportEvents>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "events",
      baseName: "events",
      type: "Array<GetWhatsappEventReportEvents>",
    },
  ];

  static getAttributeTypeMap() {
    return GetWhatsappEventReport.attributeTypeMap;
  }
}

export class GetWhatsappEventReportEvents {
  /**
   * WhatsApp Number with country code. Example, 85264318721
   */
  "contactNumber": string;
  /**
   * UTC date-time on which the event has been generated
   */
  "date": string;
  /**
   * Message ID which generated the event
   */
  "messageId": string;
  /**
   * Event which occurred
   */
  "event": GetWhatsappEventReportEvents.EventEnum;
  /**
   * Reason for the event (will be there in case of `error` and `soft-bounce` events)
   */
  "reason"?: string;
  /**
   * Text of the reply (will be there only in case of `reply` event with text)
   */
  "body"?: string;
  /**
   * Url of the media reply (will be there only in case of `reply` event with media)
   */
  "mediaUrl"?: string;
  /**
   * WhatsApp Number with country code. Example, 85264318721
   */
  "senderNumber": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "contactNumber",
      baseName: "contactNumber",
      type: "string",
    },
    {
      name: "date",
      baseName: "date",
      type: "string",
    },
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
    {
      name: "event",
      baseName: "event",
      type: "GetWhatsappEventReportEvents.EventEnum",
    },
    {
      name: "reason",
      baseName: "reason",
      type: "string",
    },
    {
      name: "body",
      baseName: "body",
      type: "string",
    },
    {
      name: "mediaUrl",
      baseName: "mediaUrl",
      type: "string",
    },
    {
      name: "senderNumber",
      baseName: "senderNumber",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return GetWhatsappEventReportEvents.attributeTypeMap;
  }
}

export namespace GetWhatsappEventReportEvents {
  export enum EventEnum {
    Sent = <any>"sent",
    Delivered = <any>"delivered",
    Read = <any>"read",
    Error = <any>"error",
    Unsubscribe = <any>"unsubscribe",
    Reply = <any>"reply",
    SoftBounce = <any>"soft-bounce",
  }
}
/**
 * Created company id
 */
export class InlineResponse200 {
  /**
   * Unique company id
   */
  "id": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return InlineResponse200.attributeTypeMap;
  }
}

/**
 * Created deal id
 */
export class InlineResponse201 {
  /**
   * Unique deal id
   */
  "id": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return InlineResponse201.attributeTypeMap;
  }
}

/**
 * Task Details
 */
export class InlineResponse2011 {
  /**
   * Unique task id
   */
  "id": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return InlineResponse2011.attributeTypeMap;
  }
}

export class InlineResponse2012 {
  /**
   * messageId of sent message
   */
  "messageId": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return InlineResponse2012.attributeTypeMap;
  }
}

export class InlineResponse2013 {
  /**
   * ID of the object created
   */
  "id": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return InlineResponse2013.attributeTypeMap;
  }
}

export class ManageIp {
  /**
   * Dedicated ID
   */
  "ip"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "ip",
      baseName: "ip",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ManageIp.attributeTypeMap;
  }
}

export class MasterDetailsResponse {
  /**
   * Email id of master account
   */
  "email"?: string;
  /**
   * Company name of master account organization
   */
  "companyName"?: string;
  /**
   * Unique identifier of the master account organization
   */
  "id"?: number;
  /**
   * Currency code of the master account organization
   */
  "currencyCode"?: string;
  /**
   * Timezone of the master account organization
   */
  "timezone"?: string;
  "billingInfo"?: MasterDetailsResponseBillingInfo;
  "planInfo"?: MasterDetailsResponsePlanInfo;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "currencyCode",
      baseName: "currencyCode",
      type: "string",
    },
    {
      name: "timezone",
      baseName: "timezone",
      type: "string",
    },
    {
      name: "billingInfo",
      baseName: "billingInfo",
      type: "MasterDetailsResponseBillingInfo",
    },
    {
      name: "planInfo",
      baseName: "planInfo",
      type: "MasterDetailsResponsePlanInfo",
    },
  ];

  static getAttributeTypeMap() {
    return MasterDetailsResponse.attributeTypeMap;
  }
}

/**
 * Billing details of the master account organization
 */
export class MasterDetailsResponseBillingInfo {
  /**
   * Billing email id of master account
   */
  "email"?: string;
  /**
   * Company name of master account
   */
  "companyName"?: string;
  "name"?: MasterDetailsResponseBillingInfoName;
  "address"?: MasterDetailsResponseBillingInfoAddress;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "MasterDetailsResponseBillingInfoName",
    },
    {
      name: "address",
      baseName: "address",
      type: "MasterDetailsResponseBillingInfoAddress",
    },
  ];

  static getAttributeTypeMap() {
    return MasterDetailsResponseBillingInfo.attributeTypeMap;
  }
}

/**
 * Billing address of master account
 */
export class MasterDetailsResponseBillingInfoAddress {
  /**
   * Street address
   */
  "streetAddress"?: string;
  /**
   * Locality
   */
  "locality"?: string;
  /**
   * Postal code
   */
  "postalCode"?: string;
  /**
   * State code
   */
  "stateCode"?: string;
  /**
   * Country code
   */
  "countryCode"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "streetAddress",
      baseName: "streetAddress",
      type: "string",
    },
    {
      name: "locality",
      baseName: "locality",
      type: "string",
    },
    {
      name: "postalCode",
      baseName: "postalCode",
      type: "string",
    },
    {
      name: "stateCode",
      baseName: "stateCode",
      type: "string",
    },
    {
      name: "countryCode",
      baseName: "countryCode",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return MasterDetailsResponseBillingInfoAddress.attributeTypeMap;
  }
}

/**
 * Billing name of master account holder
 */
export class MasterDetailsResponseBillingInfoName {
  /**
   * First name for billing
   */
  "givenName"?: string;
  /**
   * Last name for billing
   */
  "familyName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "givenName",
      baseName: "givenName",
      type: "string",
    },
    {
      name: "familyName",
      baseName: "familyName",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return MasterDetailsResponseBillingInfoName.attributeTypeMap;
  }
}

/**
 * Plan details
 */
export class MasterDetailsResponsePlanInfo {
  /**
   * Plan currency
   */
  "currencyCode"?: string;
  /**
   * Timestamp of next billing date
   */
  "nextBillingAt"?: number;
  /**
   * Plan amount
   */
  "price"?: number;
  /**
   * Plan period type
   */
  "planPeriod"?: MasterDetailsResponsePlanInfo.PlanPeriodEnum;
  /**
   * Number of sub-accounts
   */
  "subAccounts"?: number;
  /**
   * List of provided features in the plan
   */
  "features"?: Array<MasterDetailsResponsePlanInfoFeatures>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "currencyCode",
      baseName: "currencyCode",
      type: "string",
    },
    {
      name: "nextBillingAt",
      baseName: "nextBillingAt",
      type: "number",
    },
    {
      name: "price",
      baseName: "price",
      type: "number",
    },
    {
      name: "planPeriod",
      baseName: "planPeriod",
      type: "MasterDetailsResponsePlanInfo.PlanPeriodEnum",
    },
    {
      name: "subAccounts",
      baseName: "subAccounts",
      type: "number",
    },
    {
      name: "features",
      baseName: "features",
      type: "Array<MasterDetailsResponsePlanInfoFeatures>",
    },
  ];

  static getAttributeTypeMap() {
    return MasterDetailsResponsePlanInfo.attributeTypeMap;
  }
}

export namespace MasterDetailsResponsePlanInfo {
  export enum PlanPeriodEnum {
    Month = <any>"month",
    Year = <any>"year",
  }
}
export class MasterDetailsResponsePlanInfoFeatures {
  /**
   * Name of the feature
   */
  "name"?: string;
  /**
   * Unit value of the feature
   */
  "unitValue"?: string;
  /**
   * Quantity provided in the plan
   */
  "quantity"?: number;
  /**
   * Quantity consumed by master
   */
  "used"?: number;
  /**
   * Quantity remaining in the plan
   */
  "remaining"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "unitValue",
      baseName: "unitValue",
      type: "string",
    },
    {
      name: "quantity",
      baseName: "quantity",
      type: "number",
    },
    {
      name: "used",
      baseName: "used",
      type: "number",
    },
    {
      name: "remaining",
      baseName: "remaining",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return MasterDetailsResponsePlanInfoFeatures.attributeTypeMap;
  }
}

/**
 * Note Details
 */
export class Note {
  /**
   * Unique note Id
   */
  "id"?: string;
  /**
   * Text content of a note
   */
  "text": string;
  /**
   * Contact ids linked to a note
   */
  "contactIds"?: Array<number>;
  /**
   * Deal ids linked to a note
   */
  "dealIds"?: Array<string>;
  /**
   * Account details of user which created the note
   */
  "authorId"?: any;
  /**
   * Note created date/time
   */
  "createdAt"?: Date;
  /**
   * Note updated date/time
   */
  "updatedAt"?: Date;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
    {
      name: "contactIds",
      baseName: "contactIds",
      type: "Array<number>",
    },
    {
      name: "dealIds",
      baseName: "dealIds",
      type: "Array<string>",
    },
    {
      name: "authorId",
      baseName: "authorId",
      type: "any",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "Date",
    },
    {
      name: "updatedAt",
      baseName: "updatedAt",
      type: "Date",
    },
  ];

  static getAttributeTypeMap() {
    return Note.attributeTypeMap;
  }
}

/**
 * Note data to be saved
 */
export class NoteData {
  /**
   * Text content of a note
   */
  "text": string;
  /**
   * Contact Ids linked to a note
   */
  "contactIds"?: Array<number>;
  /**
   * Deal Ids linked to a note
   */
  "dealIds"?: Array<string>;
  /**
   * Company Ids linked to a note
   */
  "companyIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
    {
      name: "contactIds",
      baseName: "contactIds",
      type: "Array<number>",
    },
    {
      name: "dealIds",
      baseName: "dealIds",
      type: "Array<string>",
    },
    {
      name: "companyIds",
      baseName: "companyIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return NoteData.attributeTypeMap;
  }
}

/**
 * Updated Note ID
 */
export class NoteId {
  /**
   * Unique note Id
   */
  "id"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return NoteId.attributeTypeMap;
  }
}

/**
 * List of notes
 */
export class NoteList extends Array<Note> {
  static discriminator: string | undefined = undefined;
}

export class Order {
  /**
   * Unique ID of the order.
   */
  "id": string;
  /**
   * Event occurrence UTC date-time (YYYY-MM-DDTHH:mm:ssZ), when order is actually created.
   */
  "createdAt": string;
  /**
   * Event updated UTC date-time (YYYY-MM-DDTHH:mm:ssZ), when the status of the order is actually changed/updated.
   */
  "updatedAt": string;
  /**
   * State of the order.
   */
  "status": string;
  /**
   * Total amount of the order, including all shipping expenses, tax and the price of items.
   */
  "amount": number;
  "products": Array<OrderProducts>;
  /**
   * Email of the contact, Mandatory if \"phone\" field is not passed in \"billing\" parameter.
   */
  "email"?: string;
  "billing"?: OrderBilling;
  /**
   * Coupons applied to the order. Stored case insensitive.
   */
  "coupons"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "string",
    },
    {
      name: "updatedAt",
      baseName: "updatedAt",
      type: "string",
    },
    {
      name: "status",
      baseName: "status",
      type: "string",
    },
    {
      name: "amount",
      baseName: "amount",
      type: "number",
    },
    {
      name: "products",
      baseName: "products",
      type: "Array<OrderProducts>",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "billing",
      baseName: "billing",
      type: "OrderBilling",
    },
    {
      name: "coupons",
      baseName: "coupons",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return Order.attributeTypeMap;
  }
}

export class OrderBatch {
  /**
   * array of order objects
   */
  "orders": Array<Order>;
  /**
   * Notify Url provided by client to get the status of batch request
   */
  "notifyUrl"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "orders",
      baseName: "orders",
      type: "Array<Order>",
    },
    {
      name: "notifyUrl",
      baseName: "notifyUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return OrderBatch.attributeTypeMap;
  }
}

/**
 * Billing details of an order.
 */
export class OrderBilling {
  /**
   * Full billing address.
   */
  "address"?: string;
  /**
   * Exact city of the address.
   */
  "city"?: string;
  /**
   * Billing country 2-letter ISO code.
   */
  "countryCode"?: string;
  /**
   * Phone number to contact for further details about the order, Mandatory if \"email\" field is not passed.
   */
  "phone"?: string;
  /**
   * Postcode for delivery and billing.
   */
  "postCode"?: string;
  /**
   * How the visitor will pay for the item(s), e.g. paypal, check, etc.
   */
  "paymentMethod"?: string;
  /**
   * Exact region (state/province) for delivery and billing.
   */
  "region"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "address",
      baseName: "address",
      type: "string",
    },
    {
      name: "city",
      baseName: "city",
      type: "string",
    },
    {
      name: "countryCode",
      baseName: "countryCode",
      type: "string",
    },
    {
      name: "phone",
      baseName: "phone",
      type: "string",
    },
    {
      name: "postCode",
      baseName: "postCode",
      type: "string",
    },
    {
      name: "paymentMethod",
      baseName: "paymentMethod",
      type: "string",
    },
    {
      name: "region",
      baseName: "region",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return OrderBilling.attributeTypeMap;
  }
}

/**
 * Details for the Products in an order.
 */
export class OrderProducts {
  /**
   * ID of the product.
   */
  "productId": string;
  /**
   * How many pieces of the product the visitor has added to the cart.
   */
  "quantity": number;
  /**
   * Product ID of the red color shirts.
   */
  "variantId"?: string;
  /**
   * The price of a unit of product
   */
  "price": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "productId",
      baseName: "productId",
      type: "string",
    },
    {
      name: "quantity",
      baseName: "quantity",
      type: "number",
    },
    {
      name: "variantId",
      baseName: "variantId",
      type: "string",
    },
    {
      name: "price",
      baseName: "price",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return OrderProducts.attributeTypeMap;
  }
}

export class Otp {
  /**
   * 6 digit OTP received on email
   */
  "name"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return Otp.attributeTypeMap;
  }
}

/**
 * List of stages
 */
export class Pipeline {
  /**
   * List of stages
   */
  "stages"?: Array<PipelineStage>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "stages",
      baseName: "stages",
      type: "Array<PipelineStage>",
    },
  ];

  static getAttributeTypeMap() {
    return Pipeline.attributeTypeMap;
  }
}

/**
 * List of stages
 */
export class PipelineStage {
  /**
   * Stage id
   */
  "id"?: string;
  /**
   * Stage name
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return PipelineStage.attributeTypeMap;
  }
}

export class PostContactInfo {
  "contacts": PostContactInfoContacts;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "contacts",
      baseName: "contacts",
      type: "PostContactInfoContacts",
    },
  ];

  static getAttributeTypeMap() {
    return PostContactInfo.attributeTypeMap;
  }
}

export class PostContactInfoContacts {
  "success"?: Array<string>;
  "failure"?: Array<string>;
  /**
   * Displays the count of total number of contacts removed from list when user opts for \"all\" option.
   */
  "total"?: number;
  /**
   * Id of the process created to remove contacts from list when user opts for \"all\" option.
   */
  "processId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "success",
      baseName: "success",
      type: "Array<string>",
    },
    {
      name: "failure",
      baseName: "failure",
      type: "Array<string>",
    },
    {
      name: "total",
      baseName: "total",
      type: "number",
    },
    {
      name: "processId",
      baseName: "processId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return PostContactInfoContacts.attributeTypeMap;
  }
}

export class PostSendFailed {
  /**
   * Response code
   */
  "code": number;
  /**
   * Response message
   */
  "message": string;
  "unexistingEmails"?: Array<string>;
  "withoutListEmails"?: Array<string>;
  "blackListedEmails"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "unexistingEmails",
      baseName: "unexistingEmails",
      type: "Array<string>",
    },
    {
      name: "withoutListEmails",
      baseName: "withoutListEmails",
      type: "Array<string>",
    },
    {
      name: "blackListedEmails",
      baseName: "blackListedEmails",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return PostSendFailed.attributeTypeMap;
  }
}

export class PostSendSmsTestFailed {
  /**
   * Response code
   */
  "code": number;
  /**
   * Response message
   */
  "message": string;
  "unexistingSms"?: Array<string>;
  "withoutListSms"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "code",
      baseName: "code",
      type: "number",
    },
    {
      name: "message",
      baseName: "message",
      type: "string",
    },
    {
      name: "unexistingSms",
      baseName: "unexistingSms",
      type: "Array<string>",
    },
    {
      name: "withoutListSms",
      baseName: "withoutListSms",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return PostSendSmsTestFailed.attributeTypeMap;
  }
}

export class RemainingCreditModel {
  "child": RemainingCreditModelChild;
  "reseller": RemainingCreditModelReseller;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "child",
      baseName: "child",
      type: "RemainingCreditModelChild",
    },
    {
      name: "reseller",
      baseName: "reseller",
      type: "RemainingCreditModelReseller",
    },
  ];

  static getAttributeTypeMap() {
    return RemainingCreditModel.attributeTypeMap;
  }
}

/**
 * Credits remaining for child account
 */
export class RemainingCreditModelChild {
  /**
   * SMS Credits remaining for child account
   */
  "sms": number;
  /**
   * Email Credits remaining for child account
   */
  "email": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sms",
      baseName: "sms",
      type: "number",
    },
    {
      name: "email",
      baseName: "email",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return RemainingCreditModelChild.attributeTypeMap;
  }
}

export class RemainingCreditModelReseller {
  /**
   * SMS Credits remaining for reseller account
   */
  "sms": number;
  /**
   * Email Credits remaining for reseller account
   */
  "email": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sms",
      baseName: "sms",
      type: "number",
    },
    {
      name: "email",
      baseName: "email",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return RemainingCreditModelReseller.attributeTypeMap;
  }
}

export class RemoveContactFromList {
  /**
   * Required if 'all' is false. Emails to remove from a list. You can pass a maximum of 150 emails for removal in one request.
   */
  "emails"?: Array<string>;
  /**
   * Mandatory if Emails are not passed, ignored otherwise. Emails to add to a list. You can pass a maximum of 150 emails for addition in one request. If you need to add the emails in bulk, please prefer /contacts/import api.
   */
  "ids"?: Array<number>;
  /**
   * Required if none of 'emails' or 'ids' are passed. Remove all existing contacts from a list.  A process will be created in this scenario. You can fetch the process details to know about the progress
   */
  "all"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "emails",
      baseName: "emails",
      type: "Array<string>",
    },
    {
      name: "ids",
      baseName: "ids",
      type: "Array<number>",
    },
    {
      name: "all",
      baseName: "all",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return RemoveContactFromList.attributeTypeMap;
  }
}

export class RemoveCredits {
  /**
   * Required if email credits are empty. SMS credits to be removed from the child account
   */
  "sms"?: number;
  /**
   * Required if sms credits are empty. Email credits to be removed from the child account
   */
  "email"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sms",
      baseName: "sms",
      type: "number",
    },
    {
      name: "email",
      baseName: "email",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return RemoveCredits.attributeTypeMap;
  }
}

export class RequestContactExport {
  /**
   * List of all the attributes that you want to export. These attributes must be present in your contact database. For example, ['fname', 'lname', 'email'].
   */
  "exportAttributes"?: Array<string>;
  "customContactFilter": RequestContactExportCustomContactFilter;
  /**
   * Webhook that will be called once the export process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479
   */
  "notifyUrl"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "exportAttributes",
      baseName: "exportAttributes",
      type: "Array<string>",
    },
    {
      name: "customContactFilter",
      baseName: "customContactFilter",
      type: "RequestContactExportCustomContactFilter",
    },
    {
      name: "notifyUrl",
      baseName: "notifyUrl",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return RequestContactExport.attributeTypeMap;
  }
}

/**
 * Set the filter for the contacts to be exported.
 */
export class RequestContactExportCustomContactFilter {
  /**
   * Mandatory if neither actionForEmailCampaigns nor actionForSmsCampaigns is passed. This will export the contacts on the basis of provided action applied on contacts as per the list id. * allContacts - Fetch the list of all contacts for a particular list. * subscribed & unsubscribed - Fetch the list of subscribed / unsubscribed (blacklisted via any means) contacts for a particular list. * unsubscribedPerList - Fetch the list of contacts that are unsubscribed from a particular list only.
   */
  "actionForContacts"?: RequestContactExportCustomContactFilter.ActionForContactsEnum;
  /**
   * Mandatory if neither actionForContacts nor actionForSmsCampaigns is passed. This will export the contacts on the basis of provided action applied on email campaigns. * openers & nonOpeners - emailCampaignId is mandatory. Fetch the list of readers / non-readers for a particular email campaign. * clickers & nonClickers - emailCampaignId is mandatory. Fetch the list of clickers / non-clickers for a particular email campaign. * unsubscribed - emailCampaignId is mandatory. Fetch the list of all unsubscribed (blacklisted via any means) contacts for a particular email campaign. * hardBounces & softBounces - emailCampaignId is optional. Fetch the list of hard bounces / soft bounces for a particular / all email campaign(s).
   */
  "actionForEmailCampaigns"?: RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum;
  /**
   * Mandatory if neither actionForContacts nor actionForEmailCampaigns is passed. This will export the contacts on the basis of provided action applied on sms campaigns. * unsubscribed - Fetch the list of all unsubscribed (blacklisted via any means) contacts for all / particular sms campaigns. * hardBounces & softBounces - Fetch the list of hard bounces / soft bounces for all / particular sms campaigns.
   */
  "actionForSmsCampaigns"?: RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum;
  /**
   * Mandatory if actionForContacts is passed, ignored otherwise. Id of the list for which the corresponding action shall be applied in the filter.
   */
  "listId"?: number;
  /**
   * Considered only if actionForEmailCampaigns is passed, ignored otherwise. Mandatory if action is one of the following - openers, nonOpeners, clickers, nonClickers, unsubscribed. The id of the email campaign for which the corresponding action shall be applied in the filter.
   */
  "emailCampaignId"?: number;
  /**
   * Considered only if actionForSmsCampaigns is passed, ignored otherwise. The id of sms campaign for which the corresponding action shall be applied in the filter.
   */
  "smsCampaignId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "actionForContacts",
      baseName: "actionForContacts",
      type: "RequestContactExportCustomContactFilter.ActionForContactsEnum",
    },
    {
      name: "actionForEmailCampaigns",
      baseName: "actionForEmailCampaigns",
      type: "RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum",
    },
    {
      name: "actionForSmsCampaigns",
      baseName: "actionForSmsCampaigns",
      type: "RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum",
    },
    {
      name: "listId",
      baseName: "listId",
      type: "number",
    },
    {
      name: "emailCampaignId",
      baseName: "emailCampaignId",
      type: "number",
    },
    {
      name: "smsCampaignId",
      baseName: "smsCampaignId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return RequestContactExportCustomContactFilter.attributeTypeMap;
  }
}

export namespace RequestContactExportCustomContactFilter {
  export enum ActionForContactsEnum {
    AllContacts = <any>"allContacts",
    Subscribed = <any>"subscribed",
    Unsubscribed = <any>"unsubscribed",
    UnsubscribedPerList = <any>"unsubscribedPerList",
  }
  export enum ActionForEmailCampaignsEnum {
    Openers = <any>"openers",
    NonOpeners = <any>"nonOpeners",
    Clickers = <any>"clickers",
    NonClickers = <any>"nonClickers",
    Unsubscribed = <any>"unsubscribed",
    HardBounces = <any>"hardBounces",
    SoftBounces = <any>"softBounces",
  }
  export enum ActionForSmsCampaignsEnum {
    HardBounces = <any>"hardBounces",
    SoftBounces = <any>"softBounces",
    Unsubscribed = <any>"unsubscribed",
  }
}
export class RequestContactImport {
  /**
   * Mandatory if fileBody or jsonBody is not defined. URL of the file to be imported (no local file). Possible file formats: .txt, .csv, .json
   */
  "fileUrl"?: string;
  /**
   * Mandatory if fileUrl and jsonBody is not defined. CSV content to be imported. Use semicolon to separate multiple attributes. Maximum allowed file body size is 10MB . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of file body size while parsing. Please use fileUrl instead to import bigger files.
   */
  "fileBody"?: string;
  /**
   * **Mandatory if fileUrl and fileBody is not defined.** JSON content to be imported. **Maximum allowed json body size is 10MB** . However we recommend a safe limit of around 8 MB to avoid the issues caused due to increase of json body size while parsing. Please use fileUrl instead to import bigger files.
   */
  "jsonBody"?: Array<{ [key: string]: any }>;
  /**
   * Mandatory if newList is not defined. Ids of the lists in which the contacts shall be imported. For example, [2, 4, 7].
   */
  "listIds"?: Array<number>;
  /**
   * URL that will be called once the import process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479
   */
  "notifyUrl"?: string;
  "newList"?: RequestContactImportNewList;
  /**
   * To blacklist all the contacts for email
   */
  "emailBlacklist"?: boolean;
  /**
   * To blacklist all the contacts for sms
   */
  "smsBlacklist"?: boolean;
  /**
   * To facilitate the choice to update the existing contacts
   */
  "updateExistingContacts"?: boolean;
  /**
   * To facilitate the choice to erase any attribute of the existing contacts with empty value. emptyContactsAttributes = true means the empty fields in your import will erase any attribute that currently contain data in Brevo, & emptyContactsAttributes = false means the empty fields will not affect your existing data ( only available if `updateExistingContacts` set to true )
   */
  "emptyContactsAttributes"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "fileUrl",
      baseName: "fileUrl",
      type: "string",
    },
    {
      name: "fileBody",
      baseName: "fileBody",
      type: "string",
    },
    {
      name: "jsonBody",
      baseName: "jsonBody",
      type: "Array<{ [key: string]: any; }>",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "notifyUrl",
      baseName: "notifyUrl",
      type: "string",
    },
    {
      name: "newList",
      baseName: "newList",
      type: "RequestContactImportNewList",
    },
    {
      name: "emailBlacklist",
      baseName: "emailBlacklist",
      type: "boolean",
    },
    {
      name: "smsBlacklist",
      baseName: "smsBlacklist",
      type: "boolean",
    },
    {
      name: "updateExistingContacts",
      baseName: "updateExistingContacts",
      type: "boolean",
    },
    {
      name: "emptyContactsAttributes",
      baseName: "emptyContactsAttributes",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return RequestContactImport.attributeTypeMap;
  }
}

/**
 * To create a new list and import the contacts into it, pass the listName and an optional folderId.
 */
export class RequestContactImportNewList {
  /**
   * List with listName will be created first and users will be imported in it (Mandatory if listIds is empty).
   */
  "listName"?: string;
  /**
   * Id of the folder where this new list shall be created (Mandatory if listName is not empty).
   */
  "folderId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "listName",
      baseName: "listName",
      type: "string",
    },
    {
      name: "folderId",
      baseName: "folderId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return RequestContactImportNewList.attributeTypeMap;
  }
}

export class RequestSmsRecipientExport {
  /**
   * URL that will be called once the export process is finished. For reference, https://help.brevo.com/hc/en-us/articles/360007666479
   */
  "notifyURL"?: string;
  /**
   * Filter the recipients based on how they interacted with the campaign
   */
  "recipientsType": RequestSmsRecipientExport.RecipientsTypeEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "notifyURL",
      baseName: "notifyURL",
      type: "string",
    },
    {
      name: "recipientsType",
      baseName: "recipientsType",
      type: "RequestSmsRecipientExport.RecipientsTypeEnum",
    },
  ];

  static getAttributeTypeMap() {
    return RequestSmsRecipientExport.attributeTypeMap;
  }
}

export namespace RequestSmsRecipientExport {
  export enum RecipientsTypeEnum {
    All = <any>"all",
    Delivered = <any>"delivered",
    Answered = <any>"answered",
    SoftBounces = <any>"softBounces",
    HardBounces = <any>"hardBounces",
    Unsubscribed = <any>"unsubscribed",
  }
}
export class ScheduleSmtpEmail {
  /**
   * Message ID of the transactional email scheduled
   */
  "messageId"?: string;
  "messageIds"?: Array<string>;
  /**
   * Batch ID of the batch transactional email scheduled
   */
  "batchId"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "messageId",
      baseName: "messageId",
      type: "string",
    },
    {
      name: "messageIds",
      baseName: "messageIds",
      type: "Array<string>",
    },
    {
      name: "batchId",
      baseName: "batchId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return ScheduleSmtpEmail.attributeTypeMap;
  }
}

export class SendReport {
  /**
   * Language of email content for campaign report sending.
   */
  "language"?: SendReport.LanguageEnum;
  "email": SendReportEmail;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "language",
      baseName: "language",
      type: "SendReport.LanguageEnum",
    },
    {
      name: "email",
      baseName: "email",
      type: "SendReportEmail",
    },
  ];

  static getAttributeTypeMap() {
    return SendReport.attributeTypeMap;
  }
}

export namespace SendReport {
  export enum LanguageEnum {
    Fr = <any>"fr",
    Es = <any>"es",
    Pt = <any>"pt",
    It = <any>"it",
    De = <any>"de",
    En = <any>"en",
  }
}
/**
 * Custom attributes for the report email.
 */
export class SendReportEmail {
  /**
   * Email addresses of the recipients
   */
  "to": Array<string>;
  /**
   * Custom text message to be presented in the report email.
   */
  "body": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "to",
      baseName: "to",
      type: "Array<string>",
    },
    {
      name: "body",
      baseName: "body",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendReportEmail.attributeTypeMap;
  }
}

export class SendSms {
  "reference": string;
  "messageId": number;
  /**
   * Count of SMS's to send multiple text messages
   */
  "smsCount"?: number;
  /**
   * SMS credits used per text message
   */
  "usedCredits"?: number;
  /**
   * Remaining SMS credits of the user
   */
  "remainingCredits"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "reference",
      baseName: "reference",
      type: "string",
    },
    {
      name: "messageId",
      baseName: "messageId",
      type: "number",
    },
    {
      name: "smsCount",
      baseName: "smsCount",
      type: "number",
    },
    {
      name: "usedCredits",
      baseName: "usedCredits",
      type: "number",
    },
    {
      name: "remainingCredits",
      baseName: "remainingCredits",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SendSms.attributeTypeMap;
  }
}

export class SendSmtpEmail {
  "sender"?: SendSmtpEmailSender;
  /**
   * Mandatory if messageVersions are not passed, ignored if messageVersions are passed. List of email addresses and names (optional) of the recipients. For example, [{\"name\":\"Jimmy\", \"email\":\"jimmy98@example.com\"}, {\"name\":\"Joe\", \"email\":\"joe@example.com\"}]
   */
  "to"?: Array<SendSmtpEmailTo>;
  /**
   * List of email addresses and names (optional) of the recipients in bcc
   */
  "bcc"?: Array<SendSmtpEmailBcc>;
  /**
   * List of email addresses and names (optional) of the recipients in cc
   */
  "cc"?: Array<SendSmtpEmailCc>;
  /**
   * HTML body of the message ( Mandatory if 'templateId' is not passed, ignored if 'templateId' is passed )
   */
  "htmlContent"?: string;
  /**
   * Plain Text body of the message ( Ignored if 'templateId' is passed )
   */
  "textContent"?: string;
  /**
   * Subject of the message. Mandatory if 'templateId' is not passed
   */
  "subject"?: string;
  "replyTo"?: SendSmtpEmailReplyTo;
  /**
   * Pass the absolute URL (no local file) or the base64 content of the attachment along with the attachment name (Mandatory if attachment content is passed). For example, `[{\"url\":\"https://attachment.domain.com/myAttachmentFromUrl.jpg\", \"name\":\"myAttachmentFromUrl.jpg\"}, {\"content\":\"base64 example content\", \"name\":\"myAttachmentFromBase64.jpg\"}]`. Allowed extensions for attachment file: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub, eps, odt, mp3, m4a, m4v, wma, ogg, flac, wav, aif, aifc, aiff, mp4, mov, avi, mkv, mpeg, mpg, wmv, pkpass and xlsm ( If 'templateId' is passed and is in New Template Language format then both attachment url and content are accepted. If template is in Old template Language format, then 'attachment' is ignored )
   */
  "attachment"?: Array<SendSmtpEmailAttachment>;
  /**
   * Pass the set of custom headers (not the standard headers) that shall be sent along the mail headers in the original email. 'sender.ip' header can be set (only for dedicated ip users) to mention the IP to be used for sending transactional emails. Headers are allowed in `This-Case-Only` (i.e. words separated by hyphen with first letter of each word in capital letter), they will be converted to such case styling if not in this format in the request payload. For example, `{\"sender.ip\":\"1.2.3.4\", \"X-Mailin-custom\":\"some_custom_header\", \"idempotencyKey\":\"abc-123\"}`.
   */
  "headers"?: any;
  /**
   * Id of the template.
   */
  "templateId"?: number;
  /**
   * Pass the set of attributes to customize the template. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. It's considered only if template is in New Template Language format.
   */
  "params"?: any;
  /**
   * You can customize and send out multiple versions of a mail. templateId can be customized only if global parameter contains templateId. htmlContent and textContent can be customized only if any of the two, htmlContent or textContent, is present in global parameters. Some global parameters such as **to(mandatory), bcc, cc, replyTo, subject** can also be customized specific to each version. Total number of recipients in one API request must not exceed 2000. However, you can still pass upto 99 recipients maximum in one message version. The size of individual params in all the messageVersions shall not exceed 100 KB limit and that of cumulative params shall not exceed 1000 KB. You can follow this **step-by-step guide** on how to use **messageVersions** to batch send emails - https://developers.brevo.com/docs/batch-send-transactional-emails
   */
  "messageVersions"?: Array<SendSmtpEmailMessageVersions>;
  /**
   * Tag your emails to find them more easily
   */
  "tags"?: Array<string>;
  /**
   * UTC date-time on which the email has to schedule (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for scheduling. There can be an expected delay of +5 minutes in scheduled email delivery. **Please note this feature is currently a public beta**.
   */
  "scheduledAt"?: String;
  /**
   * Valid UUIDv4 batch id to identify the scheduled batches transactional email. If not passed we will create a valid UUIDv4 batch id at our end.
   */
  "batchId"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sender",
      baseName: "sender",
      type: "SendSmtpEmailSender",
    },
    {
      name: "to",
      baseName: "to",
      type: "Array<SendSmtpEmailTo>",
    },
    {
      name: "bcc",
      baseName: "bcc",
      type: "Array<SendSmtpEmailBcc>",
    },
    {
      name: "cc",
      baseName: "cc",
      type: "Array<SendSmtpEmailCc>",
    },
    {
      name: "htmlContent",
      baseName: "htmlContent",
      type: "string",
    },
    {
      name: "textContent",
      baseName: "textContent",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "SendSmtpEmailReplyTo",
    },
    {
      name: "attachment",
      baseName: "attachment",
      type: "Array<SendSmtpEmailAttachment>",
    },
    {
      name: "headers",
      baseName: "headers",
      type: "any",
    },
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
    {
      name: "params",
      baseName: "params",
      type: "any",
    },
    {
      name: "messageVersions",
      baseName: "messageVersions",
      type: "Array<SendSmtpEmailMessageVersions>",
    },
    {
      name: "tags",
      baseName: "tags",
      type: "Array<string>",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "Date",
    },
    {
      name: "batchId",
      baseName: "batchId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmail.attributeTypeMap;
  }
}

export class SendSmtpEmailAttachment {
  /**
   * Absolute url of the attachment (no local file).
   */
  "url"?: string;
  /**
   * Base64 encoded chunk data of the attachment generated on the fly
   */
  "content"?: string;
  /**
   * Required if content is passed. Name of the attachment
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "content",
      baseName: "content",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailAttachment.attributeTypeMap;
  }
}

export class SendSmtpEmailBcc {
  /**
   * Email address of the recipient in bcc
   */
  "email": string;
  /**
   * Name of the recipient in bcc. Maximum allowed characters are 70.
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailBcc.attributeTypeMap;
  }
}

export class SendSmtpEmailCc {
  /**
   * Email address of the recipient in cc
   */
  "email": string;
  /**
   * Name of the recipient in cc. Maximum allowed characters are 70.
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailCc.attributeTypeMap;
  }
}

export class SendSmtpEmailMessageVersions {
  /**
   * List of email addresses and names (_optional_) of the recipients. For example, [{\"name\":\"Jimmy\", \"email\":\"jimmy98@example.com\"}, {\"name\":\"Joe\", \"email\":\"joe@example.com\"}]
   */
  "to": Array<SendSmtpEmailTo1>;
  /**
   * Pass the set of attributes to customize the template. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. It's considered only if template is in New Template Language format.
   */
  "params"?: { [key: string]: any };
  /**
   * List of email addresses and names (optional) of the recipients in bcc
   */
  "bcc"?: Array<SendSmtpEmailBcc>;
  /**
   * List of email addresses and names (optional) of the recipients in cc
   */
  "cc"?: Array<SendSmtpEmailCc>;
  "replyTo"?: SendSmtpEmailReplyTo1;
  /**
   * Custom subject specific to message version
   */
  "subject"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "to",
      baseName: "to",
      type: "Array<SendSmtpEmailTo1>",
    },
    {
      name: "params",
      baseName: "params",
      type: "{ [key: string]: any; }",
    },
    {
      name: "bcc",
      baseName: "bcc",
      type: "Array<SendSmtpEmailBcc>",
    },
    {
      name: "cc",
      baseName: "cc",
      type: "Array<SendSmtpEmailCc>",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "SendSmtpEmailReplyTo1",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailMessageVersions.attributeTypeMap;
  }
}

/**
 * Email (required), along with name (optional), on which transactional mail recipients will be able to reply back. For example, {\"email\":\"ann6533@example.com\", \"name\":\"Ann\"}.
 */
export class SendSmtpEmailReplyTo {
  /**
   * Email address in reply to
   */
  "email": string;
  /**
   * Name in reply to. Maximum allowed characters are 70.
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailReplyTo.attributeTypeMap;
  }
}

/**
 * Email (required), along with name (optional), on which transactional mail recipients will be able to reply back. For example, {\"email\":\"ann6533@example.com\", \"name\":\"Ann\"}
 */
export class SendSmtpEmailReplyTo1 {
  /**
   * Email address in reply to
   */
  "email": string;
  /**
   * Name in reply to. Maximum allowed characters are 70.
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailReplyTo1.attributeTypeMap;
  }
}

/**
 * Mandatory if `templateId` is not passed. Pass `name` (optional) and `email` OR `id` of sender from which emails will be sent. `name` will be ignored if passed along with sender `id`. For example, {\"name\":\"Mary from MyShop\", \"email\":\"no-reply@myshop.com\"} or {\"id\":2}
 */
export class SendSmtpEmailSender {
  /**
   * Name of the sender from which the emails will be sent. Maximum allowed characters are 70. Applicable only when email is passed.
   */
  "name"?: string;
  /**
   * Email of the sender from which the emails will be sent. Mandatory if sender id is not passed.
   */
  "email"?: string;
  /**
   * Id of the sender from which the emails will be sent. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email). Mandatory if email is not passed.
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailSender.attributeTypeMap;
  }
}

export class SendSmtpEmailTo {
  /**
   * Email address of the recipient
   */
  "email": string;
  /**
   * Name of the recipient. Maximum allowed characters are 70.
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailTo.attributeTypeMap;
  }
}

export class SendSmtpEmailTo1 {
  /**
   * Email address of the recipient
   */
  "email": string;
  /**
   * Name of the recipient. **Maximum allowed characters are 70**.
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendSmtpEmailTo1.attributeTypeMap;
  }
}

export class SendTestEmail {
  /**
   * List of the email addresses of the recipients whom you wish to send the test mail. If left empty, the test mail will be sent to your entire test list. You can not send more than 50 test emails per day.
   */
  "emailTo"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "emailTo",
      baseName: "emailTo",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return SendTestEmail.attributeTypeMap;
  }
}

export class SendTestSms {
  /**
   * Mobile number of the recipient with the country code. This number must belong to one of your contacts in Brevo account and must not be blacklisted
   */
  "phoneNumber"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "phoneNumber",
      baseName: "phoneNumber",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendTestSms.attributeTypeMap;
  }
}

export class SendTransacSms {
  /**
   * Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**
   */
  "sender": string;
  /**
   * Mobile number to send SMS with the country code
   */
  "recipient": string;
  /**
   * Content of the message. If more than 160 characters long, will be sent as multiple text messages
   */
  "content": string;
  /**
   * Type of the SMS. Marketing SMS messages are those sent typically with marketing content. Transactional SMS messages are sent to individuals and are triggered in response to some action, such as a sign-up, purchase, etc.
   */
  "type"?: SendTransacSms.TypeEnum;
  /**
   * Tag of the message
   */
  "tag"?: string;
  /**
   * Webhook to call for each event triggered by the message (delivered etc.)
   */
  "webUrl"?: string;
  /**
   * Format of the message. It indicates whether the content should be treated as unicode or not.
   */
  "unicodeEnabled"?: boolean;
  /**
   * A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**
   */
  "organisationPrefix"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sender",
      baseName: "sender",
      type: "string",
    },
    {
      name: "recipient",
      baseName: "recipient",
      type: "string",
    },
    {
      name: "content",
      baseName: "content",
      type: "string",
    },
    {
      name: "type",
      baseName: "type",
      type: "SendTransacSms.TypeEnum",
    },
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "webUrl",
      baseName: "webUrl",
      type: "string",
    },
    {
      name: "unicodeEnabled",
      baseName: "unicodeEnabled",
      type: "boolean",
    },
    {
      name: "organisationPrefix",
      baseName: "organisationPrefix",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SendTransacSms.attributeTypeMap;
  }
}

export namespace SendTransacSms {
  export enum TypeEnum {
    Transactional = <any>"transactional",
    Marketing = <any>"marketing",
  }
}
export class SendWhatsappMessage {
  /**
   * ID of the template to send
   */
  "templateId"?: number;
  /**
   * Text to be sent as message body (will be overridden if templateId is passed in the same request)
   */
  "text"?: string;
  /**
   * WhatsApp Number with country code. Example, 85264318721
   */
  "senderNumber": string;
  /**
   * List of phone numbers of the contacts
   */
  "contactNumbers": Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "templateId",
      baseName: "templateId",
      type: "number",
    },
    {
      name: "text",
      baseName: "text",
      type: "string",
    },
    {
      name: "senderNumber",
      baseName: "senderNumber",
      type: "string",
    },
    {
      name: "contactNumbers",
      baseName: "contactNumbers",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return SendWhatsappMessage.attributeTypeMap;
  }
}

export class SsoTokenRequest {
  /**
   * Id of the sub-account organization
   */
  "id": number;
  /**
   * User email of sub-account organization
   */
  "email"?: string;
  /**
   * Set target after login success * automation - Redirect to Automation after login * email_campaign - Redirect to Email Campaign after login * contacts - Redirect to Contacts after login * landing_pages - Redirect to Landing Pages after login * email_transactional - Redirect to Email Transactional after login * senders - Redirect to Contacts after login * sms_campaign - Redirect to Sms Campaign after login * sms_transactional - Redirect to Sms Transactional after login
   */
  "target"?: SsoTokenRequest.TargetEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "target",
      baseName: "target",
      type: "SsoTokenRequest.TargetEnum",
    },
  ];

  static getAttributeTypeMap() {
    return SsoTokenRequest.attributeTypeMap;
  }
}

export namespace SsoTokenRequest {
  export enum TargetEnum {
    Automation = <any>"automation",
    EmailCampaign = <any>"email_campaign",
    Contacts = <any>"contacts",
    LandingPages = <any>"landing_pages",
    EmailTransactional = <any>"email_transactional",
    Senders = <any>"senders",
    SmsCampaign = <any>"sms_campaign",
    SmsTransactional = <any>"sms_transactional",
  }
}
export class SubAccountDetailsResponse {
  /**
   * Name of the sub-account user
   */
  "name"?: string;
  /**
   * Email id of the sub-account organization
   */
  "email"?: string;
  /**
   * Sub-account company name
   */
  "companyName"?: string;
  "planInfo"?: SubAccountDetailsResponsePlanInfo;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
    {
      name: "planInfo",
      baseName: "planInfo",
      type: "SubAccountDetailsResponsePlanInfo",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponse.attributeTypeMap;
  }
}

/**
 * Sub-account plan details
 */
export class SubAccountDetailsResponsePlanInfo {
  "credits"?: SubAccountDetailsResponsePlanInfoCredits;
  "features"?: SubAccountDetailsResponsePlanInfoFeatures;
  /**
   * type of the plan
   */
  "planType"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "credits",
      baseName: "credits",
      type: "SubAccountDetailsResponsePlanInfoCredits",
    },
    {
      name: "features",
      baseName: "features",
      type: "SubAccountDetailsResponsePlanInfoFeatures",
    },
    {
      name: "planType",
      baseName: "planType",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponsePlanInfo.attributeTypeMap;
  }
}

/**
 * Credits quota and remaining credits on the sub-account
 */
export class SubAccountDetailsResponsePlanInfoCredits {
  /**
   * SMS credits remaining on the sub-account
   */
  "sms"?: number;
  "emails"?: SubAccountDetailsResponsePlanInfoCreditsEmails;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sms",
      baseName: "sms",
      type: "number",
    },
    {
      name: "emails",
      baseName: "emails",
      type: "SubAccountDetailsResponsePlanInfoCreditsEmails",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponsePlanInfoCredits.attributeTypeMap;
  }
}

/**
 * Email credits remaining on the sub-account
 */
export class SubAccountDetailsResponsePlanInfoCreditsEmails {
  /**
   * Quantity of email messaging limits provided
   */
  "quantity"?: number;
  /**
   * Available email messaging limits for use
   */
  "remaining"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "quantity",
      baseName: "quantity",
      type: "number",
    },
    {
      name: "remaining",
      baseName: "remaining",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponsePlanInfoCreditsEmails.attributeTypeMap;
  }
}

/**
 * Features available on the sub-account
 */
export class SubAccountDetailsResponsePlanInfoFeatures {
  "inbox"?: SubAccountDetailsResponsePlanInfoFeaturesInbox;
  "landingPage"?: SubAccountDetailsResponsePlanInfoFeaturesLandingPage;
  "users"?: SubAccountDetailsResponsePlanInfoFeaturesUsers;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "inbox",
      baseName: "inbox",
      type: "SubAccountDetailsResponsePlanInfoFeaturesInbox",
    },
    {
      name: "landingPage",
      baseName: "landingPage",
      type: "SubAccountDetailsResponsePlanInfoFeaturesLandingPage",
    },
    {
      name: "users",
      baseName: "users",
      type: "SubAccountDetailsResponsePlanInfoFeaturesUsers",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponsePlanInfoFeatures.attributeTypeMap;
  }
}

/**
 * Inbox details
 */
export class SubAccountDetailsResponsePlanInfoFeaturesInbox {
  /**
   * Quantity of inbox provided
   */
  "quantity"?: number;
  /**
   * Available inboxes for use
   */
  "remaining"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "quantity",
      baseName: "quantity",
      type: "number",
    },
    {
      name: "remaining",
      baseName: "remaining",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponsePlanInfoFeaturesInbox.attributeTypeMap;
  }
}

/**
 * Landing page details
 */
export class SubAccountDetailsResponsePlanInfoFeaturesLandingPage {
  /**
   * Quantity of landing pages provided
   */
  "quantity"?: number;
  /**
   * Available landing pages for use
   */
  "remaining"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "quantity",
      baseName: "quantity",
      type: "number",
    },
    {
      name: "remaining",
      baseName: "remaining",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponsePlanInfoFeaturesLandingPage.attributeTypeMap;
  }
}

/**
 * Multi-account details
 */
export class SubAccountDetailsResponsePlanInfoFeaturesUsers {
  /**
   * Quantity of multi-account's provided
   */
  "quantity"?: number;
  /**
   * Available multi-accounts for use
   */
  "remaining"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "quantity",
      baseName: "quantity",
      type: "number",
    },
    {
      name: "remaining",
      baseName: "remaining",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountDetailsResponsePlanInfoFeaturesUsers.attributeTypeMap;
  }
}

/**
 * Details of the plan to be changed
 */
export class SubAccountUpdatePlanRequest {
  "credits"?: SubAccountUpdatePlanRequestCredits;
  "features"?: SubAccountUpdatePlanRequestFeatures;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "credits",
      baseName: "credits",
      type: "SubAccountUpdatePlanRequestCredits",
    },
    {
      name: "features",
      baseName: "features",
      type: "SubAccountUpdatePlanRequestFeatures",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountUpdatePlanRequest.attributeTypeMap;
  }
}

/**
 * Credit details to update
 */
export class SubAccountUpdatePlanRequestCredits {
  /**
   * Number of email credits
   */
  "email"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountUpdatePlanRequestCredits.attributeTypeMap;
  }
}

/**
 * Features details to update
 */
export class SubAccountUpdatePlanRequestFeatures {
  /**
   * Number of multi-users
   */
  "users"?: number;
  /**
   * Number of landing pages
   */
  "landingPage"?: number;
  /**
   * Number of inboxes
   */
  "inbox"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "users",
      baseName: "users",
      type: "number",
    },
    {
      name: "landingPage",
      baseName: "landingPage",
      type: "number",
    },
    {
      name: "inbox",
      baseName: "inbox",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountUpdatePlanRequestFeatures.attributeTypeMap;
  }
}

export class SubAccountsResponse {
  /**
   * Total number of subaccounts
   */
  "count"?: number;
  "subAccounts"?: Array<SubAccountsResponseSubAccounts>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "count",
      baseName: "count",
      type: "number",
    },
    {
      name: "subAccounts",
      baseName: "subAccounts",
      type: "Array<SubAccountsResponseSubAccounts>",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountsResponse.attributeTypeMap;
  }
}

export class SubAccountsResponseSubAccounts {
  /**
   * id of the sub-account
   */
  "id": number;
  /**
   * Name of the sub-account company
   */
  "companyName": string;
  /**
   * Whether the sub-account is active or not
   */
  "active": boolean;
  /**
   * Timestamp when the sub-account was created
   */
  "createdAt": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
    {
      name: "active",
      baseName: "active",
      type: "boolean",
    },
    {
      name: "createdAt",
      baseName: "createdAt",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return SubAccountsResponseSubAccounts.attributeTypeMap;
  }
}

/**
 * Task Details
 */
export class Task {
  /**
   * Unique task id
   */
  "id"?: string;
  /**
   * Id for type of task e.g Call / Email / Meeting etc.
   */
  "taskTypeId": string;
  /**
   * Name of task
   */
  "name": string;
  /**
   * Contact ids for contacts linked to this task
   */
  "contactsIds"?: Array<number>;
  /**
   * Deal ids for deals a task is linked to
   */
  "dealsIds"?: Array<string>;
  /**
   * Companies ids for companies a task is linked to
   */
  "companiesIds"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "taskTypeId",
      baseName: "taskTypeId",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "contactsIds",
      baseName: "contactsIds",
      type: "Array<number>",
    },
    {
      name: "dealsIds",
      baseName: "dealsIds",
      type: "Array<string>",
    },
    {
      name: "companiesIds",
      baseName: "companiesIds",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return Task.attributeTypeMap;
  }
}

/**
 * List of tasks
 */
export class TaskList {
  /**
   * List of tasks
   */
  "items"?: Array<Task>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "items",
      baseName: "items",
      type: "Array<Task>",
    },
  ];

  static getAttributeTypeMap() {
    return TaskList.attributeTypeMap;
  }
}

/**
 * Task reminder date/time for a task
 */
export class TaskReminder {
  /**
   * Value of time unit before reminder is to be sent
   */
  "value": number;
  /**
   * Unit of time before reminder is to be sent
   */
  "unit": TaskReminder.UnitEnum;
  /**
   * Type of task reminder e.g email, push
   */
  "types": Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "value",
      baseName: "value",
      type: "number",
    },
    {
      name: "unit",
      baseName: "unit",
      type: "TaskReminder.UnitEnum",
    },
    {
      name: "types",
      baseName: "types",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return TaskReminder.attributeTypeMap;
  }
}

export namespace TaskReminder {
  export enum UnitEnum {
    Minutes = <any>"minutes",
    Hours = <any>"hours",
    Weeks = <any>"weeks",
    Days = <any>"days",
  }
}
/**
 * Task types details
 */
export class TaskTypes {
  /**
   * Id of task type
   */
  "id"?: string;
  /**
   * Title of task type
   */
  "title"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "id",
      baseName: "id",
      type: "string",
    },
    {
      name: "title",
      baseName: "title",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return TaskTypes.attributeTypeMap;
  }
}

export class UpdateAttribute {
  /**
   * Value of the attribute to update. Use only if the attribute's category is 'calculated' or 'global'
   */
  "value"?: string;
  /**
   * List of the values and labels that the attribute can take. Use only if the attribute's category is \"category\". For example, [{\"value\":1, \"label\":\"male\"}, {\"value\":2, \"label\":\"female\"}]
   */
  "enumeration"?: Array<UpdateAttributeEnumeration>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "value",
      baseName: "value",
      type: "string",
    },
    {
      name: "enumeration",
      baseName: "enumeration",
      type: "Array<UpdateAttributeEnumeration>",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateAttribute.attributeTypeMap;
  }
}

export class UpdateAttributeEnumeration {
  /**
   * Id of the value
   */
  "value": number;
  /**
   * Label of the value
   */
  "label": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "value",
      baseName: "value",
      type: "number",
    },
    {
      name: "label",
      baseName: "label",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateAttributeEnumeration.attributeTypeMap;
  }
}

export class UpdateBatchContacts {
  /**
   * List of contacts to be updated
   */
  "contacts"?: Array<UpdateBatchContactsContacts>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "contacts",
      baseName: "contacts",
      type: "Array<UpdateBatchContactsContacts>",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateBatchContacts.attributeTypeMap;
  }
}

export class UpdateBatchContactsContacts {
  /**
   * Email address of the user to be updated (For each operation only pass one of the supported contact identifiers. Email, id or sms)
   */
  "email"?: string;
  /**
   * id of the user to be updated (For each operation only pass one of the supported contact identifiers. Email, id or sms)
   */
  "id"?: number;
  /**
   * SMS of the user to be updated (For each operation only pass one of the supported contact identifiers. Email, id or sms)
   */
  "sms"?: string;
  /**
   * Pass your own Id to update ext_id of a contact.
   */
  "extId"?: string;
  /**
   * Pass the set of attributes to be updated. **These attributes must be present in your account**. To update existing email address of a contact with the new one please pass EMAIL in attribtes. For example, **{ \"EMAIL\":\"newemail@domain.com\", \"FNAME\":\"Ellie\", \"LNAME\":\"Roger\"}**. Keep in mind transactional attributes can be updated the same way as normal attributes. Mobile Number in **SMS** field should be passed with proper country code. For example: **{\"SMS\":\"+91xxxxxxxxxx\"} or {\"SMS\":\"0091xxxxxxxxxx\"}**
   */
  "attributes"?: { [key: string]: any };
  /**
   * Set/unset this field to blacklist/allow the contact for emails (emailBlacklisted = true)
   */
  "emailBlacklisted"?: boolean;
  /**
   * Set/unset this field to blacklist/allow the contact for SMS (smsBlacklisted = true)
   */
  "smsBlacklisted"?: boolean;
  /**
   * Ids of the lists to add the contact to
   */
  "listIds"?: Array<number>;
  /**
   * Ids of the lists to remove the contact from
   */
  "unlinkListIds"?: Array<number>;
  /**
   * transactional email forbidden sender for contact. Use only for email Contact
   */
  "smtpBlacklistSender"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
    {
      name: "sms",
      baseName: "sms",
      type: "string",
    },
    {
      name: "extId",
      baseName: "ext_id",
      type: "string",
    },
    {
      name: "attributes",
      baseName: "attributes",
      type: "{ [key: string]: any; }",
    },
    {
      name: "emailBlacklisted",
      baseName: "emailBlacklisted",
      type: "boolean",
    },
    {
      name: "smsBlacklisted",
      baseName: "smsBlacklisted",
      type: "boolean",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "unlinkListIds",
      baseName: "unlinkListIds",
      type: "Array<number>",
    },
    {
      name: "smtpBlacklistSender",
      baseName: "smtpBlacklistSender",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateBatchContactsContacts.attributeTypeMap;
  }
}

export class UpdateBatchContactsModel {
  "successIds"?: Array<number>;
  "failureIds"?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "successIds",
      baseName: "successIds",
      type: "Array<number>",
    },
    {
      name: "failureIds",
      baseName: "failureIds",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateBatchContactsModel.attributeTypeMap;
  }
}

/**
 * Status of the campaign
 */
export class UpdateCampaignStatus {
  /**
   * Note:- replicateTemplate status will be available only for template type campaigns.
   */
  "status"?: UpdateCampaignStatus.StatusEnum;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "status",
      baseName: "status",
      type: "UpdateCampaignStatus.StatusEnum",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateCampaignStatus.attributeTypeMap;
  }
}

export namespace UpdateCampaignStatus {
  export enum StatusEnum {
    Suspended = <any>"suspended",
    Archive = <any>"archive",
    Darchive = <any>"darchive",
    Sent = <any>"sent",
    Queued = <any>"queued",
    Replicate = <any>"replicate",
    ReplicateTemplate = <any>"replicateTemplate",
    Draft = <any>"draft",
  }
}
export class UpdateChild {
  /**
   * New Email address to update the child account
   */
  "email"?: string;
  /**
   * New First name to use to update the child account
   */
  "firstName"?: string;
  /**
   * New Last name to use to update the child account
   */
  "lastName"?: string;
  /**
   * New Company name to use to update the child account
   */
  "companyName"?: string;
  /**
   * New password for the child account to login
   */
  "password"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "firstName",
      baseName: "firstName",
      type: "string",
    },
    {
      name: "lastName",
      baseName: "lastName",
      type: "string",
    },
    {
      name: "companyName",
      baseName: "companyName",
      type: "string",
    },
    {
      name: "password",
      baseName: "password",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateChild.attributeTypeMap;
  }
}

export class UpdateChildAccountStatus {
  /**
   * Status of Transactional Email Platform activation for your account (true=enabled, false=disabled)
   */
  "transactionalEmail"?: boolean;
  /**
   * Status of Transactional SMS Platform activation for your account (true=enabled, false=disabled)
   */
  "transactionalSms"?: boolean;
  /**
   * Status of Marketing Automation Platform activation for your account (true=enabled, false=disabled)
   */
  "marketingAutomation"?: boolean;
  /**
   * Status of SMS Campaign Platform activation for your account (true=enabled, false=disabled)
   */
  "smsCampaign"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "transactionalEmail",
      baseName: "transactionalEmail",
      type: "boolean",
    },
    {
      name: "transactionalSms",
      baseName: "transactionalSms",
      type: "boolean",
    },
    {
      name: "marketingAutomation",
      baseName: "marketingAutomation",
      type: "boolean",
    },
    {
      name: "smsCampaign",
      baseName: "smsCampaign",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateChildAccountStatus.attributeTypeMap;
  }
}

export class UpdateChildDomain {
  /**
   * Value for the sender domain that will replace the existing domain
   */
  "domain"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateChildDomain.attributeTypeMap;
  }
}

export class UpdateContact {
  /**
   * Pass the set of attributes to be updated. These attributes must be present in your account. To update existing email address of a contact with the new one please pass EMAIL in attributes. For example, `{ \"EMAIL\":\"newemail@domain.com\", \"FNAME\":\"Ellie\", \"LNAME\":\"Roger\"}`. The attribute's parameter should be passed in capital letter while updating a contact. Keep in mind transactional attributes can be updated the same way as normal attributes. Mobile Number in \"SMS\" field should be passed with proper country code. For example {\"SMS\":\"+91xxxxxxxxxx\"} or {\"SMS\":\"0091xxxxxxxxxx\"}
   */
  "attributes"?: any;
  /**
   * Pass your own Id to update ext_id of a contact.
   */
  "extId"?: string;
  /**
   * Set/unset this field to blacklist/allow the contact for emails (emailBlacklisted = true)
   */
  "emailBlacklisted"?: boolean;
  /**
   * Set/unset this field to blacklist/allow the contact for SMS (smsBlacklisted = true)
   */
  "smsBlacklisted"?: boolean;
  /**
   * Ids of the lists to add the contact to
   */
  "listIds"?: Array<number>;
  /**
   * Ids of the lists to remove the contact from
   */
  "unlinkListIds"?: Array<number>;
  /**
   * transactional email forbidden sender for contact. Use only for email Contact
   */
  "smtpBlacklistSender"?: Array<string>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "attributes",
      baseName: "attributes",
      type: "any",
    },
    {
      name: "extId",
      baseName: "ext_id",
      type: "string",
    },
    {
      name: "emailBlacklisted",
      baseName: "emailBlacklisted",
      type: "boolean",
    },
    {
      name: "smsBlacklisted",
      baseName: "smsBlacklisted",
      type: "boolean",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "unlinkListIds",
      baseName: "unlinkListIds",
      type: "Array<number>",
    },
    {
      name: "smtpBlacklistSender",
      baseName: "smtpBlacklistSender",
      type: "Array<string>",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateContact.attributeTypeMap;
  }
}

export class UpdateEmailCampaign {
  /**
   * Tag of the campaign
   */
  "tag"?: string;
  "sender"?: UpdateEmailCampaignSender;
  /**
   * Name of the campaign
   */
  "name"?: string;
  /**
   * Body of the message (HTML version). If the campaign is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that campaign. REQUIRED if htmlUrl is empty
   */
  "htmlContent"?: string;
  /**
   * Url which contents the body of the email message. REQUIRED if htmlContent is empty
   */
  "htmlUrl"?: string;
  /**
   * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result. If sendAtBestTime is set to true, your campaign will be sent according to the date passed (ignoring the time part).
   */
  "scheduledAt"?: string;
  /**
   * Subject of the campaign
   */
  "subject"?: string;
  /**
   * Email on which campaign recipients will be able to reply to
   */
  "replyTo"?: string;
  /**
   * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your Brevo account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
   */
  "toField"?: string;
  "recipients"?: UpdateEmailCampaignRecipients;
  /**
   * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
   */
  "attachmentUrl"?: string;
  /**
   * Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email. You cannot send a campaign of more than 4MB with images embedded in the email. Campaigns with the images embedded in the email must be sent to less than 5000 contacts.
   */
  "inlineImageActivation"?: boolean;
  /**
   * Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
   */
  "mirrorActive"?: boolean;
  /**
   * FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
   */
  "recurring"?: boolean;
  /**
   * Footer of the email campaign
   */
  "footer"?: string;
  /**
   * Header of the email campaign
   */
  "header"?: string;
  /**
   * Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
   */
  "utmCampaign"?: string;
  /**
   * Pass the set of attributes to customize the type 'classic' campaign. For example, {\"FNAME\":\"Joe\", \"LNAME\":\"Doe\"}. The 'params' field will get updated, only if the campaign is in New Template Language, else ignored. The New Template Language is dependent on the values of 'subject', 'htmlContent/htmlUrl', 'sender.name' & 'toField'
   */
  "params"?: any;
  /**
   * Set this to true if you want to send your campaign at best time. Note:- if true, warmup ip will be disabled.
   */
  "sendAtBestTime"?: boolean;
  /**
   * Status of A/B Test. abTesting = false means it is disabled, & abTesting = true means it is enabled. 'subjectA', 'subjectB', 'splitRule', 'winnerCriteria' & 'winnerDelay' will be considered if abTesting is set to true. 'subject' if passed is ignored.  Can be set to true only if 'sendAtBestTime' is 'false'. You will be able to set up two subject lines for your campaign and send them to a random sample of your total recipients. Half of the test group will receive version A, and the other half will receive version B
   */
  "abTesting"?: boolean;
  /**
   * Subject A of the campaign. Considered if abTesting = true. subjectA & subjectB should have unique value
   */
  "subjectA"?: string;
  /**
   * Subject B of the campaign. Considered if abTesting = true. subjectA & subjectB should have unique value
   */
  "subjectB"?: string;
  /**
   * Add the size of your test groups. Considered if abTesting = true. We'll send version A and B to a random sample of recipients, and then the winning version to everyone else
   */
  "splitRule"?: number;
  /**
   * Choose the metrics that will determinate the winning version. Considered if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerCriteria' is ignored if passed or alreday exist in record
   */
  "winnerCriteria"?: UpdateEmailCampaign.WinnerCriteriaEnum;
  /**
   * Choose the duration of the test in hours. Maximum is 7 days, pass 24*7 = 168 hours. The winning version will be sent at the end of the test. Considered if 'splitRule' >= 1 and < 50. If splitRule = 50, 'winnerDelay' is ignored if passed or alreday exist in record
   */
  "winnerDelay"?: number;
  /**
   * Available for dedicated ip clients. Set this to true if you wish to warm up your ip.
   */
  "ipWarmupEnable"?: boolean;
  /**
   * Set an initial quota greater than 1 for warming up your ip. We recommend you set a value of 3000.
   */
  "initialQuota"?: number;
  /**
   * Set a percentage increase rate for warming up your ip. We recommend you set the increase rate to 30% per day. If you want to send the same number of emails every day, set the daily increase value to 0%.
   */
  "increaseRate"?: number;
  /**
   * Enter an unsubscription page id. The page id is a 24 digit alphanumeric id that can be found in the URL when editing the page.
   */
  "unsubscriptionPageId"?: string;
  /**
   * Mandatory if templateId is used containing the {{ update_profile }} tag. Enter an update profile form id. The form id is a 24 digit alphanumeric id that can be found in the URL when editing the form.
   */
  "updateFormId"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "UpdateEmailCampaignSender",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "htmlContent",
      baseName: "htmlContent",
      type: "string",
    },
    {
      name: "htmlUrl",
      baseName: "htmlUrl",
      type: "string",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "string",
    },
    {
      name: "toField",
      baseName: "toField",
      type: "string",
    },
    {
      name: "recipients",
      baseName: "recipients",
      type: "UpdateEmailCampaignRecipients",
    },
    {
      name: "attachmentUrl",
      baseName: "attachmentUrl",
      type: "string",
    },
    {
      name: "inlineImageActivation",
      baseName: "inlineImageActivation",
      type: "boolean",
    },
    {
      name: "mirrorActive",
      baseName: "mirrorActive",
      type: "boolean",
    },
    {
      name: "recurring",
      baseName: "recurring",
      type: "boolean",
    },
    {
      name: "footer",
      baseName: "footer",
      type: "string",
    },
    {
      name: "header",
      baseName: "header",
      type: "string",
    },
    {
      name: "utmCampaign",
      baseName: "utmCampaign",
      type: "string",
    },
    {
      name: "params",
      baseName: "params",
      type: "any",
    },
    {
      name: "sendAtBestTime",
      baseName: "sendAtBestTime",
      type: "boolean",
    },
    {
      name: "abTesting",
      baseName: "abTesting",
      type: "boolean",
    },
    {
      name: "subjectA",
      baseName: "subjectA",
      type: "string",
    },
    {
      name: "subjectB",
      baseName: "subjectB",
      type: "string",
    },
    {
      name: "splitRule",
      baseName: "splitRule",
      type: "number",
    },
    {
      name: "winnerCriteria",
      baseName: "winnerCriteria",
      type: "UpdateEmailCampaign.WinnerCriteriaEnum",
    },
    {
      name: "winnerDelay",
      baseName: "winnerDelay",
      type: "number",
    },
    {
      name: "ipWarmupEnable",
      baseName: "ipWarmupEnable",
      type: "boolean",
    },
    {
      name: "initialQuota",
      baseName: "initialQuota",
      type: "number",
    },
    {
      name: "increaseRate",
      baseName: "increaseRate",
      type: "number",
    },
    {
      name: "unsubscriptionPageId",
      baseName: "unsubscriptionPageId",
      type: "string",
    },
    {
      name: "updateFormId",
      baseName: "updateFormId",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateEmailCampaign.attributeTypeMap;
  }
}

export namespace UpdateEmailCampaign {
  export enum WinnerCriteriaEnum {
    Open = <any>"open",
    Click = <any>"click",
  }
}
/**
 * Segment ids and List ids to include/exclude from campaign
 */
export class UpdateEmailCampaignRecipients {
  /**
   * List ids which have to be excluded from a campaign
   */
  "exclusionListIds"?: Array<number>;
  /**
   * Lists Ids to send the campaign to. Campaign should only be updated with listIds if listIds were used to create it. REQUIRED if already not present in campaign and scheduledAt is not empty
   */
  "listIds"?: Array<number>;
  /**
   * Mandatory if listIds are not used. Campaign should only be updated with segmentIds if segmentIds were used to create it. Segment ids to send the campaign to.
   */
  "segmentIds"?: Array<number>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "exclusionListIds",
      baseName: "exclusionListIds",
      type: "Array<number>",
    },
    {
      name: "listIds",
      baseName: "listIds",
      type: "Array<number>",
    },
    {
      name: "segmentIds",
      baseName: "segmentIds",
      type: "Array<number>",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateEmailCampaignRecipients.attributeTypeMap;
  }
}

/**
 * Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
 */
export class UpdateEmailCampaignSender {
  /**
   * Sender Name from which the campaign emails are sent
   */
  "name"?: string;
  /**
   * Sender email from which the campaign emails are sent
   */
  "email"?: string;
  /**
   * Select the sender for the campaign on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateEmailCampaignSender.attributeTypeMap;
  }
}

export class UpdateExternalFeed {
  /**
   * Name of the feed
   */
  "name"?: string;
  /**
   * URL of the feed
   */
  "url"?: string;
  /**
   * Auth type of the feed:   * `basic`   * `token`   * `noAuth`
   */
  "authType"?: UpdateExternalFeed.AuthTypeEnum;
  /**
   * Username for authType `basic`
   */
  "username"?: string;
  /**
   * Password for authType `basic`
   */
  "password"?: string;
  /**
   * Token for authType `token`
   */
  "token"?: string;
  /**
   * Custom headers for the feed
   */
  "headers"?: Array<GetExternalFeedByUUIDHeaders>;
  /**
   * Maximum number of retries on the feed url
   */
  "maxRetries"?: number;
  /**
   * Toggle caching of feed url response
   */
  "cache"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "authType",
      baseName: "authType",
      type: "UpdateExternalFeed.AuthTypeEnum",
    },
    {
      name: "username",
      baseName: "username",
      type: "string",
    },
    {
      name: "password",
      baseName: "password",
      type: "string",
    },
    {
      name: "token",
      baseName: "token",
      type: "string",
    },
    {
      name: "headers",
      baseName: "headers",
      type: "Array<GetExternalFeedByUUIDHeaders>",
    },
    {
      name: "maxRetries",
      baseName: "maxRetries",
      type: "number",
    },
    {
      name: "cache",
      baseName: "cache",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateExternalFeed.attributeTypeMap;
  }
}

export namespace UpdateExternalFeed {
  export enum AuthTypeEnum {
    Basic = <any>"basic",
    Token = <any>"token",
    NoAuth = <any>"noAuth",
  }
}
export class UpdateList {
  /**
   * Name of the list. Either of the two parameters (name, folderId) can be updated at a time.
   */
  "name"?: string;
  /**
   * Id of the folder in which the list is to be moved. Either of the two parameters (name, folderId) can be updated at a time.
   */
  "folderId"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "folderId",
      baseName: "folderId",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateList.attributeTypeMap;
  }
}

export class UpdateSender {
  /**
   * From Name to update the sender
   */
  "name"?: string;
  /**
   * From Email to update the sender
   */
  "email"?: string;
  /**
   * Only in case of dedicated IP, IPs to associate to the sender. If passed, will replace all the existing IPs.
   */
  "ips"?: Array<CreateSenderIps>;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "ips",
      baseName: "ips",
      type: "Array<CreateSenderIps>",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateSender.attributeTypeMap;
  }
}

export class UpdateSmsCampaign {
  /**
   * Name of the campaign
   */
  "name"?: string;
  /**
   * Name of the sender. **The number of characters is limited to 11 for alphanumeric characters and 15 for numeric characters**
   */
  "sender"?: string;
  /**
   * Content of the message. The maximum characters used per SMS is 160, if used more than that, it will be counted as more than one SMS
   */
  "content"?: string;
  "recipients"?: CreateSmsCampaignRecipients;
  /**
   * UTC date-time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
   */
  "scheduledAt"?: string;
  /**
   * Format of the message. It indicates whether the content should be treated as unicode or not.
   */
  "unicodeEnabled"?: boolean;
  /**
   * A recognizable prefix will ensure your audience knows who you are. Recommended by U.S. carriers. This will be added as your Brand Name before the message content. **Prefer verifying maximum length of 160 characters including this prefix in message content to avoid multiple sending of same sms.**
   */
  "organisationPrefix"?: string;
  /**
   * Instructions to unsubscribe from future communications. Recommended by U.S. carriers. Must include **STOP** keyword. This will be added as instructions after the end of message content. **Prefer verifying maximum length of 160 characters including this instructions in message content to avoid multiple sending of same sms.**
   */
  "unsubscribeInstruction"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "string",
    },
    {
      name: "content",
      baseName: "content",
      type: "string",
    },
    {
      name: "recipients",
      baseName: "recipients",
      type: "CreateSmsCampaignRecipients",
    },
    {
      name: "scheduledAt",
      baseName: "scheduledAt",
      type: "string",
    },
    {
      name: "unicodeEnabled",
      baseName: "unicodeEnabled",
      type: "boolean",
    },
    {
      name: "organisationPrefix",
      baseName: "organisationPrefix",
      type: "string",
    },
    {
      name: "unsubscribeInstruction",
      baseName: "unsubscribeInstruction",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateSmsCampaign.attributeTypeMap;
  }
}

export class UpdateSmtpTemplate {
  /**
   * Tag of the template
   */
  "tag"?: string;
  "sender"?: UpdateSmtpTemplateSender;
  /**
   * Name of the template
   */
  "templateName"?: string;
  /**
   * Required if htmlUrl is empty. If the template is designed using Drag & Drop editor via HTML content, then the design page will not have Drag & Drop editor access for that template. Body of the message (HTML must have more than 10 characters)
   */
  "htmlContent"?: string;
  /**
   * Required if htmlContent is empty. URL to the body of the email (HTML)
   */
  "htmlUrl"?: string;
  /**
   * Subject of the email
   */
  "subject"?: string;
  /**
   * Email on which campaign recipients will be able to reply to
   */
  "replyTo"?: string;
  /**
   * To personalize the «To» Field. If you want to include the first name and last name of your recipient, add {FNAME} {LNAME}. These contact attributes must already exist in your Brevo account. If input parameter 'params' used please use {{contact.FNAME}} {{contact.LNAME}} for personalization
   */
  "toField"?: string;
  /**
   * Absolute url of the attachment (no local file). Extension allowed: xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff, rtf, bmp, cgm, css, shtml, html, htm, zip, xml, ppt, pptx, tar, ez, ics, mobi, msg, pub and eps
   */
  "attachmentUrl"?: string;
  /**
   * Status of the template. isActive = false means template is inactive, isActive = true means template is active
   */
  "isActive"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "tag",
      baseName: "tag",
      type: "string",
    },
    {
      name: "sender",
      baseName: "sender",
      type: "UpdateSmtpTemplateSender",
    },
    {
      name: "templateName",
      baseName: "templateName",
      type: "string",
    },
    {
      name: "htmlContent",
      baseName: "htmlContent",
      type: "string",
    },
    {
      name: "htmlUrl",
      baseName: "htmlUrl",
      type: "string",
    },
    {
      name: "subject",
      baseName: "subject",
      type: "string",
    },
    {
      name: "replyTo",
      baseName: "replyTo",
      type: "string",
    },
    {
      name: "toField",
      baseName: "toField",
      type: "string",
    },
    {
      name: "attachmentUrl",
      baseName: "attachmentUrl",
      type: "string",
    },
    {
      name: "isActive",
      baseName: "isActive",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateSmtpTemplate.attributeTypeMap;
  }
}

/**
 * Sender details including id or email and name (optional). Only one of either Sender's email or Sender's ID shall be passed in one request at a time. For example `{\"name\":\"xyz\", \"email\":\"example@abc.com\"}` , `{\"name\":\"xyz\", \"id\":123}`
 */
export class UpdateSmtpTemplateSender {
  /**
   * Name of the sender
   */
  "name"?: string;
  /**
   * Email of the sender
   */
  "email"?: string;
  /**
   * Select the sender for the template on the basis of sender id. In order to select a sender with specific pool of IP’s, dedicated ip users shall pass id (instead of email).
   */
  "id"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "email",
      baseName: "email",
      type: "string",
    },
    {
      name: "id",
      baseName: "id",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateSmtpTemplateSender.attributeTypeMap;
  }
}

export class UpdateWebhook {
  /**
   * URL of the webhook
   */
  "url"?: string;
  /**
   * Description of the webhook
   */
  "description"?: string;
  /**
   * - Events triggering the webhook. Possible values for **Transactional** type webhook: #### `sent` OR `request`, `delivered`, `hardBounce`, `softBounce`, `blocked`, `spam`, `invalid`, `deferred`, `click`, `opened`, `uniqueOpened` and `unsubscribed` - Possible values for **Marketing** type webhook: #### `spam`, `opened`, `click`, `hardBounce`, `softBounce`, `unsubscribed`, `listAddition` & `delivered` - Possible values for **Inbound** type webhook: #### `inboundEmailProcessed`
   */
  "events"?: Array<UpdateWebhook.EventsEnum>;
  /**
   * Inbound domain of webhook, used in case of event type `inbound`
   */
  "domain"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
    {
      name: "description",
      baseName: "description",
      type: "string",
    },
    {
      name: "events",
      baseName: "events",
      type: "Array<UpdateWebhook.EventsEnum>",
    },
    {
      name: "domain",
      baseName: "domain",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UpdateWebhook.attributeTypeMap;
  }
}

export namespace UpdateWebhook {
  export enum EventsEnum {
    Sent = <any>"sent",
    HardBounce = <any>"hardBounce",
    SoftBounce = <any>"softBounce",
    Blocked = <any>"blocked",
    Spam = <any>"spam",
    Delivered = <any>"delivered",
    Request = <any>"request",
    Click = <any>"click",
    Invalid = <any>"invalid",
    Deferred = <any>"deferred",
    Opened = <any>"opened",
    UniqueOpened = <any>"uniqueOpened",
    Unsubscribed = <any>"unsubscribed",
    ListAddition = <any>"listAddition",
    ContactUpdated = <any>"contactUpdated",
    ContactDeleted = <any>"contactDeleted",
    InboundEmailProcessed = <any>"inboundEmailProcessed",
  }
}
export class UploadImageModel {
  /**
   * URL of the image uploaded
   */
  "url": string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "url",
      baseName: "url",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UploadImageModel.attributeTypeMap;
  }
}

export class UploadImageToGallery {
  /**
   * The absolute url of the image (no local file). Maximum allowed size for image is 2MB. Allowed extensions for images are - jpeg, jpg, png, bmp, gif.
   */
  "imageUrl": string;
  /**
   * Name of the image.
   */
  "name"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "imageUrl",
      baseName: "imageUrl",
      type: "string",
    },
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return UploadImageToGallery.attributeTypeMap;
  }
}

export class VariablesItems {
  "name"?: string;
  "_default"?: string;
  "datatype"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "_default",
      baseName: "default",
      type: "string",
    },
    {
      name: "datatype",
      baseName: "datatype",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return VariablesItems.attributeTypeMap;
  }
}

export class WhatsappCampStats {
  "sent": number;
  "delivered": number;
  "read": number;
  "unsubscribe": number;
  "notSent": number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "sent",
      baseName: "sent",
      type: "number",
    },
    {
      name: "delivered",
      baseName: "delivered",
      type: "number",
    },
    {
      name: "read",
      baseName: "read",
      type: "number",
    },
    {
      name: "unsubscribe",
      baseName: "unsubscribe",
      type: "number",
    },
    {
      name: "notSent",
      baseName: "not_sent",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return WhatsappCampStats.attributeTypeMap;
  }
}

export class WhatsappCampTemplate {
  /**
   * name of the template
   */
  "name"?: string;
  /**
   * description of the template
   */
  "category"?: string;
  /**
   * language of the template
   */
  "language"?: string;
  "containsButton"?: boolean;
  "displayHeader"?: boolean;
  /**
   * type of header
   */
  "headerType"?: string;
  /**
   * array of component item objects
   */
  "components"?: Array<ComponentItems>;
  /**
   * array of variables item object
   */
  "headerVariables"?: Array<VariablesItems>;
  /**
   * array of variables item variables
   */
  "bodyVariables"?: Array<VariablesItems>;
  "buttonType"?: string;
  "hideFooter"?: boolean;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "category",
      baseName: "category",
      type: "string",
    },
    {
      name: "language",
      baseName: "language",
      type: "string",
    },
    {
      name: "containsButton",
      baseName: "contains_button",
      type: "boolean",
    },
    {
      name: "displayHeader",
      baseName: "display_header",
      type: "boolean",
    },
    {
      name: "headerType",
      baseName: "header_type",
      type: "string",
    },
    {
      name: "components",
      baseName: "components",
      type: "Array<ComponentItems>",
    },
    {
      name: "headerVariables",
      baseName: "header_variables",
      type: "Array<VariablesItems>",
    },
    {
      name: "bodyVariables",
      baseName: "body_variables",
      type: "Array<VariablesItems>",
    },
    {
      name: "buttonType",
      baseName: "button_type",
      type: "string",
    },
    {
      name: "hideFooter",
      baseName: "hide_footer",
      type: "boolean",
    },
  ];

  static getAttributeTypeMap() {
    return WhatsappCampTemplate.attributeTypeMap;
  }
}

const enumsMap: { [index: string]: any } = {
  "AbTestCampaignResult.WinningVersionEnum":
    AbTestCampaignResult.WinningVersionEnum,
  "AbTestCampaignResult.WinningCriteriaEnum":
    AbTestCampaignResult.WinningCriteriaEnum,
  "ConversationsMessage.TypeEnum": ConversationsMessage.TypeEnum,
  "CreateAttribute.TypeEnum": CreateAttribute.TypeEnum,
  "CreateChild.LanguageEnum": CreateChild.LanguageEnum,
  "CreateEmailCampaign.WinnerCriteriaEnum":
    CreateEmailCampaign.WinnerCriteriaEnum,
  "CreateExternalFeed.AuthTypeEnum": CreateExternalFeed.AuthTypeEnum,
  "CreateSubAccount.LanguageEnum": CreateSubAccount.LanguageEnum,
  "CreateWebhook.EventsEnum": CreateWebhook.EventsEnum,
  "CreateWebhook.TypeEnum": CreateWebhook.TypeEnum,
  "CreateWhatsAppTemplate.CategoryEnum": CreateWhatsAppTemplate.CategoryEnum,
  "EmailExportRecipients.RecipientsTypeEnum":
    EmailExportRecipients.RecipientsTypeEnum,
  "ErrorModel.CodeEnum": ErrorModel.CodeEnum,
  "ExportWebhooksHistory.EventEnum": ExportWebhooksHistory.EventEnum,
  "GetAccountPlan.TypeEnum": GetAccountPlan.TypeEnum,
  "GetAccountPlan.CreditsTypeEnum": GetAccountPlan.CreditsTypeEnum,
  "GetAllExternalFeedsFeeds.AuthTypeEnum":
    GetAllExternalFeedsFeeds.AuthTypeEnum,
  "GetAttributesAttributes.CategoryEnum": GetAttributesAttributes.CategoryEnum,
  "GetAttributesAttributes.TypeEnum": GetAttributesAttributes.TypeEnum,
  "GetCampaignOverview.TypeEnum": GetCampaignOverview.TypeEnum,
  "GetCampaignOverview.StatusEnum": GetCampaignOverview.StatusEnum,
  "GetEmailEventReportEvents.EventEnum": GetEmailEventReportEvents.EventEnum,
  "GetExternalFeedByUUID.AuthTypeEnum": GetExternalFeedByUUID.AuthTypeEnum,
  "GetInboundEmailEventsByUuidLogs.TypeEnum":
    GetInboundEmailEventsByUuidLogs.TypeEnum,
  "GetProcess.StatusEnum": GetProcess.StatusEnum,
  "GetScheduledEmailByBatchIdBatches.StatusEnum":
    GetScheduledEmailByBatchIdBatches.StatusEnum,
  "GetScheduledEmailByMessageId.StatusEnum":
    GetScheduledEmailByMessageId.StatusEnum,
  "GetSmsCampaignOverview.StatusEnum": GetSmsCampaignOverview.StatusEnum,
  "GetSmsEventReportEvents.EventEnum": GetSmsEventReportEvents.EventEnum,
  "GetTransacBlockedContactsReason.CodeEnum":
    GetTransacBlockedContactsReason.CodeEnum,
  "GetWebhook.TypeEnum": GetWebhook.TypeEnum,
  "GetWhatsAppConfig.PhoneNumberQualityEnum":
    GetWhatsAppConfig.PhoneNumberQualityEnum,
  "GetWhatsAppConfig.PhoneNumberNameStatusEnum":
    GetWhatsAppConfig.PhoneNumberNameStatusEnum,
  "GetWhatsappCampaignOverview.CampaignStatusEnum":
    GetWhatsappCampaignOverview.CampaignStatusEnum,
  "GetWhatsappCampaignsCampaigns.CampaignStatusEnum":
    GetWhatsappCampaignsCampaigns.CampaignStatusEnum,
  "GetWhatsappEventReportEvents.EventEnum":
    GetWhatsappEventReportEvents.EventEnum,
  "MasterDetailsResponsePlanInfo.PlanPeriodEnum":
    MasterDetailsResponsePlanInfo.PlanPeriodEnum,
  "RequestContactExportCustomContactFilter.ActionForContactsEnum":
    RequestContactExportCustomContactFilter.ActionForContactsEnum,
  "RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum":
    RequestContactExportCustomContactFilter.ActionForEmailCampaignsEnum,
  "RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum":
    RequestContactExportCustomContactFilter.ActionForSmsCampaignsEnum,
  "RequestSmsRecipientExport.RecipientsTypeEnum":
    RequestSmsRecipientExport.RecipientsTypeEnum,
  "SendReport.LanguageEnum": SendReport.LanguageEnum,
  "SendTransacSms.TypeEnum": SendTransacSms.TypeEnum,
  "SsoTokenRequest.TargetEnum": SsoTokenRequest.TargetEnum,
  "TaskReminder.UnitEnum": TaskReminder.UnitEnum,
  "UpdateCampaignStatus.StatusEnum": UpdateCampaignStatus.StatusEnum,
  "UpdateEmailCampaign.WinnerCriteriaEnum":
    UpdateEmailCampaign.WinnerCriteriaEnum,
  "UpdateExternalFeed.AuthTypeEnum": UpdateExternalFeed.AuthTypeEnum,
  "UpdateWebhook.EventsEnum": UpdateWebhook.EventsEnum,
};

const typeMap: { [index: string]: any } = {
  AbTestCampaignResult: AbTestCampaignResult,
  AbTestCampaignResultClickedLinks: AbTestCampaignResultClickedLinks,
  AbTestCampaignResultStatistics: AbTestCampaignResultStatistics,
  AbTestVersionClicks: AbTestVersionClicks,
  AbTestVersionClicksInner: AbTestVersionClicksInner,
  AbTestVersionStats: AbTestVersionStats,
  AddChildDomain: AddChildDomain,
  AddContactToList: AddContactToList,
  AddCredits: AddCredits,
  AuthenticateDomainModel: AuthenticateDomainModel,
  BlockDomain: BlockDomain,
  Body: Body,
  Body1: Body1,
  Body10: Body10,
  Body11: Body11,
  Body12: Body12,
  Body2: Body2,
  Body3: Body3,
  Body4: Body4,
  Body5: Body5,
  Body6: Body6,
  Body7: Body7,
  Body8: Body8,
  Body9: Body9,
  BodyVariablesItems: BodyVariablesItems,
  CompaniesList: CompaniesList,
  Company: Company,
  CompanyAttributes: CompanyAttributes,
  CompanyAttributesInner: CompanyAttributesInner,
  ComponentItems: ComponentItems,
  ConversationsMessage: ConversationsMessage,
  ConversationsMessageFile: ConversationsMessageFile,
  ConversationsMessageFileImageInfo: ConversationsMessageFileImageInfo,
  CreateApiKeyRequest: CreateApiKeyRequest,
  CreateApiKeyResponse: CreateApiKeyResponse,
  CreateAttribute: CreateAttribute,
  CreateAttributeEnumeration: CreateAttributeEnumeration,
  CreateCategoryModel: CreateCategoryModel,
  CreateChild: CreateChild,
  CreateContact: CreateContact,
  CreateDoiContact: CreateDoiContact,
  CreateDomain: CreateDomain,
  CreateDomainModel: CreateDomainModel,
  CreateDomainModelDnsRecords: CreateDomainModelDnsRecords,
  CreateDomainModelDnsRecordsDkimRecord: CreateDomainModelDnsRecordsDkimRecord,
  CreateEmailCampaign: CreateEmailCampaign,
  CreateEmailCampaignRecipients: CreateEmailCampaignRecipients,
  CreateEmailCampaignSender: CreateEmailCampaignSender,
  CreateExternalFeed: CreateExternalFeed,
  CreateList: CreateList,
  CreateModel: CreateModel,
  CreateProductModel: CreateProductModel,
  CreateReseller: CreateReseller,
  CreateSender: CreateSender,
  CreateSenderIps: CreateSenderIps,
  CreateSenderModel: CreateSenderModel,
  CreateSmsCampaign: CreateSmsCampaign,
  CreateSmsCampaignRecipients: CreateSmsCampaignRecipients,
  CreateSmtpEmail: CreateSmtpEmail,
  CreateSmtpTemplate: CreateSmtpTemplate,
  CreateSmtpTemplateSender: CreateSmtpTemplateSender,
  CreateSubAccount: CreateSubAccount,
  CreateSubAccountResponse: CreateSubAccountResponse,
  CreateUpdateBatchCategory: CreateUpdateBatchCategory,
  CreateUpdateBatchCategoryModel: CreateUpdateBatchCategoryModel,
  CreateUpdateBatchProducts: CreateUpdateBatchProducts,
  CreateUpdateBatchProductsModel: CreateUpdateBatchProductsModel,
  CreateUpdateCategories: CreateUpdateCategories,
  CreateUpdateCategory: CreateUpdateCategory,
  CreateUpdateContactModel: CreateUpdateContactModel,
  CreateUpdateFolder: CreateUpdateFolder,
  CreateUpdateProduct: CreateUpdateProduct,
  CreateUpdateProducts: CreateUpdateProducts,
  CreateWebhook: CreateWebhook,
  CreateWhatsAppCampaign: CreateWhatsAppCampaign,
  CreateWhatsAppCampaignRecipients: CreateWhatsAppCampaignRecipients,
  CreateWhatsAppTemplate: CreateWhatsAppTemplate,
  CreatedBatchId: CreatedBatchId,
  CreatedProcessId: CreatedProcessId,
  Deal: Deal,
  DealAttributes: DealAttributes,
  DealAttributesInner: DealAttributesInner,
  DealsList: DealsList,
  DeleteHardbounces: DeleteHardbounces,
  EmailExportRecipients: EmailExportRecipients,
  ErrorModel: ErrorModel,
  ExportWebhooksHistory: ExportWebhooksHistory,
  FileData: FileData,
  FileDownloadableLink: FileDownloadableLink,
  FileList: FileList,
  GetAccount: GetAccount,
  GetAccountActivity: GetAccountActivity,
  GetAccountActivityLogs: GetAccountActivityLogs,
  GetAccountMarketingAutomation: GetAccountMarketingAutomation,
  GetAccountPlan: GetAccountPlan,
  GetAccountRelay: GetAccountRelay,
  GetAccountRelayData: GetAccountRelayData,
  GetAggregatedReport: GetAggregatedReport,
  GetAllExternalFeeds: GetAllExternalFeeds,
  GetAllExternalFeedsFeeds: GetAllExternalFeedsFeeds,
  GetAttributes: GetAttributes,
  GetAttributesAttributes: GetAttributesAttributes,
  GetAttributesEnumeration: GetAttributesEnumeration,
  GetBlockedDomains: GetBlockedDomains,
  GetCampaignOverview: GetCampaignOverview,
  GetCampaignRecipients: GetCampaignRecipients,
  GetCampaignStats: GetCampaignStats,
  GetCategories: GetCategories,
  GetCategoryDetails: GetCategoryDetails,
  GetChildAccountCreationStatus: GetChildAccountCreationStatus,
  GetChildDomain: GetChildDomain,
  GetChildDomains: GetChildDomains,
  GetChildInfo: GetChildInfo,
  GetChildInfoApiKeys: GetChildInfoApiKeys,
  GetChildInfoApiKeysV2: GetChildInfoApiKeysV2,
  GetChildInfoApiKeysV3: GetChildInfoApiKeysV3,
  GetChildInfoCredits: GetChildInfoCredits,
  GetChildInfoStatistics: GetChildInfoStatistics,
  GetChildrenList: GetChildrenList,
  GetClient: GetClient,
  GetContactCampaignStats: GetContactCampaignStats,
  GetContactCampaignStatsClicked: GetContactCampaignStatsClicked,
  GetContactCampaignStatsOpened: GetContactCampaignStatsOpened,
  GetContactCampaignStatsTransacAttributes:
    GetContactCampaignStatsTransacAttributes,
  GetContactCampaignStatsUnsubscriptions:
    GetContactCampaignStatsUnsubscriptions,
  GetContactDetails: GetContactDetails,
  GetContacts: GetContacts,
  GetDeviceBrowserStats: GetDeviceBrowserStats,
  GetDomainonfigurationModel: GetDomainonfigurationModel,
  GetDomainsList: GetDomainsList,
  GetDomainsListDomains: GetDomainsListDomains,
  GetEmailCampaign: GetEmailCampaign,
  GetEmailCampaigns: GetEmailCampaigns,
  GetEmailEventReport: GetEmailEventReport,
  GetEmailEventReportEvents: GetEmailEventReportEvents,
  GetExtendedCampaignOverview: GetExtendedCampaignOverview,
  GetExtendedCampaignOverviewSender: GetExtendedCampaignOverviewSender,
  GetExtendedCampaignStats: GetExtendedCampaignStats,
  GetExtendedCampaignStatsGlobalStats: GetExtendedCampaignStatsGlobalStats,
  GetExtendedClient: GetExtendedClient,
  GetExtendedClientAddress: GetExtendedClientAddress,
  GetExtendedContactDetails: GetExtendedContactDetails,
  GetExtendedContactDetailsStatistics: GetExtendedContactDetailsStatistics,
  GetExtendedContactDetailsStatisticsClicked:
    GetExtendedContactDetailsStatisticsClicked,
  GetExtendedContactDetailsStatisticsLinks:
    GetExtendedContactDetailsStatisticsLinks,
  GetExtendedContactDetailsStatisticsMessagesSent:
    GetExtendedContactDetailsStatisticsMessagesSent,
  GetExtendedContactDetailsStatisticsOpened:
    GetExtendedContactDetailsStatisticsOpened,
  GetExtendedContactDetailsStatisticsUnsubscriptions:
    GetExtendedContactDetailsStatisticsUnsubscriptions,
  GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription:
    GetExtendedContactDetailsStatisticsUnsubscriptionsAdminUnsubscription,
  GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription:
    GetExtendedContactDetailsStatisticsUnsubscriptionsUserUnsubscription,
  GetExtendedList: GetExtendedList,
  GetExtendedListCampaignStats: GetExtendedListCampaignStats,
  GetExternalFeedByUUID: GetExternalFeedByUUID,
  GetExternalFeedByUUIDHeaders: GetExternalFeedByUUIDHeaders,
  GetFolder: GetFolder,
  GetFolderLists: GetFolderLists,
  GetFolders: GetFolders,
  GetInboundEmailEvents: GetInboundEmailEvents,
  GetInboundEmailEventsByUuid: GetInboundEmailEventsByUuid,
  GetInboundEmailEventsByUuidAttachments:
    GetInboundEmailEventsByUuidAttachments,
  GetInboundEmailEventsByUuidLogs: GetInboundEmailEventsByUuidLogs,
  GetInboundEmailEventsEvents: GetInboundEmailEventsEvents,
  GetIp: GetIp,
  GetIpFromSender: GetIpFromSender,
  GetIps: GetIps,
  GetIpsFromSender: GetIpsFromSender,
  GetList: GetList,
  GetLists: GetLists,
  GetProcess: GetProcess,
  GetProcesses: GetProcesses,
  GetProductDetails: GetProductDetails,
  GetProducts: GetProducts,
  GetReports: GetReports,
  GetReportsReports: GetReportsReports,
  GetScheduledEmailByBatchId: GetScheduledEmailByBatchId,
  GetScheduledEmailByBatchIdBatches: GetScheduledEmailByBatchIdBatches,
  GetScheduledEmailByMessageId: GetScheduledEmailByMessageId,
  GetSegments: GetSegments,
  GetSegmentsSegments: GetSegmentsSegments,
  GetSendersList: GetSendersList,
  GetSendersListIps: GetSendersListIps,
  GetSendersListSenders: GetSendersListSenders,
  GetSharedTemplateUrl: GetSharedTemplateUrl,
  GetSmsCampaign: GetSmsCampaign,
  GetSmsCampaignOverview: GetSmsCampaignOverview,
  GetSmsCampaignRecipients: GetSmsCampaignRecipients,
  GetSmsCampaignStats: GetSmsCampaignStats,
  GetSmsCampaigns: GetSmsCampaigns,
  GetSmsEventReport: GetSmsEventReport,
  GetSmsEventReportEvents: GetSmsEventReportEvents,
  GetSmtpTemplateOverview: GetSmtpTemplateOverview,
  GetSmtpTemplateOverviewSender: GetSmtpTemplateOverviewSender,
  GetSmtpTemplates: GetSmtpTemplates,
  GetSsoToken: GetSsoToken,
  GetStatsByBrowser: GetStatsByBrowser,
  GetStatsByDevice: GetStatsByDevice,
  GetStatsByDomain: GetStatsByDomain,
  GetTransacAggregatedSmsReport: GetTransacAggregatedSmsReport,
  GetTransacBlockedContacts: GetTransacBlockedContacts,
  GetTransacBlockedContactsContacts: GetTransacBlockedContactsContacts,
  GetTransacBlockedContactsReason: GetTransacBlockedContactsReason,
  GetTransacEmailContent: GetTransacEmailContent,
  GetTransacEmailContentEvents: GetTransacEmailContentEvents,
  GetTransacEmailsList: GetTransacEmailsList,
  GetTransacEmailsListTransactionalEmails:
    GetTransacEmailsListTransactionalEmails,
  GetTransacSmsReport: GetTransacSmsReport,
  GetTransacSmsReportReports: GetTransacSmsReportReports,
  GetWATemplates: GetWATemplates,
  GetWATemplatesTemplates: GetWATemplatesTemplates,
  GetWebhook: GetWebhook,
  GetWebhooks: GetWebhooks,
  GetWhatsAppConfig: GetWhatsAppConfig,
  GetWhatsappCampaignOverview: GetWhatsappCampaignOverview,
  GetWhatsappCampaigns: GetWhatsappCampaigns,
  GetWhatsappCampaignsCampaigns: GetWhatsappCampaignsCampaigns,
  GetWhatsappEventReport: GetWhatsappEventReport,
  GetWhatsappEventReportEvents: GetWhatsappEventReportEvents,
  InlineResponse200: InlineResponse200,
  InlineResponse201: InlineResponse201,
  InlineResponse2011: InlineResponse2011,
  InlineResponse2012: InlineResponse2012,
  InlineResponse2013: InlineResponse2013,
  ManageIp: ManageIp,
  MasterDetailsResponse: MasterDetailsResponse,
  MasterDetailsResponseBillingInfo: MasterDetailsResponseBillingInfo,
  MasterDetailsResponseBillingInfoAddress:
    MasterDetailsResponseBillingInfoAddress,
  MasterDetailsResponseBillingInfoName: MasterDetailsResponseBillingInfoName,
  MasterDetailsResponsePlanInfo: MasterDetailsResponsePlanInfo,
  MasterDetailsResponsePlanInfoFeatures: MasterDetailsResponsePlanInfoFeatures,
  Note: Note,
  NoteData: NoteData,
  NoteId: NoteId,
  NoteList: NoteList,
  Order: Order,
  OrderBatch: OrderBatch,
  OrderBilling: OrderBilling,
  OrderProducts: OrderProducts,
  Otp: Otp,
  Pipeline: Pipeline,
  PipelineStage: PipelineStage,
  PostContactInfo: PostContactInfo,
  PostContactInfoContacts: PostContactInfoContacts,
  PostSendFailed: PostSendFailed,
  PostSendSmsTestFailed: PostSendSmsTestFailed,
  RemainingCreditModel: RemainingCreditModel,
  RemainingCreditModelChild: RemainingCreditModelChild,
  RemainingCreditModelReseller: RemainingCreditModelReseller,
  RemoveContactFromList: RemoveContactFromList,
  RemoveCredits: RemoveCredits,
  RequestContactExport: RequestContactExport,
  RequestContactExportCustomContactFilter:
    RequestContactExportCustomContactFilter,
  RequestContactImport: RequestContactImport,
  RequestContactImportNewList: RequestContactImportNewList,
  RequestSmsRecipientExport: RequestSmsRecipientExport,
  ScheduleSmtpEmail: ScheduleSmtpEmail,
  SendReport: SendReport,
  SendReportEmail: SendReportEmail,
  SendSms: SendSms,
  SendSmtpEmail: SendSmtpEmail,
  SendSmtpEmailAttachment: SendSmtpEmailAttachment,
  SendSmtpEmailBcc: SendSmtpEmailBcc,
  SendSmtpEmailCc: SendSmtpEmailCc,
  SendSmtpEmailMessageVersions: SendSmtpEmailMessageVersions,
  SendSmtpEmailReplyTo: SendSmtpEmailReplyTo,
  SendSmtpEmailReplyTo1: SendSmtpEmailReplyTo1,
  SendSmtpEmailSender: SendSmtpEmailSender,
  SendSmtpEmailTo: SendSmtpEmailTo,
  SendSmtpEmailTo1: SendSmtpEmailTo1,
  SendTestEmail: SendTestEmail,
  SendTestSms: SendTestSms,
  SendTransacSms: SendTransacSms,
  SendWhatsappMessage: SendWhatsappMessage,
  SsoTokenRequest: SsoTokenRequest,
  SubAccountDetailsResponse: SubAccountDetailsResponse,
  SubAccountDetailsResponsePlanInfo: SubAccountDetailsResponsePlanInfo,
  SubAccountDetailsResponsePlanInfoCredits:
    SubAccountDetailsResponsePlanInfoCredits,
  SubAccountDetailsResponsePlanInfoCreditsEmails:
    SubAccountDetailsResponsePlanInfoCreditsEmails,
  SubAccountDetailsResponsePlanInfoFeatures:
    SubAccountDetailsResponsePlanInfoFeatures,
  SubAccountDetailsResponsePlanInfoFeaturesInbox:
    SubAccountDetailsResponsePlanInfoFeaturesInbox,
  SubAccountDetailsResponsePlanInfoFeaturesLandingPage:
    SubAccountDetailsResponsePlanInfoFeaturesLandingPage,
  SubAccountDetailsResponsePlanInfoFeaturesUsers:
    SubAccountDetailsResponsePlanInfoFeaturesUsers,
  SubAccountUpdatePlanRequest: SubAccountUpdatePlanRequest,
  SubAccountUpdatePlanRequestCredits: SubAccountUpdatePlanRequestCredits,
  SubAccountUpdatePlanRequestFeatures: SubAccountUpdatePlanRequestFeatures,
  SubAccountsResponse: SubAccountsResponse,
  SubAccountsResponseSubAccounts: SubAccountsResponseSubAccounts,
  Task: Task,
  TaskList: TaskList,
  TaskReminder: TaskReminder,
  TaskTypes: TaskTypes,
  UpdateAttribute: UpdateAttribute,
  UpdateAttributeEnumeration: UpdateAttributeEnumeration,
  UpdateBatchContacts: UpdateBatchContacts,
  UpdateBatchContactsContacts: UpdateBatchContactsContacts,
  UpdateBatchContactsModel: UpdateBatchContactsModel,
  UpdateCampaignStatus: UpdateCampaignStatus,
  UpdateChild: UpdateChild,
  UpdateChildAccountStatus: UpdateChildAccountStatus,
  UpdateChildDomain: UpdateChildDomain,
  UpdateContact: UpdateContact,
  UpdateEmailCampaign: UpdateEmailCampaign,
  UpdateEmailCampaignRecipients: UpdateEmailCampaignRecipients,
  UpdateEmailCampaignSender: UpdateEmailCampaignSender,
  UpdateExternalFeed: UpdateExternalFeed,
  UpdateList: UpdateList,
  UpdateSender: UpdateSender,
  UpdateSmsCampaign: UpdateSmsCampaign,
  UpdateSmtpTemplate: UpdateSmtpTemplate,
  UpdateSmtpTemplateSender: UpdateSmtpTemplateSender,
  UpdateWebhook: UpdateWebhook,
  UploadImageModel: UploadImageModel,
  UploadImageToGallery: UploadImageToGallery,
  VariablesItems: VariablesItems,
  WhatsappCampStats: WhatsappCampStats,
  WhatsappCampTemplate: WhatsappCampTemplate,
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username = "";
  public password = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password,
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey = "";

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == "header" &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username = "";
  public password = "";

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum AccountApiApiKeys {
  apiKey,
  partnerKey,
}

export class AccountApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: AccountApiApiKeys, value: string) {
    (this.authentications as any)[AccountApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get your account information, plan and credits details
   * @param {*} [options] Override http request options.
   */
  public getAccount(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetAccount }> {
    const localVarPath = this.basePath + "/account";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetAccount }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetAccount");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get user activity logs
   * @param startDate Mandatory if endDate is used. Enter start date in UTC date (YYYY-MM-DD) format to filter the activity in your account. Maximum time period that can be selected is one month. Additionally, you can retrieve activity logs from the past 12 months from the date of your search.
   * @param endDate Mandatory if startDate is used. Enter end date in UTC date (YYYY-MM-DD) format to filter the activity in your account. Maximum time period that can be selected is one month.
   * @param limit Number of documents per page
   * @param offset Index of the first document in the page.
   * @param {*} [options] Override http request options.
   */
  public getAccountActivity(
    startDate?: string,
    endDate?: string,
    limit?: number,
    offset?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetAccountActivity }> {
    const localVarPath = this.basePath + "/organization/activities";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetAccountActivity;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetAccountActivity");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum CompaniesApiApiKeys {
  apiKey,
  partnerKey,
}

export class CompaniesApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: CompaniesApiApiKeys, value: string) {
    (this.authentications as any)[CompaniesApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get company attributes
   * @param {*} [options] Override http request options.
   */
  public companiesAttributesGet(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CompanyAttributes }> {
    const localVarPath = this.basePath + "/companies/attributes";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CompanyAttributes;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CompanyAttributes");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all companies
   * @param filters Filter by attrbutes. If you have filter for owner on your side please send it as {\&quot;attributes.owner\&quot;:\&quot;5b1a17d914b73d35a76ca0c7\&quot;}
   * @param linkedContactsIds Filter by linked contacts ids
   * @param linkedDealsIds Filter by linked deals ids
   * @param page Index of the first document of the page
   * @param limit Number of documents per page
   * @param sort Sort the results in the ascending/descending order. Default order is **descending** by creation if &#x60;sort&#x60; is not passed
   * @param sortBy The field used to sort field names.
   * @param {*} [options] Override http request options.
   */
  public companiesGet(
    filters?: string,
    linkedContactsIds?: number,
    linkedDealsIds?: string,
    page?: number,
    limit?: number,
    sort?: "asc" | "desc",
    sortBy?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CompaniesList }> {
    const localVarPath = this.basePath + "/companies";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (filters !== undefined) {
      localVarQueryParameters["filters"] = ObjectSerializer.serialize(
        filters,
        "string"
      );
    }

    if (linkedContactsIds !== undefined) {
      localVarQueryParameters["linkedContactsIds"] = ObjectSerializer.serialize(
        linkedContactsIds,
        "number"
      );
    }

    if (linkedDealsIds !== undefined) {
      localVarQueryParameters["linkedDealsIds"] = ObjectSerializer.serialize(
        linkedDealsIds,
        "string"
      );
    }

    if (page !== undefined) {
      localVarQueryParameters["page"] = ObjectSerializer.serialize(
        page,
        "number"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
        sortBy,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CompaniesList }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CompaniesList");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a company
   * @param id
   * @param {*} [options] Override http request options.
   */
  public companiesIdDelete(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/companies/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling companiesIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a company
   * @param id
   * @param {*} [options] Override http request options.
   */
  public companiesIdGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Company }> {
    const localVarPath =
      this.basePath +
      "/companies/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling companiesIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Company }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Company");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a company
   * @param id
   * @param body Updated company details.
   * @param {*} [options] Override http request options.
   */
  public companiesIdPatch(
    id: string,
    body: Body1,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Company }> {
    const localVarPath =
      this.basePath +
      "/companies/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling companiesIdPatch."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling companiesIdPatch."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body1"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Company }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Company");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Link and Unlink company with contacts and deals
   * @param id
   * @param body Linked / Unlinked contacts and deals ids.
   * @param {*} [options] Override http request options.
   */
  public companiesLinkUnlinkIdPatch(
    id: string,
    body: Body2,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/companies/link-unlink/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling companiesLinkUnlinkIdPatch."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling companiesLinkUnlinkIdPatch."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body2"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a company
   * @param body Company create data.
   * @param {*} [options] Override http request options.
   */
  public companiesPost(
    body: Body,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse200 }> {
    const localVarPath = this.basePath + "/companies";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling companiesPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse200;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse200");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum ContactsApiApiKeys {
  apiKey,
  partnerKey,
}

export class ContactsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ContactsApiApiKeys, value: string) {
    (this.authentications as any)[ContactsApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Add existing contacts to a list
   * @param listId Id of the list
   * @param contactEmails Emails addresses OR IDs of the contacts
   * @param {*} [options] Override http request options.
   */
  public addContactToList(
    listId: number,
    contactEmails: AddContactToList,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: PostContactInfo }> {
    const localVarPath =
      this.basePath +
      "/contacts/lists/{listId}/contacts/add".replace(
        "{" + "listId" + "}",
        encodeURIComponent(String(listId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling addContactToList."
      );
    }

    // verify required parameter 'contactEmails' is not null or undefined
    if (contactEmails === null || contactEmails === undefined) {
      throw new Error(
        "Required parameter contactEmails was null or undefined when calling addContactToList."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(contactEmails, "AddContactToList"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: PostContactInfo;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "PostContactInfo");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create contact attribute
   * @param attributeCategory Category of the attribute
   * @param attributeName Name of the attribute
   * @param createAttribute Values to create an attribute
   * @param {*} [options] Override http request options.
   */
  public createAttribute(
    attributeCategory:
      | "normal"
      | "transactional"
      | "category"
      | "calculated"
      | "global",
    attributeName: string,
    createAttribute: CreateAttribute,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/attributes/{attributeCategory}/{attributeName}"
        .replace(
          "{" + "attributeCategory" + "}",
          encodeURIComponent(String(attributeCategory))
        )
        .replace(
          "{" + "attributeName" + "}",
          encodeURIComponent(String(attributeName))
        );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'attributeCategory' is not null or undefined
    if (attributeCategory === null || attributeCategory === undefined) {
      throw new Error(
        "Required parameter attributeCategory was null or undefined when calling createAttribute."
      );
    }

    // verify required parameter 'attributeName' is not null or undefined
    if (attributeName === null || attributeName === undefined) {
      throw new Error(
        "Required parameter attributeName was null or undefined when calling createAttribute."
      );
    }

    // verify required parameter 'createAttribute' is not null or undefined
    if (createAttribute === null || createAttribute === undefined) {
      throw new Error(
        "Required parameter createAttribute was null or undefined when calling createAttribute."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createAttribute, "CreateAttribute"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a contact
   * @param createContact Values to create a contact
   * @param {*} [options] Override http request options.
   */
  public createContact(
    createContact: CreateContact,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateUpdateContactModel;
  }> {
    const localVarPath = this.basePath + "/contacts";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createContact' is not null or undefined
    if (createContact === null || createContact === undefined) {
      throw new Error(
        "Required parameter createContact was null or undefined when calling createContact."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createContact, "CreateContact"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateUpdateContactModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateUpdateContactModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create Contact via DOI (Double-Opt-In) Flow
   * @param createDoiContact Values to create the Double opt-in (DOI) contact
   * @param {*} [options] Override http request options.
   */
  public createDoiContact(
    createDoiContact: CreateDoiContact,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/contacts/doubleOptinConfirmation";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createDoiContact' is not null or undefined
    if (createDoiContact === null || createDoiContact === undefined) {
      throw new Error(
        "Required parameter createDoiContact was null or undefined when calling createDoiContact."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createDoiContact, "CreateDoiContact"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a folder
   * @param createFolder Name of the folder
   * @param {*} [options] Override http request options.
   */
  public createFolder(
    createFolder: CreateUpdateFolder,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/contacts/folders";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createFolder' is not null or undefined
    if (createFolder === null || createFolder === undefined) {
      throw new Error(
        "Required parameter createFolder was null or undefined when calling createFolder."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createFolder, "CreateUpdateFolder"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a list
   * @param createList Values to create a list
   * @param {*} [options] Override http request options.
   */
  public createList(
    createList: CreateList,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/contacts/lists";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createList' is not null or undefined
    if (createList === null || createList === undefined) {
      throw new Error(
        "Required parameter createList was null or undefined when calling createList."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createList, "CreateList"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete an attribute
   * @param attributeCategory Category of the attribute
   * @param attributeName Name of the existing attribute
   * @param {*} [options] Override http request options.
   */
  public deleteAttribute(
    attributeCategory:
      | "normal"
      | "transactional"
      | "category"
      | "calculated"
      | "global",
    attributeName: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/attributes/{attributeCategory}/{attributeName}"
        .replace(
          "{" + "attributeCategory" + "}",
          encodeURIComponent(String(attributeCategory))
        )
        .replace(
          "{" + "attributeName" + "}",
          encodeURIComponent(String(attributeName))
        );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'attributeCategory' is not null or undefined
    if (attributeCategory === null || attributeCategory === undefined) {
      throw new Error(
        "Required parameter attributeCategory was null or undefined when calling deleteAttribute."
      );
    }

    // verify required parameter 'attributeName' is not null or undefined
    if (attributeName === null || attributeName === undefined) {
      throw new Error(
        "Required parameter attributeName was null or undefined when calling deleteAttribute."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a contact
   * @param identifier Email (urlencoded) OR ID of the contact
   * @param {*} [options] Override http request options.
   */
  public deleteContact(
    identifier: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/{identifier}".replace(
        "{" + "identifier" + "}",
        encodeURIComponent(String(identifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'identifier' is not null or undefined
    if (identifier === null || identifier === undefined) {
      throw new Error(
        "Required parameter identifier was null or undefined when calling deleteContact."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a folder (and all its lists)
   * @param folderId Id of the folder
   * @param {*} [options] Override http request options.
   */
  public deleteFolder(
    folderId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/folders/{folderId}".replace(
        "{" + "folderId" + "}",
        encodeURIComponent(String(folderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        "Required parameter folderId was null or undefined when calling deleteFolder."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a list
   * @param listId Id of the list
   * @param {*} [options] Override http request options.
   */
  public deleteList(
    listId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/lists/{listId}".replace(
        "{" + "listId" + "}",
        encodeURIComponent(String(listId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling deleteList."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary List all attributes
   * @param {*} [options] Override http request options.
   */
  public getAttributes(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetAttributes }> {
    const localVarPath = this.basePath + "/contacts/attributes";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetAttributes }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetAttributes");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Along with the contact details, this endpoint will show the statistics of contact for the recent 90 days by default. To fetch the earlier statistics, please use Get contact campaign stats (https://developers.brevo.com/reference/contacts-7#getcontactstats) endpoint with the appropriate date ranges.
   * @summary Get a contact's details
   * @param identifier Email (urlencoded) OR ID of the contact OR its SMS attribute value
   * @param startDate **Mandatory if endDate is used.** Starting date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be lower than equal to endDate
   * @param endDate **Mandatory if startDate is used.** Ending date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be greater than equal to startDate.
   * @param {*} [options] Override http request options.
   */
  public getContactInfo(
    identifier: string,
    startDate?: string,
    endDate?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetExtendedContactDetails;
  }> {
    const localVarPath =
      this.basePath +
      "/contacts/{identifier}".replace(
        "{" + "identifier" + "}",
        encodeURIComponent(String(identifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'identifier' is not null or undefined
    if (identifier === null || identifier === undefined) {
      throw new Error(
        "Required parameter identifier was null or undefined when calling getContactInfo."
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetExtendedContactDetails;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetExtendedContactDetails"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get email campaigns' statistics for a contact
   * @param identifier Email (urlencoded) OR ID of the contact
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be lower than equal to endDate
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the statistic events specific to campaigns. Must be greater than equal to startDate. Maximum difference between startDate and endDate should not be greater than 90 days
   * @param {*} [options] Override http request options.
   */
  public getContactStats(
    identifier: string,
    startDate?: string,
    endDate?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetContactCampaignStats;
  }> {
    const localVarPath =
      this.basePath +
      "/contacts/{identifier}/campaignStats".replace(
        "{" + "identifier" + "}",
        encodeURIComponent(String(identifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'identifier' is not null or undefined
    if (identifier === null || identifier === undefined) {
      throw new Error(
        "Required parameter identifier was null or undefined when calling getContactStats."
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetContactCampaignStats;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetContactCampaignStats");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all the contacts
   * @param limit Number of documents per page
   * @param offset Index of the first document of the page
   * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
   * @param createdSince Filter (urlencoded) the contacts created after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getContacts(
    limit?: number,
    offset?: number,
    modifiedSince?: string,
    createdSince?: string,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetContacts }> {
    const localVarPath = this.basePath + "/contacts";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (modifiedSince !== undefined) {
      localVarQueryParameters["modifiedSince"] = ObjectSerializer.serialize(
        modifiedSince,
        "string"
      );
    }

    if (createdSince !== undefined) {
      localVarQueryParameters["createdSince"] = ObjectSerializer.serialize(
        createdSince,
        "string"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetContacts }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetContacts");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get contacts in a list
   * @param listId Id of the list
   * @param modifiedSince Filter (urlencoded) the contacts modified after a given UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ). Prefer to pass your timezone in date-time format for accurate result.
   * @param limit Number of documents per page
   * @param offset Index of the first document of the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getContactsFromList(
    listId: number,
    modifiedSince?: string,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetContacts }> {
    const localVarPath =
      this.basePath +
      "/contacts/lists/{listId}/contacts".replace(
        "{" + "listId" + "}",
        encodeURIComponent(String(listId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling getContactsFromList."
      );
    }

    if (modifiedSince !== undefined) {
      localVarQueryParameters["modifiedSince"] = ObjectSerializer.serialize(
        modifiedSince,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetContacts }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetContacts");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Returns a folder's details
   * @param folderId id of the folder
   * @param {*} [options] Override http request options.
   */
  public getFolder(
    folderId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetFolder }> {
    const localVarPath =
      this.basePath +
      "/contacts/folders/{folderId}".replace(
        "{" + "folderId" + "}",
        encodeURIComponent(String(folderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        "Required parameter folderId was null or undefined when calling getFolder."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetFolder }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetFolder");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get lists in a folder
   * @param folderId Id of the folder
   * @param limit Number of documents per page
   * @param offset Index of the first document of the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getFolderLists(
    folderId: number,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetFolderLists }> {
    const localVarPath =
      this.basePath +
      "/contacts/folders/{folderId}/lists".replace(
        "{" + "folderId" + "}",
        encodeURIComponent(String(folderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        "Required parameter folderId was null or undefined when calling getFolderLists."
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetFolderLists;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetFolderLists");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all folders
   * @param limit Number of documents per page
   * @param offset Index of the first document of the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getFolders(
    limit: number,
    offset: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetFolders }> {
    const localVarPath = this.basePath + "/contacts/folders";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        "Required parameter limit was null or undefined when calling getFolders."
      );
    }

    // verify required parameter 'offset' is not null or undefined
    if (offset === null || offset === undefined) {
      throw new Error(
        "Required parameter offset was null or undefined when calling getFolders."
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetFolders }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetFolders");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a list's details
   * @param listId Id of the list
   * @param {*} [options] Override http request options.
   */
  public getList(
    listId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetExtendedList }> {
    const localVarPath =
      this.basePath +
      "/contacts/lists/{listId}".replace(
        "{" + "listId" + "}",
        encodeURIComponent(String(listId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling getList."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetExtendedList;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetExtendedList");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all the lists
   * @param limit Number of documents per page
   * @param offset Index of the first document of the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getLists(
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetLists }> {
    const localVarPath = this.basePath + "/contacts/lists";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetLists }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetLists");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get all the Segments
   * @param limit Number of documents per page
   * @param offset Index of the first document of the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getSegments(
    limit: number,
    offset: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSegments }> {
    const localVarPath = this.basePath + "/contacts/segments";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        "Required parameter limit was null or undefined when calling getSegments."
      );
    }

    // verify required parameter 'offset' is not null or undefined
    if (offset === null || offset === undefined) {
      throw new Error(
        "Required parameter offset was null or undefined when calling getSegments."
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetSegments }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetSegments");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * It returns the background process ID which on completion calls the notify URL that you have set in the input.
   * @summary Import contacts
   * @param requestContactImport Values to import contacts in Brevo. To know more about the expected format, please have a look at &#x60;&#x60;https://help.brevo.com/hc/en-us/articles/209499265-Build-contacts-lists-for-your-email-marketing-campaigns&#x60;&#x60;
   * @param {*} [options] Override http request options.
   */
  public importContacts(
    requestContactImport: RequestContactImport,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreatedProcessId }> {
    const localVarPath = this.basePath + "/contacts/import";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'requestContactImport' is not null or undefined
    if (requestContactImport === null || requestContactImport === undefined) {
      throw new Error(
        "Required parameter requestContactImport was null or undefined when calling importContacts."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        requestContactImport,
        "RequestContactImport"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreatedProcessId;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreatedProcessId");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Delete a contact from a list
   * @param listId Id of the list
   * @param contactEmails Emails addresses OR IDs of the contacts
   * @param {*} [options] Override http request options.
   */
  public removeContactFromList(
    listId: number,
    contactEmails: RemoveContactFromList,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: PostContactInfo }> {
    const localVarPath =
      this.basePath +
      "/contacts/lists/{listId}/contacts/remove".replace(
        "{" + "listId" + "}",
        encodeURIComponent(String(listId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling removeContactFromList."
      );
    }

    // verify required parameter 'contactEmails' is not null or undefined
    if (contactEmails === null || contactEmails === undefined) {
      throw new Error(
        "Required parameter contactEmails was null or undefined when calling removeContactFromList."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(contactEmails, "RemoveContactFromList"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: PostContactInfo;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "PostContactInfo");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * It returns the background process ID which on completion calls the notify URL that you have set in the input. File will be available in csv.
   * @summary Export contacts
   * @param requestContactExport Values to request a contact export
   * @param {*} [options] Override http request options.
   */
  public requestContactExport(
    requestContactExport: RequestContactExport,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreatedProcessId }> {
    const localVarPath = this.basePath + "/contacts/export";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'requestContactExport' is not null or undefined
    if (requestContactExport === null || requestContactExport === undefined) {
      throw new Error(
        "Required parameter requestContactExport was null or undefined when calling requestContactExport."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        requestContactExport,
        "RequestContactExport"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreatedProcessId;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreatedProcessId");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Update contact attribute
   * @param attributeCategory Category of the attribute
   * @param attributeName Name of the existing attribute
   * @param updateAttribute Values to update an attribute
   * @param {*} [options] Override http request options.
   */
  public updateAttribute(
    attributeCategory: "category" | "calculated" | "global",
    attributeName: string,
    updateAttribute: UpdateAttribute,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/attributes/{attributeCategory}/{attributeName}"
        .replace(
          "{" + "attributeCategory" + "}",
          encodeURIComponent(String(attributeCategory))
        )
        .replace(
          "{" + "attributeName" + "}",
          encodeURIComponent(String(attributeName))
        );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'attributeCategory' is not null or undefined
    if (attributeCategory === null || attributeCategory === undefined) {
      throw new Error(
        "Required parameter attributeCategory was null or undefined when calling updateAttribute."
      );
    }

    // verify required parameter 'attributeName' is not null or undefined
    if (attributeName === null || attributeName === undefined) {
      throw new Error(
        "Required parameter attributeName was null or undefined when calling updateAttribute."
      );
    }

    // verify required parameter 'updateAttribute' is not null or undefined
    if (updateAttribute === null || updateAttribute === undefined) {
      throw new Error(
        "Required parameter updateAttribute was null or undefined when calling updateAttribute."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateAttribute, "UpdateAttribute"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update multiple contacts
   * @param updateBatchContacts Values to update multiple contacts
   * @param {*} [options] Override http request options.
   */
  public updateBatchContacts(
    updateBatchContacts: UpdateBatchContacts,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/contacts/batch";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'updateBatchContacts' is not null or undefined
    if (updateBatchContacts === null || updateBatchContacts === undefined) {
      throw new Error(
        "Required parameter updateBatchContacts was null or undefined when calling updateBatchContacts."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateBatchContacts,
        "UpdateBatchContacts"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a contact
   * @param identifier Email (urlencoded) OR ID of the contact
   * @param updateContact Values to update a contact
   * @param {*} [options] Override http request options.
   */
  public updateContact(
    identifier: string,
    updateContact: UpdateContact,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/{identifier}".replace(
        "{" + "identifier" + "}",
        encodeURIComponent(String(identifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'identifier' is not null or undefined
    if (identifier === null || identifier === undefined) {
      throw new Error(
        "Required parameter identifier was null or undefined when calling updateContact."
      );
    }

    // verify required parameter 'updateContact' is not null or undefined
    if (updateContact === null || updateContact === undefined) {
      throw new Error(
        "Required parameter updateContact was null or undefined when calling updateContact."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateContact, "UpdateContact"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a folder
   * @param folderId Id of the folder
   * @param updateFolder Name of the folder
   * @param {*} [options] Override http request options.
   */
  public updateFolder(
    folderId: number,
    updateFolder: CreateUpdateFolder,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/folders/{folderId}".replace(
        "{" + "folderId" + "}",
        encodeURIComponent(String(folderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'folderId' is not null or undefined
    if (folderId === null || folderId === undefined) {
      throw new Error(
        "Required parameter folderId was null or undefined when calling updateFolder."
      );
    }

    // verify required parameter 'updateFolder' is not null or undefined
    if (updateFolder === null || updateFolder === undefined) {
      throw new Error(
        "Required parameter updateFolder was null or undefined when calling updateFolder."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateFolder, "CreateUpdateFolder"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a list
   * @param listId Id of the list
   * @param updateList Values to update a list
   * @param {*} [options] Override http request options.
   */
  public updateList(
    listId: number,
    updateList: UpdateList,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/contacts/lists/{listId}".replace(
        "{" + "listId" + "}",
        encodeURIComponent(String(listId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'listId' is not null or undefined
    if (listId === null || listId === undefined) {
      throw new Error(
        "Required parameter listId was null or undefined when calling updateList."
      );
    }

    // verify required parameter 'updateList' is not null or undefined
    if (updateList === null || updateList === undefined) {
      throw new Error(
        "Required parameter updateList was null or undefined when calling updateList."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateList, "UpdateList"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ConversationsApiApiKeys {
  apiKey,
  partnerKey,
}

export class ConversationsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ConversationsApiApiKeys, value: string) {
    (this.authentications as any)[ConversationsApiApiKeys[key]].apiKey = value;
  }
  /**
   * We recommend pinging this endpoint every minute for as long as the agent has to be considered online.
   * @summary Sets agent’s status to online for 2-3 minutes
   * @param body Agent fields.
   * @param {*} [options] Override http request options.
   */
  public conversationsAgentOnlinePingPost(
    body: Body12,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/conversations/agentOnlinePing";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling conversationsAgentOnlinePingPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body12"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Only agents’ messages can be deleted.
   * @summary Delete a message sent by an agent
   * @param id ID of the message
   * @param {*} [options] Override http request options.
   */
  public conversationsMessagesIdDelete(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/conversations/messages/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling conversationsMessagesIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a message
   * @param id ID of the message
   * @param {*} [options] Override http request options.
   */
  public conversationsMessagesIdGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: ConversationsMessage }> {
    const localVarPath =
      this.basePath +
      "/conversations/messages/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling conversationsMessagesIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: ConversationsMessage;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ConversationsMessage");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Only agents’ messages can be edited.
   * @summary Update a message sent by an agent
   * @param id ID of the message
   * @param body
   * @param {*} [options] Override http request options.
   */
  public conversationsMessagesIdPut(
    id: string,
    body?: Body9,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: ConversationsMessage }> {
    const localVarPath =
      this.basePath +
      "/conversations/messages/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling conversationsMessagesIdPut."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body9"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: ConversationsMessage;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ConversationsMessage");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Send a message as an agent
   * @param body Message fields.
   * @param {*} [options] Override http request options.
   */
  public conversationsMessagesPost(
    body: Body8,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: ConversationsMessage }> {
    const localVarPath = this.basePath + "/conversations/messages";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling conversationsMessagesPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body8"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: ConversationsMessage;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ConversationsMessage");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Delete an automated message
   * @param id ID of the message
   * @param {*} [options] Override http request options.
   */
  public conversationsPushedMessagesIdDelete(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/conversations/pushedMessages/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling conversationsPushedMessagesIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get an automated message
   * @param id ID of the message sent previously
   * @param {*} [options] Override http request options.
   */
  public conversationsPushedMessagesIdGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: ConversationsMessage }> {
    const localVarPath =
      this.basePath +
      "/conversations/pushedMessages/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling conversationsPushedMessagesIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: ConversationsMessage;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ConversationsMessage");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Update an automated message
   * @param id ID of the message
   * @param body
   * @param {*} [options] Override http request options.
   */
  public conversationsPushedMessagesIdPut(
    id: string,
    body: Body11,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: ConversationsMessage }> {
    const localVarPath =
      this.basePath +
      "/conversations/pushedMessages/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling conversationsPushedMessagesIdPut."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling conversationsPushedMessagesIdPut."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body11"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: ConversationsMessage;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ConversationsMessage");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Example of automated messages: order status, announce new features in your web app, etc.
   * @summary Send an automated message to a visitor
   * @param body
   * @param {*} [options] Override http request options.
   */
  public conversationsPushedMessagesPost(
    body: Body10,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: ConversationsMessage }> {
    const localVarPath = this.basePath + "/conversations/pushedMessages";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling conversationsPushedMessagesPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body10"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: ConversationsMessage;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "ConversationsMessage");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum DealsApiApiKeys {
  apiKey,
  partnerKey,
}

export class DealsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DealsApiApiKeys, value: string) {
    (this.authentications as any)[DealsApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get deal attributes
   * @param {*} [options] Override http request options.
   */
  public crmAttributesDealsGet(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: DealAttributes }> {
    const localVarPath = this.basePath + "/crm/attributes/deals";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: DealAttributes;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "DealAttributes");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all deals
   * @param filtersAttributes Filter by attrbutes. If you have filter for owner on your side please send it as &#x60;attributes.owner&#x60;.\&quot;
   * @param filtersLinkedCompaniesIds Filter by linked companies ids
   * @param filtersLinkedContactsIds Filter by linked companies ids
   * @param offset Index of the first document of the page
   * @param limit Number of documents per page
   * @param sort Sort the results in the ascending/descending order. Default order is **descending** by creation if &#x60;sort&#x60; is not passed
   * @param sortBy The field used to sort field names.
   * @param {*} [options] Override http request options.
   */
  public crmDealsGet(
    filtersAttributes?: string,
    filtersLinkedCompaniesIds?: string,
    filtersLinkedContactsIds?: string,
    offset?: number,
    limit?: number,
    sort?: "asc" | "desc",
    sortBy?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: DealsList }> {
    const localVarPath = this.basePath + "/crm/deals";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (filtersAttributes !== undefined) {
      localVarQueryParameters["filters[attributes]"] =
        ObjectSerializer.serialize(filtersAttributes, "string");
    }

    if (filtersLinkedCompaniesIds !== undefined) {
      localVarQueryParameters["filters[linkedCompaniesIds]"] =
        ObjectSerializer.serialize(filtersLinkedCompaniesIds, "string");
    }

    if (filtersLinkedContactsIds !== undefined) {
      localVarQueryParameters["filters[linkedContactsIds]"] =
        ObjectSerializer.serialize(filtersLinkedContactsIds, "string");
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
        sortBy,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: DealsList }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "DealsList");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a deal
   * @param id
   * @param {*} [options] Override http request options.
   */
  public crmDealsIdDelete(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/deals/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmDealsIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a deal
   * @param id
   * @param {*} [options] Override http request options.
   */
  public crmDealsIdGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Deal }> {
    const localVarPath =
      this.basePath +
      "/crm/deals/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmDealsIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Deal }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Deal");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a deal
   * @param id
   * @param body Updated deal details.
   * @param {*} [options] Override http request options.
   */
  public crmDealsIdPatch(
    id: string,
    body: Body4,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/deals/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmDealsIdPatch."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling crmDealsIdPatch."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body4"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Link and Unlink a deal with contacts and companies
   * @param id
   * @param body Linked / Unlinked contacts and companies ids.
   * @param {*} [options] Override http request options.
   */
  public crmDealsLinkUnlinkIdPatch(
    id: string,
    body: Body5,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/deals/link-unlink/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmDealsLinkUnlinkIdPatch."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling crmDealsLinkUnlinkIdPatch."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body5"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a deal
   * @param body Deal create data.
   * @param {*} [options] Override http request options.
   */
  public crmDealsPost(
    body: Body3,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse201 }> {
    const localVarPath = this.basePath + "/crm/deals";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling crmDealsPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body3"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse201;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse201");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get pipeline stages
   * @param {*} [options] Override http request options.
   */
  public crmPipelineDetailsGet(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Pipeline }> {
    const localVarPath = this.basePath + "/crm/pipeline/details";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Pipeline }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Pipeline");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum DomainsApiApiKeys {
  apiKey,
  partnerKey,
}

export class DomainsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DomainsApiApiKeys, value: string) {
    (this.authentications as any)[DomainsApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Authenticate a domain
   * @param domainName Domain name
   * @param {*} [options] Override http request options.
   */
  public authenticateDomain(
    domainName: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: AuthenticateDomainModel;
  }> {
    const localVarPath =
      this.basePath +
      "/senders/domains/{domainName}/authenticate".replace(
        "{" + "domainName" + "}",
        encodeURIComponent(String(domainName))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling authenticateDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AuthenticateDomainModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AuthenticateDomainModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create a new domain
   * @param domainName domain&#39;s name
   * @param {*} [options] Override http request options.
   */
  public createDomain(
    domainName?: CreateDomain,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateDomainModel }> {
    const localVarPath = this.basePath + "/senders/domains";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(domainName, "CreateDomain"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateDomainModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateDomainModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Delete a domain
   * @param domainName Domain name
   * @param {*} [options] Override http request options.
   */
  public deleteDomain(
    domainName: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/senders/domains/{domainName}".replace(
        "{" + "domainName" + "}",
        encodeURIComponent(String(domainName))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling deleteDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Validate domain configuration
   * @param domainName Domain name
   * @param {*} [options] Override http request options.
   */
  public getDomainonfiguration(
    domainName: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetDomainonfigurationModel;
  }> {
    const localVarPath =
      this.basePath +
      "/senders/domains/{domainName}".replace(
        "{" + "domainName" + "}",
        encodeURIComponent(String(domainName))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling getDomainonfiguration."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetDomainonfigurationModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetDomainonfigurationModel"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the list of all your domains
   * @param {*} [options] Override http request options.
   */
  public getDomains(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetDomainsList }> {
    const localVarPath = this.basePath + "/senders/domains";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetDomainsList;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetDomainsList");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum EcommerceApiApiKeys {
  apiKey,
  partnerKey,
}

export class EcommerceApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: EcommerceApiApiKeys, value: string) {
    (this.authentications as any)[EcommerceApiApiKeys[key]].apiKey = value;
  }
  /**
   * Create multiple orders at one time instead of one order at a time
   * @summary Create orders in batch
   * @param orderBatch
   * @param {*} [options] Override http request options.
   */
  public createBatchOrder(
    orderBatch: OrderBatch,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/orders/status/batch";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'orderBatch' is not null or undefined
    if (orderBatch === null || orderBatch === undefined) {
      throw new Error(
        "Required parameter orderBatch was null or undefined when calling createBatchOrder."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(orderBatch, "OrderBatch"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Manages the transactional status of the order
   * @summary Managing the status of the order
   * @param order
   * @param {*} [options] Override http request options.
   */
  public createOrder(
    order: Order,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/orders/status";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'order' is not null or undefined
    if (order === null || order === undefined) {
      throw new Error(
        "Required parameter order was null or undefined when calling createOrder."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(order, "Order"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create categories in batch
   * @param createUpdateBatchCategory Values to create a batch of categories
   * @param {*} [options] Override http request options.
   */
  public createUpdateBatchCategory(
    createUpdateBatchCategory: CreateUpdateBatchCategory,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateUpdateBatchCategoryModel;
  }> {
    const localVarPath = this.basePath + "/categories/batch";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createUpdateBatchCategory' is not null or undefined
    if (
      createUpdateBatchCategory === null ||
      createUpdateBatchCategory === undefined
    ) {
      throw new Error(
        "Required parameter createUpdateBatchCategory was null or undefined when calling createUpdateBatchCategory."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createUpdateBatchCategory,
        "CreateUpdateBatchCategory"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateUpdateBatchCategoryModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "CreateUpdateBatchCategoryModel"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create products in batch
   * @param createUpdateBatchProducts Values to create a batch of products
   * @param {*} [options] Override http request options.
   */
  public createUpdateBatchProducts(
    createUpdateBatchProducts: CreateUpdateBatchProducts,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateUpdateBatchProductsModel;
  }> {
    const localVarPath = this.basePath + "/products/batch";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createUpdateBatchProducts' is not null or undefined
    if (
      createUpdateBatchProducts === null ||
      createUpdateBatchProducts === undefined
    ) {
      throw new Error(
        "Required parameter createUpdateBatchProducts was null or undefined when calling createUpdateBatchProducts."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createUpdateBatchProducts,
        "CreateUpdateBatchProducts"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateUpdateBatchProductsModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "CreateUpdateBatchProductsModel"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create/Update a category
   * @param createUpdateCategory Values to create/update a category
   * @param {*} [options] Override http request options.
   */
  public createUpdateCategory(
    createUpdateCategory: CreateUpdateCategory,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateCategoryModel }> {
    const localVarPath = this.basePath + "/categories";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createUpdateCategory' is not null or undefined
    if (createUpdateCategory === null || createUpdateCategory === undefined) {
      throw new Error(
        "Required parameter createUpdateCategory was null or undefined when calling createUpdateCategory."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createUpdateCategory,
        "CreateUpdateCategory"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateCategoryModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateCategoryModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Create/Update a product
   * @param createUpdateProduct Values to create/update a product
   * @param {*} [options] Override http request options.
   */
  public createUpdateProduct(
    createUpdateProduct: CreateUpdateProduct,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateProductModel }> {
    const localVarPath = this.basePath + "/products";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createUpdateProduct' is not null or undefined
    if (createUpdateProduct === null || createUpdateProduct === undefined) {
      throw new Error(
        "Required parameter createUpdateProduct was null or undefined when calling createUpdateProduct."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createUpdateProduct,
        "CreateUpdateProduct"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateProductModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateProductModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Getting access to Brevo eCommerce.
   * @summary Activate the eCommerce app
   * @param {*} [options] Override http request options.
   */
  public ecommerceActivatePost(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/ecommerce/activate";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Return all your categories
   * @param limit Number of documents per page
   * @param offset Index of the first document in the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param ids Filter by category ids
   * @param name Filter by category name
   * @param {*} [options] Override http request options.
   */
  public getCategories(
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    ids?: Array<string>,
    name?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetCategories }> {
    const localVarPath = this.basePath + "/categories";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (ids !== undefined) {
      localVarQueryParameters["ids"] = ObjectSerializer.serialize(
        ids,
        "Array<string>"
      );
    }

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetCategories }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetCategories");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a category details
   * @param id Category ID
   * @param {*} [options] Override http request options.
   */
  public getCategoryInfo(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetCategoryDetails }> {
    const localVarPath =
      this.basePath +
      "/categories/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getCategoryInfo."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetCategoryDetails;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetCategoryDetails");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get a product's details
   * @param id Product ID
   * @param {*} [options] Override http request options.
   */
  public getProductInfo(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetProductDetails }> {
    const localVarPath =
      this.basePath +
      "/products/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling getProductInfo."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetProductDetails;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetProductDetails");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Return all your products
   * @param limit Number of documents per page
   * @param offset Index of the first document in the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param ids Filter by product ids
   * @param name Filter by product name, minimum 3 characters should be present for search
   * @param priceLte Price filter for products less than and equals to particular amount
   * @param priceGte Price filter for products greater than and equals to particular amount
   * @param priceLt Price filter for products less than particular amount
   * @param priceGt Price filter for products greater than particular amount
   * @param priceEq Price filter for products equals to particular amount
   * @param priceNe Price filter for products not equals to particular amount
   * @param categories Filter by category ids
   * @param {*} [options] Override http request options.
   */
  public getProducts(
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    ids?: Array<string>,
    name?: string,
    priceLte?: number,
    priceGte?: number,
    priceLt?: number,
    priceGt?: number,
    priceEq?: number,
    priceNe?: number,
    categories?: Array<string>,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetProducts }> {
    const localVarPath = this.basePath + "/products";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (ids !== undefined) {
      localVarQueryParameters["ids"] = ObjectSerializer.serialize(
        ids,
        "Array<string>"
      );
    }

    if (name !== undefined) {
      localVarQueryParameters["name"] = ObjectSerializer.serialize(
        name,
        "string"
      );
    }

    if (priceLte !== undefined) {
      localVarQueryParameters["price[lte]"] = ObjectSerializer.serialize(
        priceLte,
        "number"
      );
    }

    if (priceGte !== undefined) {
      localVarQueryParameters["price[gte]"] = ObjectSerializer.serialize(
        priceGte,
        "number"
      );
    }

    if (priceLt !== undefined) {
      localVarQueryParameters["price[lt]"] = ObjectSerializer.serialize(
        priceLt,
        "number"
      );
    }

    if (priceGt !== undefined) {
      localVarQueryParameters["price[gt]"] = ObjectSerializer.serialize(
        priceGt,
        "number"
      );
    }

    if (priceEq !== undefined) {
      localVarQueryParameters["price[eq]"] = ObjectSerializer.serialize(
        priceEq,
        "number"
      );
    }

    if (priceNe !== undefined) {
      localVarQueryParameters["price[ne]"] = ObjectSerializer.serialize(
        priceNe,
        "number"
      );
    }

    if (categories !== undefined) {
      localVarQueryParameters["categories"] = ObjectSerializer.serialize(
        categories,
        "Array<string>"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetProducts }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetProducts");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum EmailCampaignsApiApiKeys {
  apiKey,
  partnerKey,
}

export class EmailCampaignsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: EmailCampaignsApiApiKeys, value: string) {
    (this.authentications as any)[EmailCampaignsApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Create an email campaign
   * @param emailCampaigns Values to create a campaign
   * @param {*} [options] Override http request options.
   */
  public createEmailCampaign(
    emailCampaigns: CreateEmailCampaign,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/emailCampaigns";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'emailCampaigns' is not null or undefined
    if (emailCampaigns === null || emailCampaigns === undefined) {
      throw new Error(
        "Required parameter emailCampaigns was null or undefined when calling createEmailCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(emailCampaigns, "CreateEmailCampaign"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete an email campaign
   * @param campaignId id of the campaign
   * @param {*} [options] Override http request options.
   */
  public deleteEmailCampaign(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling deleteEmailCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Export the recipients of an email campaign
   * @param campaignId Id of the campaign
   * @param recipientExport Values to send for a recipient export request
   * @param {*} [options] Override http request options.
   */
  public emailExportRecipients(
    campaignId: number,
    recipientExport?: EmailExportRecipients,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreatedProcessId }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}/exportRecipients".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling emailExportRecipients."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        recipientExport,
        "EmailExportRecipients"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreatedProcessId;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreatedProcessId");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Obtain winning version of an A/B test email campaign
   * @summary Get an A/B test email campaign results
   * @param campaignId Id of the A/B test campaign
   * @param {*} [options] Override http request options.
   */
  public getAbTestCampaignResult(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: AbTestCampaignResult }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}/abTestCampaignResult".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling getAbTestCampaignResult."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: AbTestCampaignResult;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "AbTestCampaignResult");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get an email campaign report
   * @param campaignId Id of the campaign
   * @param statistics Filter on the type of statistics required. Example **globalStats** value will only fetch globalStats info of the campaign in returned response.
   * @param {*} [options] Override http request options.
   */
  public getEmailCampaign(
    campaignId: number,
    statistics?:
      | "globalStats"
      | "linksStats"
      | "statsByDomain"
      | "statsByDevice"
      | "statsByBrowser",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetEmailCampaign }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling getEmailCampaign."
      );
    }

    if (statistics !== undefined) {
      localVarQueryParameters["statistics"] = ObjectSerializer.serialize(
        statistics,
        "'globalStats' | 'linksStats' | 'statsByDomain' | 'statsByDevice' | 'statsByBrowser'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetEmailCampaign;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetEmailCampaign");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Return all your created email campaigns
   * @param type Filter on the type of the campaigns
   * @param status Filter on the status of the campaign
   * @param statistics Filter on the type of statistics required. Example **globalStats** value will only fetch globalStats info of the campaign in returned response.
   * @param startDate Mandatory if endDate is used. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
   * @param endDate Mandatory if startDate is used. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent email campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
   * @param limit Number of documents per page
   * @param offset Index of the first document in the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param excludeHtmlContent Use this flag to exclude htmlContent from the response body. If set to **true**, htmlContent field will be returned as empty string in the response body
   * @param {*} [options] Override http request options.
   */
  public getEmailCampaigns(
    type?: "classic" | "trigger",
    status?:
      | "suspended"
      | "archive"
      | "sent"
      | "queued"
      | "draft"
      | "inProcess",
    statistics?: "globalStats" | "linksStats" | "statsByDomain",
    startDate?: string,
    endDate?: string,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    excludeHtmlContent?: boolean,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetEmailCampaigns }> {
    const localVarPath = this.basePath + "/emailCampaigns";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (type !== undefined) {
      localVarQueryParameters["type"] = ObjectSerializer.serialize(
        type,
        "'classic' | 'trigger'"
      );
    }

    if (status !== undefined) {
      localVarQueryParameters["status"] = ObjectSerializer.serialize(
        status,
        "'suspended' | 'archive' | 'sent' | 'queued' | 'draft' | 'inProcess'"
      );
    }

    if (statistics !== undefined) {
      localVarQueryParameters["statistics"] = ObjectSerializer.serialize(
        statistics,
        "'globalStats' | 'linksStats' | 'statsByDomain'"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (excludeHtmlContent !== undefined) {
      localVarQueryParameters["excludeHtmlContent"] =
        ObjectSerializer.serialize(excludeHtmlContent, "boolean");
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetEmailCampaigns;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetEmailCampaigns");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get a unique URL to share & import an email template from one Brevo account to another.
   * @summary Get a shared template url
   * @param campaignId Id of the campaign or template
   * @param {*} [options] Override http request options.
   */
  public getSharedTemplateUrl(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSharedTemplateUrl }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}/sharedUrl".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling getSharedTemplateUrl."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetSharedTemplateUrl;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSharedTemplateUrl");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Send an email campaign immediately, based on campaignId
   * @param campaignId Id of the campaign
   * @param {*} [options] Override http request options.
   */
  public sendEmailCampaignNow(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}/sendNow".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling sendEmailCampaignNow."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * A PDF will be sent to the specified email addresses
   * @summary Send the report of a campaign
   * @param campaignId Id of the campaign
   * @param sendReport Values for send a report
   * @param {*} [options] Override http request options.
   */
  public sendReport(
    campaignId: number,
    sendReport: SendReport,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}/sendReport".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling sendReport."
      );
    }

    // verify required parameter 'sendReport' is not null or undefined
    if (sendReport === null || sendReport === undefined) {
      throw new Error(
        "Required parameter sendReport was null or undefined when calling sendReport."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(sendReport, "SendReport"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Send an email campaign to your test list
   * @param campaignId Id of the campaign
   * @param emailTo
   * @param {*} [options] Override http request options.
   */
  public sendTestEmail(
    campaignId: number,
    emailTo: SendTestEmail,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}/sendTest".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling sendTestEmail."
      );
    }

    // verify required parameter 'emailTo' is not null or undefined
    if (emailTo === null || emailTo === undefined) {
      throw new Error(
        "Required parameter emailTo was null or undefined when calling sendTestEmail."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(emailTo, "SendTestEmail"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update an email campaign status
   * @param campaignId Id of the campaign
   * @param status Status of the campaign
   * @param {*} [options] Override http request options.
   */
  public updateCampaignStatus(
    campaignId: number,
    status: UpdateCampaignStatus,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}/status".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling updateCampaignStatus."
      );
    }

    // verify required parameter 'status' is not null or undefined
    if (status === null || status === undefined) {
      throw new Error(
        "Required parameter status was null or undefined when calling updateCampaignStatus."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(status, "UpdateCampaignStatus"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update an email campaign
   * @param campaignId Id of the campaign
   * @param emailCampaign Values to update a campaign
   * @param {*} [options] Override http request options.
   */
  public updateEmailCampaign(
    campaignId: number,
    emailCampaign: UpdateEmailCampaign,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/emailCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling updateEmailCampaign."
      );
    }

    // verify required parameter 'emailCampaign' is not null or undefined
    if (emailCampaign === null || emailCampaign === undefined) {
      throw new Error(
        "Required parameter emailCampaign was null or undefined when calling updateEmailCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(emailCampaign, "UpdateEmailCampaign"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Upload an image to your account's image gallery
   * @param uploadImage Parameters to upload an image
   * @param {*} [options] Override http request options.
   */
  public uploadImageToGallery(
    uploadImage: UploadImageToGallery,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: UploadImageModel }> {
    const localVarPath = this.basePath + "/emailCampaigns/images";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'uploadImage' is not null or undefined
    if (uploadImage === null || uploadImage === undefined) {
      throw new Error(
        "Required parameter uploadImage was null or undefined when calling uploadImageToGallery."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(uploadImage, "UploadImageToGallery"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: UploadImageModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "UploadImageModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum ExternalFeedsApiApiKeys {
  apiKey,
  partnerKey,
}

export class ExternalFeedsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ExternalFeedsApiApiKeys, value: string) {
    (this.authentications as any)[ExternalFeedsApiApiKeys[key]].apiKey = value;
  }
  /**
   * This endpoint will create an external feed.
   * @summary Create an external feed
   * @param createExternalFeed Values to create a feed
   * @param {*} [options] Override http request options.
   */
  public createExternalFeed(
    createExternalFeed: CreateExternalFeed,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse2013 }> {
    const localVarPath = this.basePath + "/feeds";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createExternalFeed' is not null or undefined
    if (createExternalFeed === null || createExternalFeed === undefined) {
      throw new Error(
        "Required parameter createExternalFeed was null or undefined when calling createExternalFeed."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createExternalFeed,
        "CreateExternalFeed"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse2013;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse2013");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will delete an external feed.
   * @summary Delete an external feed
   * @param uuid UUID of the feed to delete
   * @param {*} [options] Override http request options.
   */
  public deleteExternalFeed(
    uuid: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/feeds/{uuid}".replace(
        "{" + "uuid" + "}",
        encodeURIComponent(String(uuid))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'uuid' is not null or undefined
    if (uuid === null || uuid === undefined) {
      throw new Error(
        "Required parameter uuid was null or undefined when calling deleteExternalFeed."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This endpoint can fetch all created external feeds.
   * @summary Fetch all external feeds
   * @param search Can be used to filter records by search keyword on feed name
   * @param startDate Mandatory if &#x60;endDate&#x60; is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Can be maximum 30 days older than current date.
   * @param endDate Mandatory if &#x60;startDate&#x60; is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed.
   * @param authType Filter the records by &#x60;authType&#x60; of the feed.
   * @param limit Number of documents returned per page.
   * @param offset Index of the first document on the page.
   * @param {*} [options] Override http request options.
   */
  public getAllExternalFeeds(
    search?: string,
    startDate?: string,
    endDate?: string,
    sort?: "asc" | "desc",
    authType?: "basic" | "token" | "noAuth",
    limit?: number,
    offset?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetAllExternalFeeds }> {
    const localVarPath = this.basePath + "/feeds";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (search !== undefined) {
      localVarQueryParameters["search"] = ObjectSerializer.serialize(
        search,
        "string"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (authType !== undefined) {
      localVarQueryParameters["authType"] = ObjectSerializer.serialize(
        authType,
        "'basic' | 'token' | 'noAuth'"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetAllExternalFeeds;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetAllExternalFeeds");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will update an external feed.
   * @summary Get an external feed by UUID
   * @param uuid UUID of the feed to fetch
   * @param {*} [options] Override http request options.
   */
  public getExternalFeedByUUID(
    uuid: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetExternalFeedByUUID }> {
    const localVarPath =
      this.basePath +
      "/feeds/{uuid}".replace(
        "{" + "uuid" + "}",
        encodeURIComponent(String(uuid))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'uuid' is not null or undefined
    if (uuid === null || uuid === undefined) {
      throw new Error(
        "Required parameter uuid was null or undefined when calling getExternalFeedByUUID."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetExternalFeedByUUID;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetExternalFeedByUUID");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will update an external feed.
   * @summary Update an external feed
   * @param uuid UUID of the feed to update
   * @param updateExternalFeed Values to update a feed
   * @param {*} [options] Override http request options.
   */
  public updateExternalFeed(
    uuid: string,
    updateExternalFeed: UpdateExternalFeed,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/feeds/{uuid}".replace(
        "{" + "uuid" + "}",
        encodeURIComponent(String(uuid))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'uuid' is not null or undefined
    if (uuid === null || uuid === undefined) {
      throw new Error(
        "Required parameter uuid was null or undefined when calling updateExternalFeed."
      );
    }

    // verify required parameter 'updateExternalFeed' is not null or undefined
    if (updateExternalFeed === null || updateExternalFeed === undefined) {
      throw new Error(
        "Required parameter updateExternalFeed was null or undefined when calling updateExternalFeed."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateExternalFeed,
        "UpdateExternalFeed"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum FilesApiApiKeys {
  apiKey,
  partnerKey,
}

export class FilesApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: FilesApiApiKeys, value: string) {
    (this.authentications as any)[FilesApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get all files
   * @param entity Filter by file entity type
   * @param entityIds Filter by file entity IDs
   * @param dateFrom dateFrom to date range filter type (timestamp in milliseconds)
   * @param dateTo dateTo to date range filter type (timestamp in milliseconds)
   * @param offset Index of the first document of the page
   * @param limit Number of documents per page
   * @param sort Sort the results in the ascending/descending order. Default order is **descending** by creation if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public crmFilesGet(
    entity?: "companies" | "deals" | "contacts",
    entityIds?: string,
    dateFrom?: number,
    dateTo?: number,
    offset?: number,
    limit?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: FileList }> {
    const localVarPath = this.basePath + "/crm/files";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (entity !== undefined) {
      localVarQueryParameters["entity"] = ObjectSerializer.serialize(
        entity,
        "'companies' | 'deals' | 'contacts'"
      );
    }

    if (entityIds !== undefined) {
      localVarQueryParameters["entityIds"] = ObjectSerializer.serialize(
        entityIds,
        "string"
      );
    }

    if (dateFrom !== undefined) {
      localVarQueryParameters["dateFrom"] = ObjectSerializer.serialize(
        dateFrom,
        "number"
      );
    }

    if (dateTo !== undefined) {
      localVarQueryParameters["dateTo"] = ObjectSerializer.serialize(
        dateTo,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: FileList }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "FileList");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get file details
   * @param id File id to get file data.
   * @param {*} [options] Override http request options.
   */
  public crmFilesIdDataGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: FileData }> {
    const localVarPath =
      this.basePath +
      "/crm/files/{id}/data".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmFilesIdDataGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: FileData }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "FileData");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a file
   * @param id File id to delete.
   * @param {*} [options] Override http request options.
   */
  public crmFilesIdDelete(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/files/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmFilesIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Download a file
   * @param id File id to download.
   * @param {*} [options] Override http request options.
   */
  public crmFilesIdGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: FileDownloadableLink }> {
    const localVarPath =
      this.basePath +
      "/crm/files/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmFilesIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: FileDownloadableLink;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "FileDownloadableLink");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Upload a file
   * @param file File data to create a file.
   * @param dealId Deal id linked to a file
   * @param contactId Contact id linked to a file
   * @param companyId Company id linked to a file
   * @param {*} [options] Override http request options.
   */
  public crmFilesPost(
    file: Buffer,
    dealId?: string,
    contactId?: number,
    companyId?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: FileData }> {
    const localVarPath = this.basePath + "/crm/files";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'file' is not null or undefined
    if (file === null || file === undefined) {
      throw new Error(
        "Required parameter file was null or undefined when calling crmFilesPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    if (file !== undefined) {
      localVarFormParams["file"] = file;
    }
    localVarUseFormData = true;

    if (dealId !== undefined) {
      localVarFormParams["dealId"] = ObjectSerializer.serialize(
        dealId,
        "string"
      );
    }

    if (contactId !== undefined) {
      localVarFormParams["contactId"] = ObjectSerializer.serialize(
        contactId,
        "number"
      );
    }

    if (companyId !== undefined) {
      localVarFormParams["companyId"] = ObjectSerializer.serialize(
        companyId,
        "string"
      );
    }

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: FileData }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "FileData");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum InboundParsingApiApiKeys {
  apiKey,
  partnerKey,
}

export class InboundParsingApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: InboundParsingApiApiKeys, value: string) {
    (this.authentications as any)[InboundParsingApiApiKeys[key]].apiKey = value;
  }
  /**
   * This endpoint will retrieve inbound attachment with download token.
   * @summary Retrieve inbound attachment with download token.
   * @param downloadToken Token to fetch a particular attachment
   * @param {*} [options] Override http request options.
   */
  public getInboundEmailAttachment(
    downloadToken: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Buffer }> {
    const localVarPath =
      this.basePath +
      "/inbound/attachments/{downloadToken}".replace(
        "{" + "downloadToken" + "}",
        encodeURIComponent(String(downloadToken))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'downloadToken' is not null or undefined
    if (downloadToken === null || downloadToken === undefined) {
      throw new Error(
        "Required parameter downloadToken was null or undefined when calling getInboundEmailAttachment."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      encoding: null,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Buffer }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Buffer");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This endpoint will show the list of all the events for the received emails.
   * @summary Get the list of all the events for the received emails.
   * @param sender Email address of the sender.
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss.SSSZ) from which you want to fetch the list. Maximum time period that can be selected is one month.
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss.SSSZ) till which you want to fetch the list. Maximum time period that can be selected is one month.
   * @param limit Number of documents returned per page
   * @param offset Index of the first document on the page
   * @param sort Sort the results in the ascending/descending order of record creation
   * @param {*} [options] Override http request options.
   */
  public getInboundEmailEvents(
    sender?: string,
    startDate?: string,
    endDate?: string,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetInboundEmailEvents }> {
    const localVarPath = this.basePath + "/inbound/events";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (sender !== undefined) {
      localVarQueryParameters["sender"] = ObjectSerializer.serialize(
        sender,
        "string"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetInboundEmailEvents;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetInboundEmailEvents");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will show the list of all events history for one particular received email.
   * @summary Fetch all events history for one particular received email.
   * @param uuid UUID to fetch events specific to recieved email
   * @param {*} [options] Override http request options.
   */
  public getInboundEmailEventsByUuid(
    uuid: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetInboundEmailEventsByUuid;
  }> {
    const localVarPath =
      this.basePath +
      "/inbound/events/{uuid}".replace(
        "{" + "uuid" + "}",
        encodeURIComponent(String(uuid))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'uuid' is not null or undefined
    if (uuid === null || uuid === undefined) {
      throw new Error(
        "Required parameter uuid was null or undefined when calling getInboundEmailEventsByUuid."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetInboundEmailEventsByUuid;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetInboundEmailEventsByUuid"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum MasterAccountApiApiKeys {
  apiKey,
  partnerKey,
}

export class MasterAccountApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: MasterAccountApiApiKeys, value: string) {
    (this.authentications as any)[MasterAccountApiApiKeys[key]].apiKey = value;
  }
  /**
   * This endpoint will provide the details of the master account.
   * @summary Get the details of requested master account
   * @param {*} [options] Override http request options.
   */
  public corporateMasterAccountGet(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: MasterDetailsResponse }> {
    const localVarPath = this.basePath + "/corporate/masterAccount";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: MasterDetailsResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "MasterDetailsResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will provide the list all the sub-accounts of the master account.
   * @summary Get the list of all the sub-accounts of the master account.
   * @param offset Index of the first sub-account in the page
   * @param limit Number of sub-accounts to be displayed on each page
   * @param {*} [options] Override http request options.
   */
  public corporateSubAccountGet(
    offset: number,
    limit: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: SubAccountsResponse }> {
    const localVarPath = this.basePath + "/corporate/subAccount";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'offset' is not null or undefined
    if (offset === null || offset === undefined) {
      throw new Error(
        "Required parameter offset was null or undefined when calling corporateSubAccountGet."
      );
    }

    // verify required parameter 'limit' is not null or undefined
    if (limit === null || limit === undefined) {
      throw new Error(
        "Required parameter limit was null or undefined when calling corporateSubAccountGet."
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: SubAccountsResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "SubAccountsResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Delete a sub-account
   * @param id Id of the sub-account organization to be deleted
   * @param {*} [options] Override http request options.
   */
  public corporateSubAccountIdDelete(
    id: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/corporate/subAccount/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling corporateSubAccountIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This endpoint will provide the details for the specified sub-account company
   * @summary Get sub-account details
   * @param id Id of the sub-account organization
   * @param {*} [options] Override http request options.
   */
  public corporateSubAccountIdGet(
    id: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: SubAccountDetailsResponse;
  }> {
    const localVarPath =
      this.basePath +
      "/corporate/subAccount/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling corporateSubAccountIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: SubAccountDetailsResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "SubAccountDetailsResponse"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will update the sub-account plan
   * @summary Update sub-account plan
   * @param id Id of the sub-account organization
   * @param updatePlanDetails Values to update a sub-account plan
   * @param {*} [options] Override http request options.
   */
  public corporateSubAccountIdPlanPut(
    id: number,
    updatePlanDetails: SubAccountUpdatePlanRequest,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/corporate/subAccount/{id}/plan".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling corporateSubAccountIdPlanPut."
      );
    }

    // verify required parameter 'updatePlanDetails' is not null or undefined
    if (updatePlanDetails === null || updatePlanDetails === undefined) {
      throw new Error(
        "Required parameter updatePlanDetails was null or undefined when calling corporateSubAccountIdPlanPut."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updatePlanDetails,
        "SubAccountUpdatePlanRequest"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This endpoint will generate an API v3 key for a sub account
   * @summary Create an API key for a sub-account
   * @param createApiKeyRequest Values to generate API key for sub-account
   * @param {*} [options] Override http request options.
   */
  public corporateSubAccountKeyPost(
    createApiKeyRequest: CreateApiKeyRequest,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateApiKeyResponse }> {
    const localVarPath = this.basePath + "/corporate/subAccount/key";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createApiKeyRequest' is not null or undefined
    if (createApiKeyRequest === null || createApiKeyRequest === undefined) {
      throw new Error(
        "Required parameter createApiKeyRequest was null or undefined when calling corporateSubAccountKeyPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createApiKeyRequest,
        "CreateApiKeyRequest"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateApiKeyResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateApiKeyResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will create a new sub-account under a master account
   * @summary Create a new sub-account under a master account.
   * @param subAccountCreate values to create new sub-account
   * @param {*} [options] Override http request options.
   */
  public corporateSubAccountPost(
    subAccountCreate: CreateSubAccount,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateSubAccountResponse;
  }> {
    const localVarPath = this.basePath + "/corporate/subAccount";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'subAccountCreate' is not null or undefined
    if (subAccountCreate === null || subAccountCreate === undefined) {
      throw new Error(
        "Required parameter subAccountCreate was null or undefined when calling corporateSubAccountPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(subAccountCreate, "CreateSubAccount"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateSubAccountResponse;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateSubAccountResponse");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint generates an sso token to authenticate and access a sub-account of the master using the account endpoint https://account-app.brevo.com/account/login/sub-account/sso/[token], where [token] will be replaced by the actual token.
   * @summary Generate SSO token to access Brevo
   * @param ssoTokenRequest Values to generate SSO token for sub-account
   * @param {*} [options] Override http request options.
   */
  public corporateSubAccountSsoTokenPost(
    ssoTokenRequest: SsoTokenRequest,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSsoToken }> {
    const localVarPath = this.basePath + "/corporate/subAccount/ssoToken";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'ssoTokenRequest' is not null or undefined
    if (ssoTokenRequest === null || ssoTokenRequest === undefined) {
      throw new Error(
        "Required parameter ssoTokenRequest was null or undefined when calling corporateSubAccountSsoTokenPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(ssoTokenRequest, "SsoTokenRequest"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetSsoToken }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetSsoToken");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum NotesApiApiKeys {
  apiKey,
  partnerKey,
}

export class NotesApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: NotesApiApiKeys, value: string) {
    (this.authentications as any)[NotesApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get all notes
   * @param entity Filter by note entity type
   * @param entityIds Filter by note entity IDs
   * @param dateFrom dateFrom to date range filter type (timestamp in milliseconds)
   * @param dateTo dateTo to date range filter type (timestamp in milliseconds)
   * @param offset Index of the first document of the page
   * @param limit Number of documents per page
   * @param sort Sort the results in the ascending/descending order. Default order is **descending** by creation if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public crmNotesGet(
    entity?: "companies" | "deals" | "contacts",
    entityIds?: string,
    dateFrom?: number,
    dateTo?: number,
    offset?: number,
    limit?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: NoteList }> {
    const localVarPath = this.basePath + "/crm/notes";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (entity !== undefined) {
      localVarQueryParameters["entity"] = ObjectSerializer.serialize(
        entity,
        "'companies' | 'deals' | 'contacts'"
      );
    }

    if (entityIds !== undefined) {
      localVarQueryParameters["entityIds"] = ObjectSerializer.serialize(
        entityIds,
        "string"
      );
    }

    if (dateFrom !== undefined) {
      localVarQueryParameters["dateFrom"] = ObjectSerializer.serialize(
        dateFrom,
        "number"
      );
    }

    if (dateTo !== undefined) {
      localVarQueryParameters["dateTo"] = ObjectSerializer.serialize(
        dateTo,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: NoteList }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "NoteList");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a note
   * @param id Note ID to delete
   * @param {*} [options] Override http request options.
   */
  public crmNotesIdDelete(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/notes/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmNotesIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a note
   * @param id Note ID to get
   * @param {*} [options] Override http request options.
   */
  public crmNotesIdGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Note }> {
    const localVarPath =
      this.basePath +
      "/crm/notes/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmNotesIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Note }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Note");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a note
   * @param id Note ID to update
   * @param body Note data to update a note
   * @param {*} [options] Override http request options.
   */
  public crmNotesIdPatch(
    id: string,
    body: NoteData,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/notes/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmNotesIdPatch."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling crmNotesIdPatch."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "NoteData"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a note
   * @param body Note data to create a note.
   * @param {*} [options] Override http request options.
   */
  public crmNotesPost(
    body: NoteData,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: NoteId }> {
    const localVarPath = this.basePath + "/crm/notes";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling crmNotesPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "NoteData"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: NoteId }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "NoteId");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ProcessApiApiKeys {
  apiKey,
  partnerKey,
}

export class ProcessApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ProcessApiApiKeys, value: string) {
    (this.authentications as any)[ProcessApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Return the informations for a process
   * @param processId Id of the process
   * @param {*} [options] Override http request options.
   */
  public getProcess(
    processId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetProcess }> {
    const localVarPath =
      this.basePath +
      "/processes/{processId}".replace(
        "{" + "processId" + "}",
        encodeURIComponent(String(processId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'processId' is not null or undefined
    if (processId === null || processId === undefined) {
      throw new Error(
        "Required parameter processId was null or undefined when calling getProcess."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetProcess }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetProcess");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Return all the processes for your account
   * @param limit Number limitation for the result returned
   * @param offset Beginning point in the list to retrieve from.
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getProcesses(
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetProcesses }> {
    const localVarPath = this.basePath + "/processes";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetProcesses }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetProcesses");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ResellerApiApiKeys {
  apiKey,
  partnerKey,
}

export class ResellerApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ResellerApiApiKeys, value: string) {
    (this.authentications as any)[ResellerApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Add Email and/or SMS credits to a specific child account
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param addCredits Values to post to add credit to a specific child account
   * @param {*} [options] Override http request options.
   */
  public addCredits(
    childIdentifier: string,
    addCredits: AddCredits,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RemainingCreditModel }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/credits/add".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling addCredits."
      );
    }

    // verify required parameter 'addCredits' is not null or undefined
    if (addCredits === null || addCredits === undefined) {
      throw new Error(
        "Required parameter addCredits was null or undefined when calling addCredits."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(addCredits, "AddCredits"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RemainingCreditModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RemainingCreditModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Associate a dedicated IP to the child
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param ip IP to associate
   * @param {*} [options] Override http request options.
   */
  public associateIpToChild(
    childIdentifier: string,
    ip: ManageIp,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/ips/associate".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling associateIpToChild."
      );
    }

    // verify required parameter 'ip' is not null or undefined
    if (ip === null || ip === undefined) {
      throw new Error(
        "Required parameter ip was null or undefined when calling associateIpToChild."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(ip, "ManageIp"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a domain for a child account
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param addChildDomain Sender domain to add for a specific child account. This will not be displayed to the parent account.
   * @param {*} [options] Override http request options.
   */
  public createChildDomain(
    childIdentifier: string,
    addChildDomain: AddChildDomain,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/domains".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling createChildDomain."
      );
    }

    // verify required parameter 'addChildDomain' is not null or undefined
    if (addChildDomain === null || addChildDomain === undefined) {
      throw new Error(
        "Required parameter addChildDomain was null or undefined when calling createChildDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(addChildDomain, "AddChildDomain"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Creates a reseller child
   * @param resellerChild reseller child to add
   * @param {*} [options] Override http request options.
   */
  public createResellerChild(
    resellerChild?: CreateChild,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateReseller }> {
    const localVarPath = this.basePath + "/reseller/children";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(resellerChild, "CreateChild"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateReseller;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateReseller");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Delete the sender domain of the reseller child based on the childIdentifier and domainName passed
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param domainName Pass the existing domain that needs to be deleted
   * @param {*} [options] Override http request options.
   */
  public deleteChildDomain(
    childIdentifier: string,
    domainName: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/domains/{domainName}"
        .replace(
          "{" + "childIdentifier" + "}",
          encodeURIComponent(String(childIdentifier))
        )
        .replace(
          "{" + "domainName" + "}",
          encodeURIComponent(String(domainName))
        );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling deleteChildDomain."
      );
    }

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling deleteChildDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a single reseller child based on the child identifier supplied
   * @param childIdentifier Either auth key or child id of reseller&#39;s child
   * @param {*} [options] Override http request options.
   */
  public deleteResellerChild(
    childIdentifier: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling deleteResellerChild."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Dissociate a dedicated IP to the child
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param ip IP to dissociate
   * @param {*} [options] Override http request options.
   */
  public dissociateIpFromChild(
    childIdentifier: string,
    ip: ManageIp,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/ips/dissociate".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling dissociateIpFromChild."
      );
    }

    // verify required parameter 'ip' is not null or undefined
    if (ip === null || ip === undefined) {
      throw new Error(
        "Required parameter ip was null or undefined when calling dissociateIpFromChild."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(ip, "ManageIp"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the status of a reseller's child account creation, whether it is successfully created (exists) or not based on the identifier supplied
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param {*} [options] Override http request options.
   */
  public getChildAccountCreationStatus(
    childIdentifier: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetChildAccountCreationStatus;
  }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/accountCreationStatus".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling getChildAccountCreationStatus."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetChildAccountCreationStatus;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetChildAccountCreationStatus"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all sender domains for a specific child account
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param {*} [options] Override http request options.
   */
  public getChildDomains(
    childIdentifier: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetChildDomains }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/domains".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling getChildDomains."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetChildDomains;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetChildDomains");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get a child account's details
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param {*} [options] Override http request options.
   */
  public getChildInfo(
    childIdentifier: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetChildInfo }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling getChildInfo."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetChildInfo }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetChildInfo");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get the list of all children accounts
   * @param limit Number of documents for child accounts information per page
   * @param offset Index of the first document in the page
   * @param {*} [options] Override http request options.
   */
  public getResellerChilds(
    limit?: number,
    offset?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetChildrenList }> {
    const localVarPath = this.basePath + "/reseller/children";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetChildrenList;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetChildrenList");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * It returns a session [token] which will remain valid for a short period of time. A child account will be able to access a white-labeled section by using the following url pattern => https:/email.mydomain.com/login/sso?token=[token]
   * @summary Get session token to access Brevo (SSO)
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param {*} [options] Override http request options.
   */
  public getSsoToken(
    childIdentifier: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSsoToken }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/auth".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling getSsoToken."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetSsoToken }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetSsoToken");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Remove Email and/or SMS credits from a specific child account
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param removeCredits Values to post to remove email or SMS credits from a specific child account
   * @param {*} [options] Override http request options.
   */
  public removeCredits(
    childIdentifier: string,
    removeCredits: RemoveCredits,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: RemainingCreditModel }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/credits/remove".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling removeCredits."
      );
    }

    // verify required parameter 'removeCredits' is not null or undefined
    if (removeCredits === null || removeCredits === undefined) {
      throw new Error(
        "Required parameter removeCredits was null or undefined when calling removeCredits."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(removeCredits, "RemoveCredits"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: RemainingCreditModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "RemainingCreditModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Update info of reseller's child account status based on the childIdentifier supplied
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param updateChildAccountStatus values to update in child account status
   * @param {*} [options] Override http request options.
   */
  public updateChildAccountStatus(
    childIdentifier: string,
    updateChildAccountStatus: UpdateChildAccountStatus,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/accountStatus".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling updateChildAccountStatus."
      );
    }

    // verify required parameter 'updateChildAccountStatus' is not null or undefined
    if (
      updateChildAccountStatus === null ||
      updateChildAccountStatus === undefined
    ) {
      throw new Error(
        "Required parameter updateChildAccountStatus was null or undefined when calling updateChildAccountStatus."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateChildAccountStatus,
        "UpdateChildAccountStatus"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update the sender domain of reseller's child based on the childIdentifier and domainName passed
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param domainName Pass the existing domain that needs to be updated
   * @param updateChildDomain value to update for sender domain
   * @param {*} [options] Override http request options.
   */
  public updateChildDomain(
    childIdentifier: string,
    domainName: string,
    updateChildDomain: UpdateChildDomain,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}/domains/{domainName}"
        .replace(
          "{" + "childIdentifier" + "}",
          encodeURIComponent(String(childIdentifier))
        )
        .replace(
          "{" + "domainName" + "}",
          encodeURIComponent(String(domainName))
        );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling updateChildDomain."
      );
    }

    // verify required parameter 'domainName' is not null or undefined
    if (domainName === null || domainName === undefined) {
      throw new Error(
        "Required parameter domainName was null or undefined when calling updateChildDomain."
      );
    }

    // verify required parameter 'updateChildDomain' is not null or undefined
    if (updateChildDomain === null || updateChildDomain === undefined) {
      throw new Error(
        "Required parameter updateChildDomain was null or undefined when calling updateChildDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateChildDomain, "UpdateChildDomain"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update info of reseller's child based on the child identifier supplied
   * @param childIdentifier Either auth key or id of reseller&#39;s child
   * @param resellerChild values to update in child profile
   * @param {*} [options] Override http request options.
   */
  public updateResellerChild(
    childIdentifier: string,
    resellerChild: UpdateChild,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/reseller/children/{childIdentifier}".replace(
        "{" + "childIdentifier" + "}",
        encodeURIComponent(String(childIdentifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'childIdentifier' is not null or undefined
    if (childIdentifier === null || childIdentifier === undefined) {
      throw new Error(
        "Required parameter childIdentifier was null or undefined when calling updateResellerChild."
      );
    }

    // verify required parameter 'resellerChild' is not null or undefined
    if (resellerChild === null || resellerChild === undefined) {
      throw new Error(
        "Required parameter resellerChild was null or undefined when calling updateResellerChild."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(resellerChild, "UpdateChild"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum SMSCampaignsApiApiKeys {
  apiKey,
  partnerKey,
}

export class SMSCampaignsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: SMSCampaignsApiApiKeys, value: string) {
    (this.authentications as any)[SMSCampaignsApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Creates an SMS campaign
   * @param createSmsCampaign Values to create an SMS Campaign
   * @param {*} [options] Override http request options.
   */
  public createSmsCampaign(
    createSmsCampaign: CreateSmsCampaign,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/smsCampaigns";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createSmsCampaign' is not null or undefined
    if (createSmsCampaign === null || createSmsCampaign === undefined) {
      throw new Error(
        "Required parameter createSmsCampaign was null or undefined when calling createSmsCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createSmsCampaign, "CreateSmsCampaign"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete an SMS campaign
   * @param campaignId id of the SMS campaign
   * @param {*} [options] Override http request options.
   */
  public deleteSmsCampaign(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling deleteSmsCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get an SMS campaign
   * @param campaignId id of the SMS campaign
   * @param {*} [options] Override http request options.
   */
  public getSmsCampaign(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSmsCampaign }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling getSmsCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetSmsCampaign;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSmsCampaign");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Returns the information for all your created SMS campaigns
   * @param status Status of campaign.
   * @param startDate Mandatory if endDate is used. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent sms campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
   * @param endDate Mandatory if startDate is used. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the sent sms campaigns. Prefer to pass your timezone in date-time format for accurate result ( only available if either &#39;status&#39; not passed and if passed is set to &#39;sent&#39; )
   * @param limit Number limitation for the result returned
   * @param offset Beginning point in the list to retrieve from.
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getSmsCampaigns(
    status?:
      | "suspended"
      | "archive"
      | "sent"
      | "queued"
      | "draft"
      | "inProcess",
    startDate?: string,
    endDate?: string,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSmsCampaigns }> {
    const localVarPath = this.basePath + "/smsCampaigns";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (status !== undefined) {
      localVarQueryParameters["status"] = ObjectSerializer.serialize(
        status,
        "'suspended' | 'archive' | 'sent' | 'queued' | 'draft' | 'inProcess'"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetSmsCampaigns;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSmsCampaigns");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * It returns the background process ID which on completion calls the notify URL that you have set in the input.
   * @summary Export an SMS campaign's recipients
   * @param campaignId id of the campaign
   * @param recipientExport Values to send for a recipient export request
   * @param {*} [options] Override http request options.
   */
  public requestSmsRecipientExport(
    campaignId: number,
    recipientExport?: RequestSmsRecipientExport,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreatedProcessId }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}/exportRecipients".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling requestSmsRecipientExport."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        recipientExport,
        "RequestSmsRecipientExport"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreatedProcessId;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreatedProcessId");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Send your SMS campaign immediately
   * @param campaignId id of the campaign
   * @param {*} [options] Override http request options.
   */
  public sendSmsCampaignNow(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}/sendNow".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling sendSmsCampaignNow."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Send report of Sent and Archived campaign, to the specified email addresses, with respective data and a pdf attachment in detail.
   * @summary Send an SMS campaign's report
   * @param campaignId id of the campaign
   * @param sendReport Values for send a report
   * @param {*} [options] Override http request options.
   */
  public sendSmsReport(
    campaignId: number,
    sendReport: SendReport,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}/sendReport".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling sendSmsReport."
      );
    }

    // verify required parameter 'sendReport' is not null or undefined
    if (sendReport === null || sendReport === undefined) {
      throw new Error(
        "Required parameter sendReport was null or undefined when calling sendSmsReport."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(sendReport, "SendReport"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Send a test SMS campaign
   * @param campaignId Id of the SMS campaign
   * @param phoneNumber Mobile number of the recipient with the country code. This number must belong to one of your contacts in Brevo account and must not be blacklisted
   * @param {*} [options] Override http request options.
   */
  public sendTestSms(
    campaignId: number,
    phoneNumber: SendTestSms,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}/sendTest".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling sendTestSms."
      );
    }

    // verify required parameter 'phoneNumber' is not null or undefined
    if (phoneNumber === null || phoneNumber === undefined) {
      throw new Error(
        "Required parameter phoneNumber was null or undefined when calling sendTestSms."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(phoneNumber, "SendTestSms"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update an SMS campaign
   * @param campaignId id of the SMS campaign
   * @param updateSmsCampaign Values to update an SMS Campaign
   * @param {*} [options] Override http request options.
   */
  public updateSmsCampaign(
    campaignId: number,
    updateSmsCampaign: UpdateSmsCampaign,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling updateSmsCampaign."
      );
    }

    // verify required parameter 'updateSmsCampaign' is not null or undefined
    if (updateSmsCampaign === null || updateSmsCampaign === undefined) {
      throw new Error(
        "Required parameter updateSmsCampaign was null or undefined when calling updateSmsCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateSmsCampaign, "UpdateSmsCampaign"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a campaign's status
   * @param campaignId id of the campaign
   * @param status Status of the campaign.
   * @param {*} [options] Override http request options.
   */
  public updateSmsCampaignStatus(
    campaignId: number,
    status: UpdateCampaignStatus,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smsCampaigns/{campaignId}/status".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling updateSmsCampaignStatus."
      );
    }

    // verify required parameter 'status' is not null or undefined
    if (status === null || status === undefined) {
      throw new Error(
        "Required parameter status was null or undefined when calling updateSmsCampaignStatus."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(status, "UpdateCampaignStatus"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum SendersApiApiKeys {
  apiKey,
  partnerKey,
}

export class SendersApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: SendersApiApiKeys, value: string) {
    (this.authentications as any)[SendersApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Create a new sender
   * @param sender sender&#39;s name
   * @param {*} [options] Override http request options.
   */
  public createSender(
    sender?: CreateSender,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateSenderModel }> {
    const localVarPath = this.basePath + "/senders";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(sender, "CreateSender"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateSenderModel;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateSenderModel");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Delete a sender
   * @param senderId Id of the sender
   * @param {*} [options] Override http request options.
   */
  public deleteSender(
    senderId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/senders/{senderId}".replace(
        "{" + "senderId" + "}",
        encodeURIComponent(String(senderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'senderId' is not null or undefined
    if (senderId === null || senderId === undefined) {
      throw new Error(
        "Required parameter senderId was null or undefined when calling deleteSender."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get all the dedicated IPs for your account
   * @param {*} [options] Override http request options.
   */
  public getIps(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetIps }> {
    const localVarPath = this.basePath + "/senders/ips";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetIps }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetIps");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get all the dedicated IPs for a sender
   * @param senderId Id of the sender
   * @param {*} [options] Override http request options.
   */
  public getIpsFromSender(
    senderId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetIpsFromSender }> {
    const localVarPath =
      this.basePath +
      "/senders/{senderId}/ips".replace(
        "{" + "senderId" + "}",
        encodeURIComponent(String(senderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'senderId' is not null or undefined
    if (senderId === null || senderId === undefined) {
      throw new Error(
        "Required parameter senderId was null or undefined when calling getIpsFromSender."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetIpsFromSender;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetIpsFromSender");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the list of all your senders
   * @param ip Filter your senders for a specific ip (available for dedicated IP usage only)
   * @param domain Filter your senders for a specific domain
   * @param {*} [options] Override http request options.
   */
  public getSenders(
    ip?: string,
    domain?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSendersList }> {
    const localVarPath = this.basePath + "/senders";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (ip !== undefined) {
      localVarQueryParameters["ip"] = ObjectSerializer.serialize(ip, "string");
    }

    if (domain !== undefined) {
      localVarQueryParameters["domain"] = ObjectSerializer.serialize(
        domain,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetSendersList;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSendersList");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Update a sender
   * @param senderId Id of the sender
   * @param sender sender&#39;s name
   * @param {*} [options] Override http request options.
   */
  public updateSender(
    senderId: number,
    sender?: UpdateSender,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/senders/{senderId}".replace(
        "{" + "senderId" + "}",
        encodeURIComponent(String(senderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'senderId' is not null or undefined
    if (senderId === null || senderId === undefined) {
      throw new Error(
        "Required parameter senderId was null or undefined when calling updateSender."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(sender, "UpdateSender"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a sender
   * @param senderId Id of the sender
   * @param otp otp
   * @param {*} [options] Override http request options.
   */
  public validateSenderByOTP(
    senderId: number,
    otp?: Otp,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/senders/{senderId}/validate".replace(
        "{" + "senderId" + "}",
        encodeURIComponent(String(senderId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'senderId' is not null or undefined
    if (senderId === null || senderId === undefined) {
      throw new Error(
        "Required parameter senderId was null or undefined when calling validateSenderByOTP."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(otp, "Otp"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum TasksApiApiKeys {
  apiKey,
  partnerKey,
}

export class TasksApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TasksApiApiKeys, value: string) {
    (this.authentications as any)[TasksApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Get all tasks
   * @param filterType Filter by task type (ID)
   * @param filterStatus Filter by task status
   * @param filterDate Filter by date
   * @param filterAssignTo Filter by assignTo id
   * @param filterContacts Filter by contact ids
   * @param filterDeals Filter by deals ids
   * @param filterCompanies Filter by companies ids
   * @param dateFrom dateFrom to date range filter type (timestamp in milliseconds)
   * @param dateTo dateTo to date range filter type (timestamp in milliseconds)
   * @param offset Index of the first document of the page
   * @param limit Number of documents per page
   * @param sort Sort the results in the ascending/descending order. Default order is **descending** by creation if &#x60;sort&#x60; is not passed
   * @param sortBy The field used to sort field names.
   * @param {*} [options] Override http request options.
   */
  public crmTasksGet(
    filterType?: string,
    filterStatus?: "done" | "undone",
    filterDate?: "overdue" | "today" | "tomorrow" | "week" | "range",
    filterAssignTo?: string,
    filterContacts?: string,
    filterDeals?: string,
    filterCompanies?: string,
    dateFrom?: number,
    dateTo?: number,
    offset?: number,
    limit?: number,
    sort?: "asc" | "desc",
    sortBy?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: TaskList }> {
    const localVarPath = this.basePath + "/crm/tasks";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (filterType !== undefined) {
      localVarQueryParameters["filter[type]"] = ObjectSerializer.serialize(
        filterType,
        "string"
      );
    }

    if (filterStatus !== undefined) {
      localVarQueryParameters["filter[status]"] = ObjectSerializer.serialize(
        filterStatus,
        "'done' | 'undone'"
      );
    }

    if (filterDate !== undefined) {
      localVarQueryParameters["filter[date]"] = ObjectSerializer.serialize(
        filterDate,
        "'overdue' | 'today' | 'tomorrow' | 'week' | 'range'"
      );
    }

    if (filterAssignTo !== undefined) {
      localVarQueryParameters["filter[assignTo]"] = ObjectSerializer.serialize(
        filterAssignTo,
        "string"
      );
    }

    if (filterContacts !== undefined) {
      localVarQueryParameters["filter[contacts]"] = ObjectSerializer.serialize(
        filterContacts,
        "string"
      );
    }

    if (filterDeals !== undefined) {
      localVarQueryParameters["filter[deals]"] = ObjectSerializer.serialize(
        filterDeals,
        "string"
      );
    }

    if (filterCompanies !== undefined) {
      localVarQueryParameters["filter[companies]"] = ObjectSerializer.serialize(
        filterCompanies,
        "string"
      );
    }

    if (dateFrom !== undefined) {
      localVarQueryParameters["dateFrom"] = ObjectSerializer.serialize(
        dateFrom,
        "number"
      );
    }

    if (dateTo !== undefined) {
      localVarQueryParameters["dateTo"] = ObjectSerializer.serialize(
        dateTo,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (sortBy !== undefined) {
      localVarQueryParameters["sortBy"] = ObjectSerializer.serialize(
        sortBy,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: TaskList }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "TaskList");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a task
   * @param id
   * @param {*} [options] Override http request options.
   */
  public crmTasksIdDelete(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/tasks/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmTasksIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a task
   * @param id
   * @param {*} [options] Override http request options.
   */
  public crmTasksIdGet(
    id: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: Task }> {
    const localVarPath =
      this.basePath +
      "/crm/tasks/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmTasksIdGet."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: Task }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Task");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a task
   * @param id
   * @param body Updated task details.
   * @param {*} [options] Override http request options.
   */
  public crmTasksIdPatch(
    id: string,
    body: Body7,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/crm/tasks/{id}".replace(
        "{" + "id" + "}",
        encodeURIComponent(String(id))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error(
        "Required parameter id was null or undefined when calling crmTasksIdPatch."
      );
    }

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling crmTasksIdPatch."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body7"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a task
   * @param body Task name.
   * @param {*} [options] Override http request options.
   */
  public crmTasksPost(
    body: Body6,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse2011 }> {
    const localVarPath = this.basePath + "/crm/tasks";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling crmTasksPost."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Body6"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse2011;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse2011");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get all task types
   * @param {*} [options] Override http request options.
   */
  public crmTasktypesGet(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: TaskTypes }> {
    const localVarPath = this.basePath + "/crm/tasktypes";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: TaskTypes }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "TaskTypes");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum TransactionalEmailsApiApiKeys {
  apiKey,
  partnerKey,
}

export class TransactionalEmailsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TransactionalEmailsApiApiKeys, value: string) {
    (this.authentications as any)[TransactionalEmailsApiApiKeys[key]].apiKey =
      value;
  }
  /**
   * Blocks a new domain in order to avoid messages being sent to the same
   * @summary Add a new domain to the list of blocked domains
   * @param blockDomain
   * @param {*} [options] Override http request options.
   */
  public blockNewDomain(
    blockDomain: BlockDomain,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/smtp/blockedDomains";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'blockDomain' is not null or undefined
    if (blockDomain === null || blockDomain === undefined) {
      throw new Error(
        "Required parameter blockDomain was null or undefined when calling blockNewDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(blockDomain, "BlockDomain"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create an email template
   * @param smtpTemplate values to update in transactional email template
   * @param {*} [options] Override http request options.
   */
  public createSmtpTemplate(
    smtpTemplate: CreateSmtpTemplate,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/smtp/templates";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'smtpTemplate' is not null or undefined
    if (smtpTemplate === null || smtpTemplate === undefined) {
      throw new Error(
        "Required parameter smtpTemplate was null or undefined when calling createSmtpTemplate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(smtpTemplate, "CreateSmtpTemplate"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Unblocks an existing domain from the list of blocked domains
   * @summary Unblock an existing domain from the list of blocked domains
   * @param domain The name of the domain to be deleted
   * @param {*} [options] Override http request options.
   */
  public deleteBlockedDomain(
    domain: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smtp/blockedDomains/{domain}".replace(
        "{" + "domain" + "}",
        encodeURIComponent(String(domain))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'domain' is not null or undefined
    if (domain === null || domain === undefined) {
      throw new Error(
        "Required parameter domain was null or undefined when calling deleteBlockedDomain."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
   * @summary Delete hardbounces
   * @param deleteHardbounces values to delete hardbounces
   * @param {*} [options] Override http request options.
   */
  public deleteHardbounces(
    deleteHardbounces?: DeleteHardbounces,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/smtp/deleteHardbounces";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(deleteHardbounces, "DeleteHardbounces"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Delete scheduled batch of emails by batchId or single scheduled email by messageId
   * @summary Delete scheduled emails by batchId or messageId
   * @param identifier The &#x60;batchId&#x60; of scheduled emails batch (Should be a valid UUIDv4) or the &#x60;messageId&#x60; of scheduled email.
   * @param {*} [options] Override http request options.
   */
  public deleteScheduledEmailById(
    identifier: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smtp/email/{identifier}".replace(
        "{" + "identifier" + "}",
        encodeURIComponent(String(identifier))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'identifier' is not null or undefined
    if (identifier === null || identifier === undefined) {
      throw new Error(
        "Required parameter identifier was null or undefined when calling deleteScheduledEmailById."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete an inactive email template
   * @param templateId id of the template
   * @param {*} [options] Override http request options.
   */
  public deleteSmtpTemplate(
    templateId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smtp/templates/{templateId}".replace(
        "{" + "templateId" + "}",
        encodeURIComponent(String(templateId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error(
        "Required parameter templateId was null or undefined when calling deleteSmtpTemplate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This endpoint will show the aggregated stats for past 90 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days
   * @summary Get your transactional email activity aggregated over a period of time
   * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
   * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
   * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
   * @param tag Tag of the emails
   * @param {*} [options] Override http request options.
   */
  public getAggregatedSmtpReport(
    startDate?: string,
    endDate?: string,
    days?: number,
    tag?: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetAggregatedReport }> {
    const localVarPath = this.basePath + "/smtp/statistics/aggregatedReport";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (days !== undefined) {
      localVarQueryParameters["days"] = ObjectSerializer.serialize(
        days,
        "number"
      );
    }

    if (tag !== undefined) {
      localVarQueryParameters["tag"] = ObjectSerializer.serialize(
        tag,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetAggregatedReport;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetAggregatedReport");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get the list of blocked domains
   * @summary Get the list of blocked domains
   * @param {*} [options] Override http request options.
   */
  public getBlockedDomains(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetBlockedDomains }> {
    const localVarPath = this.basePath + "/smtp/blockedDomains";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetBlockedDomains;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetBlockedDomains");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will show the aggregated stats for past 30 days by default if `startDate` and `endDate` OR `days` is not passed. The date range can not exceed 90 days
   * @summary Get all your transactional email activity (unaggregated events)
   * @param limit Number limitation for the result returned
   * @param offset Beginning point in the list to retrieve from.
   * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
   * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
   * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
   * @param email Filter the report for a specific email addresses
   * @param event Filter the report for a specific event type
   * @param tags Filter the report for tags (serialized and urlencoded array)
   * @param messageId Filter on a specific message id
   * @param templateId Filter on a specific template id
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getEmailEventReport(
    limit?: number,
    offset?: number,
    startDate?: string,
    endDate?: string,
    days?: number,
    email?: string,
    event?:
      | "bounces"
      | "hardBounces"
      | "softBounces"
      | "delivered"
      | "spam"
      | "requests"
      | "opened"
      | "clicks"
      | "invalid"
      | "deferred"
      | "blocked"
      | "unsubscribed"
      | "error"
      | "loadedByProxy",
    tags?: string,
    messageId?: string,
    templateId?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetEmailEventReport }> {
    const localVarPath = this.basePath + "/smtp/statistics/events";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (days !== undefined) {
      localVarQueryParameters["days"] = ObjectSerializer.serialize(
        days,
        "number"
      );
    }

    if (email !== undefined) {
      localVarQueryParameters["email"] = ObjectSerializer.serialize(
        email,
        "string"
      );
    }

    if (event !== undefined) {
      localVarQueryParameters["event"] = ObjectSerializer.serialize(
        event,
        "'bounces' | 'hardBounces' | 'softBounces' | 'delivered' | 'spam' | 'requests' | 'opened' | 'clicks' | 'invalid' | 'deferred' | 'blocked' | 'unsubscribed' | 'error' | 'loadedByProxy'"
      );
    }

    if (tags !== undefined) {
      localVarQueryParameters["tags"] = ObjectSerializer.serialize(
        tags,
        "string"
      );
    }

    if (messageId !== undefined) {
      localVarQueryParameters["messageId"] = ObjectSerializer.serialize(
        messageId,
        "string"
      );
    }

    if (templateId !== undefined) {
      localVarQueryParameters["templateId"] = ObjectSerializer.serialize(
        templateId,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetEmailEventReport;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetEmailEventReport");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Fetch scheduled batch of emails by batchId (Can retrieve data upto 30 days old)
   * @summary Fetch scheduled emails by batchId
   * @param batchId The batchId of scheduled emails batch (Should be a valid UUIDv4)
   * @param startDate Mandatory if &#x60;endDate&#x60; is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Can be maximum 30 days older tha current date.
   * @param endDate Mandatory if &#x60;startDate&#x60; is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param status Filter the records by &#x60;status&#x60; of the scheduled email batch or message.
   * @param limit Number of documents returned per page
   * @param offset Index of the first document on the page
   * @param {*} [options] Override http request options.
   */
  public getScheduledEmailByBatchId(
    batchId: string,
    startDate?: string,
    endDate?: string,
    sort?: "asc" | "desc",
    status?: "processed" | "inProgress" | "queued",
    limit?: number,
    offset?: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetScheduledEmailByBatchId;
  }> {
    const localVarPath =
      this.basePath +
      "/smtp/emailStatus/{batchId}".replace(
        "{" + "batchId" + "}",
        encodeURIComponent(String(batchId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'batchId' is not null or undefined
    if (batchId === null || batchId === undefined) {
      throw new Error(
        "Required parameter batchId was null or undefined when calling getScheduledEmailByBatchId."
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (status !== undefined) {
      localVarQueryParameters["status"] = ObjectSerializer.serialize(
        status,
        "'processed' | 'inProgress' | 'queued'"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetScheduledEmailByBatchId;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetScheduledEmailByBatchId"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Fetch scheduled email by messageId (Can retrieve data upto 30 days old)
   * @summary Fetch scheduled email by messageId
   * @param messageId The messageId of scheduled email
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Can be maximum 30 days older tha current date.
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.
   * @param {*} [options] Override http request options.
   */
  public getScheduledEmailByMessageId(
    messageId: string,
    startDate?: string,
    endDate?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetScheduledEmailByMessageId;
  }> {
    const localVarPath =
      this.basePath +
      "/smtp/emailStatus/{messageId}".replace(
        "{" + "messageId" + "}",
        encodeURIComponent(String(messageId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'messageId' is not null or undefined
    if (messageId === null || messageId === undefined) {
      throw new Error(
        "Required parameter messageId was null or undefined when calling getScheduledEmailByMessageId."
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetScheduledEmailByMessageId;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetScheduledEmailByMessageId"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get your transactional email activity aggregated per day
   * @param limit Number of documents returned per page
   * @param offset Index of the first document on the page
   * @param startDate Mandatory if endDate is used. Starting date of the report (YYYY-MM-DD)
   * @param endDate Mandatory if startDate is used. Ending date of the report (YYYY-MM-DD)
   * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
   * @param tag Tag of the emails
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getSmtpReport(
    limit?: number,
    offset?: number,
    startDate?: string,
    endDate?: string,
    days?: number,
    tag?: string,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetReports }> {
    const localVarPath = this.basePath + "/smtp/statistics/reports";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (days !== undefined) {
      localVarQueryParameters["days"] = ObjectSerializer.serialize(
        days,
        "number"
      );
    }

    if (tag !== undefined) {
      localVarQueryParameters["tag"] = ObjectSerializer.serialize(
        tag,
        "string"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetReports }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetReports");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Returns the template information
   * @param templateId id of the template
   * @param {*} [options] Override http request options.
   */
  public getSmtpTemplate(
    templateId: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetSmtpTemplateOverview;
  }> {
    const localVarPath =
      this.basePath +
      "/smtp/templates/{templateId}".replace(
        "{" + "templateId" + "}",
        encodeURIComponent(String(templateId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error(
        "Required parameter templateId was null or undefined when calling getSmtpTemplate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetSmtpTemplateOverview;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSmtpTemplateOverview");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the list of email templates
   * @param templateStatus Filter on the status of the template. Active &#x3D; true, inactive &#x3D; false
   * @param limit Number of documents returned per page
   * @param offset Index of the first document in the page
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getSmtpTemplates(
    templateStatus?: boolean,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSmtpTemplates }> {
    const localVarPath = this.basePath + "/smtp/templates";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (templateStatus !== undefined) {
      localVarQueryParameters["templateStatus"] = ObjectSerializer.serialize(
        templateStatus,
        "boolean"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetSmtpTemplates;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSmtpTemplates");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the list of blocked or unsubscribed transactional contacts
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the blocked or unsubscribed contacts
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the blocked or unsubscribed contacts
   * @param limit Number of documents returned per page
   * @param offset Index of the first document on the page
   * @param senders Comma separated list of emails of the senders from which contacts are blocked or unsubscribed
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getTransacBlockedContacts(
    startDate?: string,
    endDate?: string,
    limit?: number,
    offset?: number,
    senders?: Array<string>,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransacBlockedContacts;
  }> {
    const localVarPath = this.basePath + "/smtp/blockedContacts";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (senders !== undefined) {
      localVarQueryParameters["senders"] = ObjectSerializer.serialize(
        senders,
        "Array<string>"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetTransacBlockedContacts;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetTransacBlockedContacts"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get the personalized content of a sent transactional email
   * @param uuid Unique id of the transactional email that has been sent to a particular contact
   * @param {*} [options] Override http request options.
   */
  public getTransacEmailContent(
    uuid: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetTransacEmailContent }> {
    const localVarPath =
      this.basePath +
      "/smtp/emails/{uuid}".replace(
        "{" + "uuid" + "}",
        encodeURIComponent(String(uuid))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'uuid' is not null or undefined
    if (uuid === null || uuid === undefined) {
      throw new Error(
        "Required parameter uuid was null or undefined when calling getTransacEmailContent."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetTransacEmailContent;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetTransacEmailContent");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
   * @summary Get the list of transactional emails on the basis of allowed filters
   * @param email Mandatory if templateId and messageId are not passed in query filters. Email address to which transactional email has been sent.
   * @param templateId Mandatory if email and messageId are not passed in query filters. Id of the template that was used to compose transactional email.
   * @param messageId Mandatory if templateId and email are not passed in query filters. Message ID of the transactional email sent.
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) from which you want to fetch the list. Maximum time period that can be selected is one month.
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) till which you want to fetch the list. Maximum time period that can be selected is one month.
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param limit Number of documents returned per page
   * @param offset Index of the first document in the page
   * @param {*} [options] Override http request options.
   */
  public getTransacEmailsList(
    email?: string,
    templateId?: number,
    messageId?: string,
    startDate?: string,
    endDate?: string,
    sort?: "asc" | "desc",
    limit?: number,
    offset?: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetTransacEmailsList }> {
    const localVarPath = this.basePath + "/smtp/emails";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (email !== undefined) {
      localVarQueryParameters["email"] = ObjectSerializer.serialize(
        email,
        "string"
      );
    }

    if (templateId !== undefined) {
      localVarQueryParameters["templateId"] = ObjectSerializer.serialize(
        templateId,
        "number"
      );
    }

    if (messageId !== undefined) {
      localVarQueryParameters["messageId"] = ObjectSerializer.serialize(
        messageId,
        "string"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetTransacEmailsList;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetTransacEmailsList");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Send a template to your test list
   * @param templateId Id of the template
   * @param sendTestEmail
   * @param {*} [options] Override http request options.
   */
  public sendTestTemplate(
    templateId: number,
    sendTestEmail: SendTestEmail,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smtp/templates/{templateId}/sendTest".replace(
        "{" + "templateId" + "}",
        encodeURIComponent(String(templateId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error(
        "Required parameter templateId was null or undefined when calling sendTestTemplate."
      );
    }

    // verify required parameter 'sendTestEmail' is not null or undefined
    if (sendTestEmail === null || sendTestEmail === undefined) {
      throw new Error(
        "Required parameter sendTestEmail was null or undefined when calling sendTestTemplate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(sendTestEmail, "SendTestEmail"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Send a transactional email
   * @param sendSmtpEmail Values to send a transactional email
   * @param {*} [options] Override http request options.
   */
  public sendTransacEmail(
    sendSmtpEmail: SendSmtpEmail,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateSmtpEmail }> {
    const localVarPath = this.basePath + "/smtp/email";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'sendSmtpEmail' is not null or undefined
    if (sendSmtpEmail === null || sendSmtpEmail === undefined) {
      throw new Error(
        "Required parameter sendSmtpEmail was null or undefined when calling sendTransacEmail."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(sendSmtpEmail, "SendSmtpEmail"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreateSmtpEmail;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreateSmtpEmail");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Unblock or resubscribe a transactional contact
   * @param email contact email (urlencoded) to unblock.
   * @param {*} [options] Override http request options.
   */
  public smtpBlockedContactsEmailDelete(
    email: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smtp/blockedContacts/{email}".replace(
        "{" + "email" + "}",
        encodeURIComponent(String(email))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'email' is not null or undefined
    if (email === null || email === undefined) {
      throw new Error(
        "Required parameter email was null or undefined when calling smtpBlockedContactsEmailDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete an SMTP transactional log
   * @param messageId MessageId of the transactional log to delete
   * @param {*} [options] Override http request options.
   */
  public smtpLogMessageIdDelete(
    messageId: string,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smtp/log/{messageId}".replace(
        "{" + "messageId" + "}",
        encodeURIComponent(String(messageId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'messageId' is not null or undefined
    if (messageId === null || messageId === undefined) {
      throw new Error(
        "Required parameter messageId was null or undefined when calling smtpLogMessageIdDelete."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update an email template
   * @param templateId id of the template
   * @param smtpTemplate values to update in transactional email template
   * @param {*} [options] Override http request options.
   */
  public updateSmtpTemplate(
    templateId: number,
    smtpTemplate: UpdateSmtpTemplate,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/smtp/templates/{templateId}".replace(
        "{" + "templateId" + "}",
        encodeURIComponent(String(templateId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'templateId' is not null or undefined
    if (templateId === null || templateId === undefined) {
      throw new Error(
        "Required parameter templateId was null or undefined when calling updateSmtpTemplate."
      );
    }

    // verify required parameter 'smtpTemplate' is not null or undefined
    if (smtpTemplate === null || smtpTemplate === undefined) {
      throw new Error(
        "Required parameter smtpTemplate was null or undefined when calling updateSmtpTemplate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(smtpTemplate, "UpdateSmtpTemplate"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum TransactionalSMSApiApiKeys {
  apiKey,
  partnerKey,
}

export class TransactionalSMSApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TransactionalSMSApiApiKeys, value: string) {
    (this.authentications as any)[TransactionalSMSApiApiKeys[key]].apiKey =
      value;
  }
  /**
   *
   * @summary Get all your SMS activity (unaggregated events)
   * @param limit Number of documents per page
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
   * @param offset Index of the first document of the page
   * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
   * @param phoneNumber Filter the report for a specific phone number
   * @param event Filter the report for specific events
   * @param tags Filter the report for specific tags passed as a serialized urlencoded array
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getSmsEvents(
    limit?: number,
    startDate?: string,
    endDate?: string,
    offset?: number,
    days?: number,
    phoneNumber?: string,
    event?:
      | "bounces"
      | "hardBounces"
      | "softBounces"
      | "delivered"
      | "sent"
      | "accepted"
      | "unsubscription"
      | "replies"
      | "blocked"
      | "rejected",
    tags?: string,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetSmsEventReport }> {
    const localVarPath = this.basePath + "/transactionalSMS/statistics/events";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (days !== undefined) {
      localVarQueryParameters["days"] = ObjectSerializer.serialize(
        days,
        "number"
      );
    }

    if (phoneNumber !== undefined) {
      localVarQueryParameters["phoneNumber"] = ObjectSerializer.serialize(
        phoneNumber,
        "string"
      );
    }

    if (event !== undefined) {
      localVarQueryParameters["event"] = ObjectSerializer.serialize(
        event,
        "'bounces' | 'hardBounces' | 'softBounces' | 'delivered' | 'sent' | 'accepted' | 'unsubscription' | 'replies' | 'blocked' | 'rejected'"
      );
    }

    if (tags !== undefined) {
      localVarQueryParameters["tags"] = ObjectSerializer.serialize(
        tags,
        "string"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetSmsEventReport;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetSmsEventReport");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get your SMS activity aggregated over a period of time
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
   * @param days Number of days in the past including today (positive integer). Not compatible with startDate and endDate
   * @param tag Filter on a tag
   * @param {*} [options] Override http request options.
   */
  public getTransacAggregatedSmsReport(
    startDate?: string,
    endDate?: string,
    days?: number,
    tag?: string,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTransacAggregatedSmsReport;
  }> {
    const localVarPath =
      this.basePath + "/transactionalSMS/statistics/aggregatedReport";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (days !== undefined) {
      localVarQueryParameters["days"] = ObjectSerializer.serialize(
        days,
        "number"
      );
    }

    if (tag !== undefined) {
      localVarQueryParameters["tag"] = ObjectSerializer.serialize(
        tag,
        "string"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetTransacAggregatedSmsReport;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetTransacAggregatedSmsReport"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get your SMS activity aggregated per day
   * @param startDate Mandatory if endDate is used. Starting date (YYYY-MM-DD) of the report
   * @param endDate Mandatory if startDate is used. Ending date (YYYY-MM-DD) of the report
   * @param days Number of days in the past including today (positive integer). Not compatible with &#39;startDate&#39; and &#39;endDate&#39;
   * @param tag Filter on a tag
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getTransacSmsReport(
    startDate?: string,
    endDate?: string,
    days?: number,
    tag?: string,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetTransacSmsReport }> {
    const localVarPath = this.basePath + "/transactionalSMS/statistics/reports";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (days !== undefined) {
      localVarQueryParameters["days"] = ObjectSerializer.serialize(
        days,
        "number"
      );
    }

    if (tag !== undefined) {
      localVarQueryParameters["tag"] = ObjectSerializer.serialize(
        tag,
        "string"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetTransacSmsReport;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetTransacSmsReport");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Send SMS message to a mobile number
   * @param sendTransacSms Values to send a transactional SMS
   * @param {*} [options] Override http request options.
   */
  public sendTransacSms(
    sendTransacSms: SendTransacSms,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: SendSms }> {
    const localVarPath = this.basePath + "/transactionalSMS/sms";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'sendTransacSms' is not null or undefined
    if (sendTransacSms === null || sendTransacSms === undefined) {
      throw new Error(
        "Required parameter sendTransacSms was null or undefined when calling sendTransacSms."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(sendTransacSms, "SendTransacSms"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: SendSms }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "SendSms");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum TransactionalWhatsAppApiApiKeys {
  apiKey,
  partnerKey,
}

export class TransactionalWhatsAppApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TransactionalWhatsAppApiApiKeys, value: string) {
    (this.authentications as any)[TransactionalWhatsAppApiApiKeys[key]].apiKey =
      value;
  }
  /**
   * This endpoint will show the unaggregated statistics for WhatsApp activity (30 days by default if `startDate` and `endDate` or `days` is not passed. The date range can not exceed 90 days)
   * @summary Get all your WhatsApp activity (unaggregated events)
   * @param limit Number limitation for the result returned
   * @param offset Beginning point in the list to retrieve from
   * @param startDate **Mandatory if endDate is used.** Starting date of the report (YYYY-MM-DD). Must be lower than equal to endDate
   * @param endDate **Mandatory if startDate is used.** Ending date of the report (YYYY-MM-DD). Must be greater than equal to startDate
   * @param days Number of days in the past including today (positive integer). _Not compatible with &#39;startDate&#39; and &#39;endDate&#39;_
   * @param contactNumber Filter results for specific contact (WhatsApp Number with country code. Example, 85264318721)
   * @param event Filter the report for a specific event type
   * @param sort Sort the results in the ascending/descending order of record creation. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getWhatsappEventReport(
    limit?: number,
    offset?: number,
    startDate?: string,
    endDate?: string,
    days?: number,
    contactNumber?: string,
    event?:
      | "sent"
      | "delivered"
      | "read"
      | "error"
      | "unsubscribe"
      | "reply"
      | "soft-bounce",
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetWhatsappEventReport }> {
    const localVarPath = this.basePath + "/whatsapp/statistics/events";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (days !== undefined) {
      localVarQueryParameters["days"] = ObjectSerializer.serialize(
        days,
        "number"
      );
    }

    if (contactNumber !== undefined) {
      localVarQueryParameters["contactNumber"] = ObjectSerializer.serialize(
        contactNumber,
        "string"
      );
    }

    if (event !== undefined) {
      localVarQueryParameters["event"] = ObjectSerializer.serialize(
        event,
        "'sent' | 'delivered' | 'read' | 'error' | 'unsubscribe' | 'reply' | 'soft-bounce'"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetWhatsappEventReport;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetWhatsappEventReport");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This endpoint is used to send a WhatsApp message. <br/>(**The first message you send using the API must contain a Template ID. You must create a template on WhatsApp on the Brevo platform to fetch the Template ID.**)
   * @summary Send a WhatsApp message
   * @param sendWhatsappMessage Values to send WhatsApp message
   * @param {*} [options] Override http request options.
   */
  public sendWhatsappMessage(
    sendWhatsappMessage: SendWhatsappMessage,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: InlineResponse2012 }> {
    const localVarPath = this.basePath + "/whatsapp/sendMessage";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'sendWhatsappMessage' is not null or undefined
    if (sendWhatsappMessage === null || sendWhatsappMessage === undefined) {
      throw new Error(
        "Required parameter sendWhatsappMessage was null or undefined when calling sendWhatsappMessage."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        sendWhatsappMessage,
        "SendWhatsappMessage"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: InlineResponse2012;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "InlineResponse2012");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum WebhooksApiApiKeys {
  apiKey,
  partnerKey,
}

export class WebhooksApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: WebhooksApiApiKeys, value: string) {
    (this.authentications as any)[WebhooksApiApiKeys[key]].apiKey = value;
  }
  /**
   *
   * @summary Create a webhook
   * @param createWebhook Values to create a webhook
   * @param {*} [options] Override http request options.
   */
  public createWebhook(
    createWebhook: CreateWebhook,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/webhooks";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'createWebhook' is not null or undefined
    if (createWebhook === null || createWebhook === undefined) {
      throw new Error(
        "Required parameter createWebhook was null or undefined when calling createWebhook."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(createWebhook, "CreateWebhook"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a webhook
   * @param webhookId Id of the webhook
   * @param {*} [options] Override http request options.
   */
  public deleteWebhook(
    webhookId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/webhooks/{webhookId}".replace(
        "{" + "webhookId" + "}",
        encodeURIComponent(String(webhookId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'webhookId' is not null or undefined
    if (webhookId === null || webhookId === undefined) {
      throw new Error(
        "Required parameter webhookId was null or undefined when calling deleteWebhook."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * This endpoint will submit a request to get the history of webhooks in the CSV file. The link to download that CSV file will send to the webhook link provided in notifyURL of the body payload.
   * @summary Export all transactional events
   * @param exportWebhookHistory Values to submit for webhooks history
   * @param {*} [options] Override http request options.
   */
  public exportWebhooksHistory(
    exportWebhookHistory: ExportWebhooksHistory,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreatedProcessId }> {
    const localVarPath = this.basePath + "/webhooks/export";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'exportWebhookHistory' is not null or undefined
    if (exportWebhookHistory === null || exportWebhookHistory === undefined) {
      throw new Error(
        "Required parameter exportWebhookHistory was null or undefined when calling exportWebhooksHistory."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        exportWebhookHistory,
        "ExportWebhooksHistory"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: CreatedProcessId;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "CreatedProcessId");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get a webhook details
   * @param webhookId Id of the webhook
   * @param {*} [options] Override http request options.
   */
  public getWebhook(
    webhookId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetWebhook }> {
    const localVarPath =
      this.basePath +
      "/webhooks/{webhookId}".replace(
        "{" + "webhookId" + "}",
        encodeURIComponent(String(webhookId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'webhookId' is not null or undefined
    if (webhookId === null || webhookId === undefined) {
      throw new Error(
        "Required parameter webhookId was null or undefined when calling getWebhook."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetWebhook }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetWebhook");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get all webhooks
   * @param type Filter on webhook type
   * @param sort Sort the results in the ascending/descending order of webhook creation
   * @param {*} [options] Override http request options.
   */
  public getWebhooks(
    type?: "marketing" | "transactional" | "inbound",
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetWebhooks }> {
    const localVarPath = this.basePath + "/webhooks";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (type !== undefined) {
      localVarQueryParameters["type"] = ObjectSerializer.serialize(
        type,
        "'marketing' | 'transactional' | 'inbound'"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: GetWebhooks }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "GetWebhooks");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Update a webhook
   * @param webhookId Id of the webhook
   * @param updateWebhook Values to update a webhook
   * @param {*} [options] Override http request options.
   */
  public updateWebhook(
    webhookId: number,
    updateWebhook: UpdateWebhook,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/webhooks/{webhookId}".replace(
        "{" + "webhookId" + "}",
        encodeURIComponent(String(webhookId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'webhookId' is not null or undefined
    if (webhookId === null || webhookId === undefined) {
      throw new Error(
        "Required parameter webhookId was null or undefined when calling updateWebhook."
      );
    }

    // verify required parameter 'updateWebhook' is not null or undefined
    if (updateWebhook === null || updateWebhook === undefined) {
      throw new Error(
        "Required parameter updateWebhook was null or undefined when calling updateWebhook."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "PUT",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateWebhook, "UpdateWebhook"),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum WhatsAppCampaignsApiApiKeys {
  apiKey,
  partnerKey,
}

export class WhatsAppCampaignsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {
    "user-agent": `brevo_clientAPI/v${version}/ts-node`,
  };
  protected _useQuerystring = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "api-key"),
    partnerKey: new ApiKeyAuth("header", "partner-key"),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: WhatsAppCampaignsApiApiKeys, value: string) {
    (this.authentications as any)[WhatsAppCampaignsApiApiKeys[key]].apiKey =
      value;
  }
  /**
   *
   * @summary Create and Send a WhatsApp campaign
   * @param whatsAppCampaigns Values to create a campaign
   * @param {*} [options] Override http request options.
   */
  public createWhatsAppCampaign(
    whatsAppCampaigns: CreateWhatsAppCampaign,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/whatsappCampaigns";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'whatsAppCampaigns' is not null or undefined
    if (whatsAppCampaigns === null || whatsAppCampaigns === undefined) {
      throw new Error(
        "Required parameter whatsAppCampaigns was null or undefined when calling createWhatsAppCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        whatsAppCampaigns,
        "CreateWhatsAppCampaign"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Create a WhatsApp template
   * @param whatsAppTemplates Values to create a template
   * @param {*} [options] Override http request options.
   */
  public createWhatsAppTemplate(
    whatsAppTemplates: CreateWhatsAppTemplate,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: CreateModel }> {
    const localVarPath = this.basePath + "/whatsppCampaigns/template";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'whatsAppTemplates' is not null or undefined
    if (whatsAppTemplates === null || whatsAppTemplates === undefined) {
      throw new Error(
        "Required parameter whatsAppTemplates was null or undefined when calling createWhatsAppTemplate."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        whatsAppTemplates,
        "CreateWhatsAppTemplate"
      ),
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body: CreateModel }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "CreateModel");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Delete a WhatsApp campaign
   * @param campaignId id of the campaign
   * @param {*} [options] Override http request options.
   */
  public deleteWhatsAppCampaign(
    campaignId: number,
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/whatsappCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling deleteWhatsAppCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: http.IncomingMessage; body?: any }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   *
   * @summary Get a WhatsApp campaign
   * @param campaignId Id of the campaign
   * @param {*} [options] Override http request options.
   */
  public getWhatsAppCampaign(
    campaignId: number,
    options: any = {}
  ): Promise<{
    response: http.IncomingMessage;
    body: GetWhatsappCampaignOverview;
  }> {
    const localVarPath =
      this.basePath +
      "/whatsappCampaigns/{campaignId}".replace(
        "{" + "campaignId" + "}",
        encodeURIComponent(String(campaignId))
      );
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    // verify required parameter 'campaignId' is not null or undefined
    if (campaignId === null || campaignId === undefined) {
      throw new Error(
        "Required parameter campaignId was null or undefined when calling getWhatsAppCampaign."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetWhatsappCampaignOverview;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(
            body,
            "GetWhatsappCampaignOverview"
          );
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Return all your created WhatsApp campaigns
   * @param startDate **Mandatory if endDate is used**. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the campaigns created. **Prefer to pass your timezone in date-time format for accurate result**
   * @param endDate **Mandatory if startDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the campaigns created. **Prefer to pass your timezone in date-time format for accurate result**
   * @param limit Number of documents per page
   * @param offset Index of the first document in the page
   * @param sort Sort the results in the ascending/descending order of record modification. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getWhatsAppCampaigns(
    startDate?: string,
    endDate?: string,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetWhatsappCampaigns }> {
    const localVarPath = this.basePath + "/whatsappCampaigns";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetWhatsappCampaigns;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetWhatsappCampaigns");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Get your WhatsApp API account information
   * @param {*} [options] Override http request options.
   */
  public getWhatsAppConfig(
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetWhatsAppConfig }> {
    const localVarPath = this.basePath + "/whatsappCampaigns/config";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetWhatsAppConfig;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetWhatsAppConfig");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   *
   * @summary Return all your created WhatsApp templates
   * @param startDate **Mandatory if endDate is used**. Starting (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the templates created. **Prefer to pass your timezone in date-time format for accurate result**
   * @param endDate **Mandatory if startDate is used**. Ending (urlencoded) UTC date-time (YYYY-MM-DDTHH:mm:ss.SSSZ) to filter the templates created. **Prefer to pass your timezone in date-time format for accurate result**
   * @param limit Number of documents per page
   * @param offset Index of the first document in the page
   * @param sort Sort the results in the ascending/descending order of record modification. Default order is **descending** if &#x60;sort&#x60; is not passed
   * @param {*} [options] Override http request options.
   */
  public getWhatsAppTemplates(
    startDate?: string,
    endDate?: string,
    limit?: number,
    offset?: number,
    sort?: "asc" | "desc",
    options: any = {}
  ): Promise<{ response: http.IncomingMessage; body: GetWATemplates }> {
    const localVarPath = this.basePath + "/whatsappCampaigns/template-list";
    const localVarQueryParameters: any = {};
    const localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    const localVarFormParams: any = {};

    if (startDate !== undefined) {
      localVarQueryParameters["startDate"] = ObjectSerializer.serialize(
        startDate,
        "string"
      );
    }

    if (endDate !== undefined) {
      localVarQueryParameters["endDate"] = ObjectSerializer.serialize(
        endDate,
        "string"
      );
    }

    if (limit !== undefined) {
      localVarQueryParameters["limit"] = ObjectSerializer.serialize(
        limit,
        "number"
      );
    }

    if (offset !== undefined) {
      localVarQueryParameters["offset"] = ObjectSerializer.serialize(
        offset,
        "number"
      );
    }

    if (sort !== undefined) {
      localVarQueryParameters["sort"] = ObjectSerializer.serialize(
        sort,
        "'asc' | 'desc'"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    const localVarUseFormData = false;

    const localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.apiKey.applyToRequest(localVarRequestOptions);

    this.authentications.partnerKey.applyToRequest(localVarRequestOptions);

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: http.IncomingMessage;
      body: GetWATemplates;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "GetWATemplates");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
